<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CraftMine - Minecraft Clone</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { overflow: hidden; background: #000; font-family: 'Segoe UI', Arial, sans-serif; }
        #game-container { width: 100vw; height: 100vh; cursor: none; }

        #crosshair {
            position: fixed; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none; z-index: 100;
            transition: all 0.1s ease;
        }
        #crosshair.default { width: 24px; height: 24px; }
        #crosshair.default::before, #crosshair.default::after {
            content: ''; position: absolute; background: white; mix-blend-mode: difference;
        }
        #crosshair.default::before { width: 2px; height: 24px; left: 11px; top: 0; }
        #crosshair.default::after { width: 24px; height: 2px; top: 11px; left: 0; }

        #crosshair.gun { width: 40px; height: 40px; border: 2px solid #ff4444; border-radius: 50%; background: transparent; }
        #crosshair.gun::before { content: ''; position: absolute; width: 6px; height: 6px; background: #ff4444; border-radius: 50%; top: 50%; left: 50%; transform: translate(-50%, -50%); }

        #crosshair.laser { width: 30px; height: 30px; border: 2px solid #00ffff; background: transparent; }
        #crosshair.laser::before, #crosshair.laser::after { content: ''; position: absolute; background: #00ffff; }
        #crosshair.laser::before { width: 2px; height: 30px; left: 12px; top: -2px; }
        #crosshair.laser::after { width: 30px; height: 2px; top: 12px; left: -2px; }

        #crosshair.railgun { width: 50px; height: 50px; border: 3px solid #ff00ff; border-radius: 50%; background: transparent; animation: pulse 0.5s infinite; }
        @keyframes pulse { 0%, 100% { transform: translate(-50%, -50%) scale(1); opacity: 1; } 50% { transform: translate(-50%, -50%) scale(1.1); opacity: 0.7; } }

        #hotbar {
            position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 4px; padding: 6px;
            background: rgba(0, 0, 0, 0.7); border-radius: 8px; z-index: 100;
            border: 2px solid rgba(255,255,255,0.2);
        }
        .hotbar-slot {
            width: 54px; height: 54px; border: 2px solid #444;
            background: rgba(60, 60, 60, 0.8); display: flex;
            align-items: center; justify-content: center;
            position: relative; border-radius: 4px; transition: all 0.15s ease;
        }
        .hotbar-slot.selected { border-color: #fff; box-shadow: 0 0 15px rgba(255,255,255,0.6); transform: scale(1.05); }
        .hotbar-slot span { position: absolute; bottom: 2px; right: 4px; font-size: 10px; color: #fff; text-shadow: 1px 1px 2px #000; }
        .block-preview { width: 40px; height: 40px; border-radius: 3px; overflow: hidden; display: flex; align-items: center; justify-content: center; }

        #debug {
            position: fixed; top: 10px; left: 10px; color: white;
            font-family: 'Consolas', monospace; font-size: 12px;
            background: rgba(0, 0, 0, 0.75); padding: 12px 15px;
            border-radius: 6px; z-index: 100; line-height: 1.7;
            border: 1px solid rgba(255,255,255,0.1);
        }

        #weapon-info {
            position: fixed; bottom: 100px; left: 50%; transform: translateX(-50%);
            color: white; font-family: 'Consolas', monospace; font-size: 18px;
            text-shadow: 2px 2px 4px #000; z-index: 100; text-align: center;
            opacity: 0; transition: opacity 0.3s;
        }
        #weapon-info.show { opacity: 1; }

        #muzzle-flash {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 150px; height: 150px;
            background: radial-gradient(circle, rgba(255,200,50,0.9) 0%, rgba(255,100,0,0.5) 30%, transparent 60%);
            pointer-events: none; z-index: 99; opacity: 0; transition: opacity 0.03s;
        }
        #muzzle-flash.flash { opacity: 1; }

        #damage-overlay {
            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            pointer-events: none; z-index: 98;
            background: radial-gradient(circle, transparent 40%, rgba(255,0,0,0.3) 100%);
            opacity: 0; transition: opacity 0.2s;
        }
        #damage-overlay.show { opacity: 1; }

        #water-overlay {
            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            pointer-events: none; z-index: 97;
            background: radial-gradient(ellipse at center, rgba(30,80,150,0.3) 0%, rgba(20,60,120,0.5) 100%);
            opacity: 0; transition: opacity 0.3s;
        }
        #water-overlay.show { opacity: 1; }
        #water-overlay::before {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: repeating-linear-gradient(
                0deg,
                transparent,
                transparent 4px,
                rgba(100, 180, 255, 0.1) 4px,
                rgba(100, 180, 255, 0.1) 8px
            );
            animation: waterWave 2s linear infinite;
        }
        @keyframes waterWave {
            0% { transform: translateY(0); }
            100% { transform: translateY(8px); }
        }

        #air-meter {
            position: fixed; top: 60px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 4px; opacity: 0; transition: opacity 0.3s; z-index: 100;
        }
        #air-meter.show { opacity: 1; }
        .air-bubble {
            width: 16px; height: 16px; border-radius: 50%;
            background: radial-gradient(circle at 30% 30%, rgba(200, 230, 255, 0.9), rgba(100, 180, 255, 0.6));
            border: 2px solid rgba(255, 255, 255, 0.5);
            box-shadow: inset 0 -2px 4px rgba(0,0,0,0.2);
        }
        .air-bubble.empty {
            background: rgba(50, 80, 120, 0.3);
            border-color: rgba(100, 150, 200, 0.3);
        }

        #click-to-start {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; font-size: 24px; text-align: center; z-index: 300;
            text-shadow: 2px 2px 4px #000; cursor: pointer;
            animation: breathe 2s infinite;
        }
        @keyframes breathe { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }

        .vignette {
            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            pointer-events: none; z-index: 50;
            background: radial-gradient(ellipse at center, transparent 50%, rgba(0,0,0,0.4) 100%);
        }

        #pause-menu {
            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.8); z-index: 400; display: none;
            flex-direction: column; align-items: center; justify-content: center;
        }
        #pause-menu.show { display: flex; }
        #pause-menu h1 { color: white; font-size: 48px; margin-bottom: 40px; text-shadow: 3px 3px 6px #000; }
        .menu-btn {
            background: linear-gradient(180deg, #5a5a5a 0%, #3a3a3a 100%);
            border: 3px solid #222; color: white; padding: 15px 60px;
            font-size: 18px; margin: 8px; cursor: pointer; border-radius: 4px;
            min-width: 250px; text-shadow: 1px 1px 2px #000;
        }
        .menu-btn:hover { background: linear-gradient(180deg, #6a6a6a 0%, #4a4a4a 100%); }

        #health-bar {
            position: fixed; bottom: 90px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 2px; z-index: 100;
        }
        .heart { width: 18px; height: 18px; background: #ff0000; clip-path: path('M9 3C6.5 0 0 0 0 6c0 4 9 10 9 10s9-6 9-10c0-6-6.5-6-9-3z'); transition: opacity 0.2s; }
        .heart.empty { background: #333; }
        .heart.half { background: linear-gradient(90deg, #ff0000 50%, #333 50%); }

        #game-mode {
            position: fixed; top: 10px; right: 10px; color: white;
            font-family: 'Consolas', monospace; font-size: 14px;
            background: rgba(0, 0, 0, 0.75); padding: 8px 12px;
            border-radius: 6px; z-index: 100;
        }
        #game-version {
            position: fixed; bottom: 10px; right: 10px; color: rgba(255,255,255,0.5);
            font-family: 'Consolas', monospace; font-size: 11px;
            z-index: 100; pointer-events: none;
        }

        .rain {
            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            pointer-events: none; z-index: 45; opacity: 0;
            background: repeating-linear-gradient(transparent, transparent 5px, rgba(200,200,255,0.1) 5px, rgba(200,200,255,0.1) 10px);
            animation: rain-fall 0.2s linear infinite;
        }
        .rain.active { opacity: 1; }
        @keyframes rain-fall { 0% { background-position: 0 0; } 100% { background-position: 20px 40px; } }

        #time-display {
            position: fixed; top: 50px; left: 10px; color: white;
            font-family: 'Consolas', monospace; font-size: 12px;
            background: rgba(0, 0, 0, 0.75); padding: 8px 12px;
            border-radius: 6px; z-index: 100;
        }

        /* Lobby UI */
        #lobby {
            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            background: linear-gradient(180deg, #1a0a2e 0%, #0d1b2a 50%, #1b2838 100%);
            z-index: 500; display: flex; flex-direction: column;
            align-items: center; justify-content: center;
        }
        #lobby.hidden { display: none; }
        #lobby h1 {
            font-size: 64px; color: #55ff55; margin-bottom: 10px;
            text-shadow: 3px 3px 6px #000, 0 0 20px rgba(85,255,85,0.3);
            font-family: 'Segoe UI', Arial, sans-serif; letter-spacing: 4px;
        }
        #lobby .subtitle { color: #888; font-size: 14px; margin-bottom: 40px; }
        .lobby-btn {
            background: linear-gradient(180deg, #4a7a4a 0%, #2a5a2a 100%);
            border: 3px solid #1a3a1a; color: white; padding: 16px 60px;
            font-size: 20px; margin: 8px; cursor: pointer; border-radius: 6px;
            min-width: 280px; text-shadow: 1px 1px 2px #000;
            transition: all 0.2s ease; font-family: 'Segoe UI', Arial, sans-serif;
        }
        .lobby-btn:hover { background: linear-gradient(180deg, #5a9a5a 0%, #3a7a3a 100%); transform: scale(1.02); }
        .lobby-btn.secondary {
            background: linear-gradient(180deg, #5a5a5a 0%, #3a3a3a 100%);
            border-color: #222;
        }
        .lobby-btn.secondary:hover { background: linear-gradient(180deg, #6a6a6a 0%, #4a4a4a 100%); }
        #join-input {
            background: rgba(0,0,0,0.6); border: 2px solid #555; color: white;
            padding: 14px 20px; font-size: 20px; border-radius: 6px;
            text-align: center; width: 280px; margin: 8px;
            font-family: 'Consolas', monospace; letter-spacing: 4px;
        }
        #join-input::placeholder { color: #666; letter-spacing: 2px; }
        #join-input:focus { outline: none; border-color: #55ff55; }
        #lobby-status {
            color: #aaa; font-size: 14px; margin-top: 15px;
            min-height: 20px; text-align: center;
        }
        #room-info {
            color: #55ff55; font-size: 18px; margin-top: 15px;
            font-family: 'Consolas', monospace; display: none;
            text-align: center;
        }
        #room-info .room-code {
            font-size: 48px; letter-spacing: 8px; display: block;
            margin: 12px 0; color: #ffff55; cursor: pointer;
            background: rgba(0,0,0,0.4); padding: 12px 24px;
            border-radius: 8px; border: 2px dashed rgba(255,255,85,0.4);
            transition: all 0.2s ease; user-select: all;
        }
        #room-info .room-code:hover {
            background: rgba(255,255,85,0.1);
            border-color: rgba(255,255,85,0.8);
        }
        #room-info .copy-hint {
            color: #888; font-size: 12px; margin-bottom: 8px;
        }
        #room-info .copied-msg {
            color: #55ff55; font-size: 14px; opacity: 0;
            transition: opacity 0.3s;
        }
        #room-info .copied-msg.show { opacity: 1; }
        .lobby-btns { display: contents; }
        .lobby-btns.hidden { display: none; }

        /* In-game room code badge */
        #room-badge {
            position: fixed; top: 10px; left: 50%; transform: translateX(-50%);
            color: #ffff55; font-family: 'Consolas', monospace; font-size: 14px;
            background: rgba(0,0,0,0.75); padding: 6px 14px;
            border-radius: 6px; z-index: 100; display: none;
            cursor: pointer; border: 1px solid rgba(255,255,85,0.3);
            transition: all 0.2s;
        }
        #room-badge:hover { background: rgba(255,255,85,0.15); border-color: rgba(255,255,85,0.7); }

        /* Host migration overlay */
        #migration-overlay {
            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.85); z-index: 450;
            display: none; flex-direction: column;
            align-items: center; justify-content: center;
        }
        #migration-overlay.show { display: flex; }
        #migration-overlay h2 { color: #ffaa00; font-size: 32px; margin-bottom: 10px; }
        #migration-overlay p { color: #aaa; font-size: 16px; }
        .spinner {
            width: 40px; height: 40px; border: 4px solid #333;
            border-top: 4px solid #ffaa00; border-radius: 50%;
            animation: spin 1s linear infinite; margin: 20px;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* Chat */
        #chat-box {
            position: fixed; bottom: 100px; left: 10px;
            width: 350px; z-index: 200; pointer-events: none;
        }
        #chat-messages {
            max-height: 200px; overflow-y: auto; padding: 5px;
            display: flex; flex-direction: column; gap: 2px;
        }
        .chat-msg {
            color: white; font-family: 'Consolas', monospace; font-size: 13px;
            text-shadow: 1px 1px 2px #000; padding: 2px 4px;
            background: rgba(0,0,0,0.4); border-radius: 3px;
            opacity: 1; transition: opacity 0.5s;
        }
        .chat-msg.faded { opacity: 0; }
        #chat-input-wrap {
            display: none; pointer-events: auto; margin-top: 4px;
        }
        #chat-input-wrap.show { display: block; }
        #chat-input {
            width: 100%; background: rgba(0,0,0,0.7); border: 1px solid #555;
            color: white; padding: 6px 10px; font-size: 13px;
            font-family: 'Consolas', monospace; border-radius: 3px;
        }
        #chat-input:focus { outline: none; border-color: #55ff55; }

        /* Player count HUD */
        #player-count {
            position: fixed; top: 40px; right: 10px; color: white;
            font-family: 'Consolas', monospace; font-size: 13px;
            background: rgba(0,0,0,0.75); padding: 6px 10px;
            border-radius: 6px; z-index: 100; display: none;
        }
    </style>
</head>
<body>
    <div id="game-container"></div>
    <div id="crosshair" class="default" style="display:none;"></div>
    <div id="muzzle-flash"></div>
    <div id="damage-overlay"></div>
    <div id="water-overlay"></div>
    <div id="air-meter"></div>
    <div class="vignette"></div>
    <div id="hotbar" style="display:none;"></div>
    <div id="debug" style="display:none;"></div>
    <div id="weapon-info"></div>
    <div id="lobby">
        <h1>CRAFTMINE</h1>
        <div class="subtitle">A Voxel Adventure</div>
        <div class="lobby-btns" id="lobby-btns">
            <button class="lobby-btn" id="btn-singleplayer">Singleplayer</button>
            <button class="lobby-btn secondary" id="btn-host">Host Game</button>
            <input type="text" id="join-input" placeholder="Room Code" maxlength="8" autocomplete="off">
            <button class="lobby-btn secondary" id="btn-join">Join Game</button>
        </div>
        <div id="lobby-status"></div>
        <div id="room-info">
            Share this code with friends:<br>
            <span class="room-code" id="room-code-display"></span>
            <div class="copy-hint">Click the code to copy</div>
            <div class="copied-msg" id="copied-msg">Copied!</div>
            <span id="room-player-count">1 player connected</span>
            <br>
            <button class="lobby-btn" id="btn-start-host" style="margin-top:16px;">Start Game</button>
            <button class="lobby-btn secondary" id="btn-cancel-host" style="margin-top:4px;padding:10px 40px;font-size:16px;">Cancel</button>
        </div>
    </div>
    <div id="room-badge"></div>
    <div id="migration-overlay">
        <h2>Host Migrating...</h2>
        <div class="spinner"></div>
        <p>Transferring world to new host</p>
    </div>
    <div id="chat-box">
        <div id="chat-messages"></div>
        <div id="chat-input-wrap">
            <input type="text" id="chat-input" placeholder="Type a message..." maxlength="200">
        </div>
    </div>
    <div id="player-count"></div>
    <div id="click-to-start" style="display:none;">Click to Play<br><small>WASD to move | Mouse to look | Scroll to switch weapons</small></div>
    <div id="pause-menu">
        <h1>PAUSED</h1>
        <button class="menu-btn" id="resume-btn">Resume Game</button>
        <button class="menu-btn" id="creative-btn">Toggle Creative Mode</button>
        <button class="menu-btn" id="weather-btn">Toggle Weather</button>
        <button class="menu-btn" id="time-btn">Toggle Time Cycle</button>
        <button class="menu-btn" id="disconnect-btn" style="display:none;color:#ff5555;">Disconnect</button>
    </div>
    <div id="health-bar" style="display:none;"></div>
    <div id="game-mode" style="display:none;">Survival</div>
    <div id="game-version">v0.8.0-mp</div>
    <div id="time-display" style="display:none;">Day 1 - 12:00</div>
    <div class="rain"></div>

    <script src="https://unpkg.com/peerjs@1.5.4/dist/peerjs.min.js"></script>
    <script type="importmap">
    { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // ============================================
        // AUDIO SYSTEM - Synthesized sounds
        // ============================================
        class AudioSystem {
            constructor() {
                this.ctx = null;
                this.initialized = false;
                this.masterVolume = 0.4;
                this.compressor = null;
                this.reverb = null;
            }

            init() {
                if (this.initialized) return;
                this.ctx = new (window.AudioContext || window.webkitAudioContext)();

                // Master compressor for punchier sound
                this.compressor = this.ctx.createDynamicsCompressor();
                this.compressor.threshold.value = -24;
                this.compressor.knee.value = 30;
                this.compressor.ratio.value = 12;
                this.compressor.attack.value = 0.003;
                this.compressor.release.value = 0.25;
                this.compressor.connect(this.ctx.destination);

                // Create reverb impulse response
                this.createReverb();
                this.initialized = true;
            }

            createReverb() {
                const length = this.ctx.sampleRate * 1.5;
                const impulse = this.ctx.createBuffer(2, length, this.ctx.sampleRate);
                for (let channel = 0; channel < 2; channel++) {
                    const data = impulse.getChannelData(channel);
                    for (let i = 0; i < length; i++) {
                        data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, 2.5);
                    }
                }
                this.reverb = this.ctx.createConvolver();
                this.reverb.buffer = impulse;
            }

            play(type, options = {}) {
                if (!this.initialized) return;
                const now = this.ctx.currentTime;
                switch(type) {
                    case 'shoot_tnt': this.playTNTShoot(now); break;
                    case 'shoot_laser': this.playLaserShoot(now); break;
                    case 'shoot_railgun': this.playRailgunShoot(now); break;
                    case 'shoot_minigun': this.playMinigunShoot(now); break;
                    case 'explosion': this.playExplosion(now, options.size || 1); break;
                    case 'explosion_big': this.playBigExplosion(now); break;
                    case 'hit': this.playHit(now); break;
                    case 'place': this.playPlace(now); break;
                    case 'break': this.playBreak(now); break;
                    case 'freeze': this.playFreeze(now); break;
                    case 'sword': this.playSword(now); break;
                    case 'bow': this.playBow(now); break;
                    case 'throw': this.playThrow(now); break;
                    case 'footstep': this.playFootstep(now); break;
                    case 'hurt': this.playHurt(now); break;
                    case 'jump': this.playJump(now); break;
                    case 'land': this.playLand(now); break;
                    case 'ambient': this.playAmbient(now); break;
                    // DOOM-style sounds
                    case 'shotgun': this.playShotgun(now); break;
                    case 'rocket': this.playRocket(now); break;
                    case 'plasma': this.playPlasma(now); break;
                    case 'bfg': this.playBFG(now); break;
                    case 'nuke': this.playNuke(now); break;
                    case 'demon_growl': this.playDemonGrowl(now); break;
                    case 'demon_death': this.playDemonDeath(now); break;
                    case 'gore': this.playGore(now); break;
                    case 'metal_impact': this.playMetalImpact(now); break;
                    case 'pickup': this.playPickup(now); break;
                    case 'powerup': this.playPowerup(now); break;
                    case 'chainsaw': this.playChainsaw(now); break;
                    case 'lightning': this.playLightning(now); break;
                    case 'black_hole': this.playBlackHole(now); break;
                    case 'splash': this.playSplash(now); break;
                    case 'underwater': this.playUnderwater(now); break;
                }
            }

            createGain(volume = 1) {
                const gain = this.ctx.createGain();
                gain.gain.value = volume * this.masterVolume;
                gain.connect(this.compressor);
                return gain;
            }

            createReverbSend(dryGain, wetAmount = 0.2) {
                const wet = this.ctx.createGain();
                wet.gain.value = wetAmount * this.masterVolume;
                wet.connect(this.reverb);
                this.reverb.connect(this.compressor);
                return wet;
            }

            createDistortion(amount = 50) {
                const dist = this.ctx.createWaveShaper();
                const samples = 44100;
                const curve = new Float32Array(samples);
                for (let i = 0; i < samples; i++) {
                    const x = (i * 2) / samples - 1;
                    curve[i] = ((3 + amount) * x * 20 * (Math.PI / 180)) / (Math.PI + amount * Math.abs(x));
                }
                dist.curve = curve;
                dist.oversample = '4x';
                return dist;
            }

            playTNTShoot(now) {
                // Punchy thump
                const kick = this.ctx.createOscillator();
                const kickGain = this.createGain(0.6);
                kick.type = 'sine';
                kick.frequency.setValueAtTime(150, now);
                kick.frequency.exponentialRampToValueAtTime(40, now + 0.08);
                kickGain.gain.setValueAtTime(0.6 * this.masterVolume, now);
                kickGain.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
                kick.connect(kickGain);
                kick.start(now);
                kick.stop(now + 0.15);

                // Mechanical clunk
                const clunk = this.ctx.createOscillator();
                const clunkGain = this.createGain(0.3);
                clunk.type = 'square';
                clunk.frequency.setValueAtTime(80, now);
                clunk.frequency.setValueAtTime(60, now + 0.02);
                clunkGain.gain.exponentialRampToValueAtTime(0.001, now + 0.08);
                clunk.connect(clunkGain);
                clunk.start(now);
                clunk.stop(now + 0.08);

                // Hiss
                const noiseLen = this.ctx.sampleRate * 0.15;
                const noiseBuf = this.ctx.createBuffer(1, noiseLen, this.ctx.sampleRate);
                const noiseData = noiseBuf.getChannelData(0);
                for (let i = 0; i < noiseLen; i++) noiseData[i] = (Math.random() * 2 - 1) * Math.pow(1 - i/noiseLen, 1.5);
                const noise = this.ctx.createBufferSource();
                noise.buffer = noiseBuf;
                const noiseFilter = this.ctx.createBiquadFilter();
                noiseFilter.type = 'bandpass';
                noiseFilter.frequency.value = 2000;
                noiseFilter.Q.value = 1;
                const noiseGain = this.createGain(0.25);
                noise.connect(noiseFilter);
                noiseFilter.connect(noiseGain);
                noise.start(now);
            }

            playLaserShoot(now) {
                // Pew pew - descending sine with harmonics
                for (let i = 0; i < 3; i++) {
                    const osc = this.ctx.createOscillator();
                    const gain = this.createGain(0.2 / (i + 1));
                    osc.type = i === 0 ? 'sine' : 'triangle';
                    const baseFreq = 1200 * (i + 1);
                    osc.frequency.setValueAtTime(baseFreq, now);
                    osc.frequency.exponentialRampToValueAtTime(baseFreq * 0.2, now + 0.12);
                    gain.gain.setValueAtTime(0.2 / (i + 1) * this.masterVolume, now);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
                    osc.connect(gain);
                    osc.start(now);
                    osc.stop(now + 0.15);
                }

                // Electric crackle
                const crackleLen = this.ctx.sampleRate * 0.1;
                const crackleBuf = this.ctx.createBuffer(1, crackleLen, this.ctx.sampleRate);
                const crackleData = crackleBuf.getChannelData(0);
                for (let i = 0; i < crackleLen; i++) {
                    crackleData[i] = (Math.random() > 0.95 ? (Math.random() * 2 - 1) : 0) * (1 - i/crackleLen);
                }
                const crackle = this.ctx.createBufferSource();
                crackle.buffer = crackleBuf;
                const crackleGain = this.createGain(0.15);
                crackle.connect(crackleGain);
                crackle.start(now);
            }

            playRailgunShoot(now) {
                // Intense charge-up whine
                const charge = this.ctx.createOscillator();
                const chargeGain = this.createGain(0.35);
                const chargeFilter = this.ctx.createBiquadFilter();
                chargeFilter.type = 'bandpass';
                chargeFilter.Q.value = 5;
                charge.type = 'sawtooth';
                charge.frequency.setValueAtTime(80, now);
                charge.frequency.exponentialRampToValueAtTime(3000, now + 0.12);
                chargeFilter.frequency.setValueAtTime(200, now);
                chargeFilter.frequency.exponentialRampToValueAtTime(4000, now + 0.12);
                chargeGain.gain.setValueAtTime(0.01, now);
                chargeGain.gain.linearRampToValueAtTime(0.35 * this.masterVolume, now + 0.1);
                chargeGain.gain.exponentialRampToValueAtTime(0.001, now + 0.5);
                charge.connect(chargeFilter);
                chargeFilter.connect(chargeGain);
                charge.start(now);
                charge.stop(now + 0.5);

                // Massive bass drop with distortion
                const bass = this.ctx.createOscillator();
                const bassGain = this.createGain(0.7);
                const dist = this.createDistortion(100);
                bass.type = 'sine';
                bass.frequency.setValueAtTime(60, now + 0.12);
                bass.frequency.exponentialRampToValueAtTime(15, now + 0.6);
                bassGain.gain.setValueAtTime(0.7 * this.masterVolume, now + 0.12);
                bassGain.gain.exponentialRampToValueAtTime(0.001, now + 0.6);
                bass.connect(dist);
                dist.connect(bassGain);
                bass.start(now + 0.12);
                bass.stop(now + 0.6);

                // Thunder crack
                const thunderLen = this.ctx.sampleRate * 0.4;
                const thunderBuf = this.ctx.createBuffer(1, thunderLen, this.ctx.sampleRate);
                const thunderData = thunderBuf.getChannelData(0);
                for (let i = 0; i < thunderLen; i++) {
                    const env = Math.pow(1 - i/thunderLen, 1.5);
                    thunderData[i] = (Math.random() * 2 - 1) * env * (Math.random() > 0.7 ? 2 : 0.5);
                }
                const thunder = this.ctx.createBufferSource();
                thunder.buffer = thunderBuf;
                const thunderFilter = this.ctx.createBiquadFilter();
                thunderFilter.type = 'lowpass';
                thunderFilter.frequency.setValueAtTime(5000, now + 0.12);
                thunderFilter.frequency.exponentialRampToValueAtTime(500, now + 0.5);
                const thunderGain = this.createGain(0.5);
                const thunderReverb = this.createReverbSend(thunderGain, 0.4);
                thunder.connect(thunderFilter);
                thunderFilter.connect(thunderGain);
                thunderFilter.connect(thunderReverb);
                thunder.start(now + 0.12);
            }

            playMinigunShoot(now) {
                // Rapid mechanical shot
                const pop = this.ctx.createOscillator();
                const popGain = this.createGain(0.2);
                pop.type = 'square';
                pop.frequency.setValueAtTime(150 + Math.random() * 80, now);
                pop.frequency.exponentialRampToValueAtTime(60, now + 0.025);
                popGain.gain.exponentialRampToValueAtTime(0.001, now + 0.04);
                pop.connect(popGain);
                pop.start(now);
                pop.stop(now + 0.04);

                // Shell casing tink
                const casing = this.ctx.createOscillator();
                const casingGain = this.createGain(0.08);
                casing.type = 'sine';
                casing.frequency.setValueAtTime(4000 + Math.random() * 2000, now + 0.02);
                casing.frequency.exponentialRampToValueAtTime(1000, now + 0.06);
                casingGain.gain.exponentialRampToValueAtTime(0.001, now + 0.06);
                casing.connect(casingGain);
                casing.start(now + 0.02);
                casing.stop(now + 0.06);

                // Click
                const clickLen = this.ctx.sampleRate * 0.015;
                const clickBuf = this.ctx.createBuffer(1, clickLen, this.ctx.sampleRate);
                const clickData = clickBuf.getChannelData(0);
                for (let i = 0; i < clickLen; i++) clickData[i] = (Math.random() * 2 - 1) * Math.pow(1 - i/clickLen, 4);
                const click = this.ctx.createBufferSource();
                click.buffer = clickBuf;
                const clickGain = this.createGain(0.35);
                click.connect(clickGain);
                click.start(now);
            }

            playExplosion(now, size = 1) {
                // Sub bass thump
                const sub = this.ctx.createOscillator();
                const subGain = this.createGain(0.8 * size);
                sub.type = 'sine';
                sub.frequency.setValueAtTime(80 * size, now);
                sub.frequency.exponentialRampToValueAtTime(10, now + 0.4);
                subGain.gain.setValueAtTime(0.8 * size * this.masterVolume, now);
                subGain.gain.exponentialRampToValueAtTime(0.001, now + 0.5);
                sub.connect(subGain);
                sub.start(now);
                sub.stop(now + 0.5);

                // Mid rumble
                const mid = this.ctx.createOscillator();
                const midGain = this.createGain(0.4 * size);
                const midDist = this.createDistortion(50);
                mid.type = 'sawtooth';
                mid.frequency.setValueAtTime(120, now);
                mid.frequency.exponentialRampToValueAtTime(30, now + 0.3);
                midGain.gain.exponentialRampToValueAtTime(0.001, now + 0.4);
                mid.connect(midDist);
                midDist.connect(midGain);
                mid.start(now);
                mid.stop(now + 0.4);

                // Layered noise burst
                const noiseLen = this.ctx.sampleRate * 0.8;
                const noiseBuf = this.ctx.createBuffer(2, noiseLen, this.ctx.sampleRate);
                for (let ch = 0; ch < 2; ch++) {
                    const data = noiseBuf.getChannelData(ch);
                    for (let i = 0; i < noiseLen; i++) {
                        const env = Math.pow(1 - i/noiseLen, 2);
                        const rumble = Math.sin(i * 0.01) * 0.3;
                        data[i] = ((Math.random() * 2 - 1) + rumble) * env;
                    }
                }
                const noise = this.ctx.createBufferSource();
                noise.buffer = noiseBuf;
                const noiseFilter = this.ctx.createBiquadFilter();
                noiseFilter.type = 'lowpass';
                noiseFilter.frequency.setValueAtTime(8000, now);
                noiseFilter.frequency.exponentialRampToValueAtTime(200, now + 0.6);
                const noiseGain = this.createGain(0.6 * size);
                const noiseReverb = this.createReverbSend(noiseGain, 0.3);
                noise.connect(noiseFilter);
                noiseFilter.connect(noiseGain);
                noiseFilter.connect(noiseReverb);
                noise.start(now);

                // Debris crackle
                const debrisLen = this.ctx.sampleRate * 0.5;
                const debrisBuf = this.ctx.createBuffer(1, debrisLen, this.ctx.sampleRate);
                const debrisData = debrisBuf.getChannelData(0);
                for (let i = 0; i < debrisLen; i++) {
                    debrisData[i] = (Math.random() > 0.9 ? Math.random() * 2 - 1 : 0) * Math.pow(1 - i/debrisLen, 1.5);
                }
                const debris = this.ctx.createBufferSource();
                debris.buffer = debrisBuf;
                const debrisFilter = this.ctx.createBiquadFilter();
                debrisFilter.type = 'highpass';
                debrisFilter.frequency.value = 2000;
                const debrisGain = this.createGain(0.2 * size);
                debris.connect(debrisFilter);
                debrisFilter.connect(debrisGain);
                debris.start(now + 0.05);
            }

            playBigExplosion(now) {
                this.playExplosion(now, 2);
                setTimeout(() => this.playExplosion(this.ctx.currentTime, 1.5), 80);
                setTimeout(() => this.playExplosion(this.ctx.currentTime, 1.2), 160);
                setTimeout(() => this.playExplosion(this.ctx.currentTime, 0.8), 250);
            }

            playHit(now) {
                // Impact thud
                const thud = this.ctx.createOscillator();
                const thudGain = this.createGain(0.4);
                thud.type = 'sine';
                thud.frequency.setValueAtTime(200, now);
                thud.frequency.exponentialRampToValueAtTime(60, now + 0.08);
                thudGain.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
                thud.connect(thudGain);
                thud.start(now);
                thud.stop(now + 0.1);

                // Crunch
                const crunchLen = this.ctx.sampleRate * 0.08;
                const crunchBuf = this.ctx.createBuffer(1, crunchLen, this.ctx.sampleRate);
                const crunchData = crunchBuf.getChannelData(0);
                for (let i = 0; i < crunchLen; i++) crunchData[i] = (Math.random() * 2 - 1) * Math.pow(1 - i/crunchLen, 3);
                const crunch = this.ctx.createBufferSource();
                crunch.buffer = crunchBuf;
                const crunchFilter = this.ctx.createBiquadFilter();
                crunchFilter.type = 'bandpass';
                crunchFilter.frequency.value = 1500;
                crunchFilter.Q.value = 2;
                const crunchGain = this.createGain(0.3);
                crunch.connect(crunchFilter);
                crunchFilter.connect(crunchGain);
                crunch.start(now);
            }

            playPlace(now) {
                // Satisfying click-thunk
                const click = this.ctx.createOscillator();
                const clickGain = this.createGain(0.25);
                click.type = 'sine';
                click.frequency.setValueAtTime(800, now);
                click.frequency.exponentialRampToValueAtTime(400, now + 0.03);
                clickGain.gain.exponentialRampToValueAtTime(0.001, now + 0.05);
                click.connect(clickGain);
                click.start(now);
                click.stop(now + 0.05);

                const thunk = this.ctx.createOscillator();
                const thunkGain = this.createGain(0.2);
                thunk.type = 'triangle';
                thunk.frequency.setValueAtTime(150, now + 0.02);
                thunk.frequency.exponentialRampToValueAtTime(80, now + 0.1);
                thunkGain.gain.exponentialRampToValueAtTime(0.001, now + 0.12);
                thunk.connect(thunkGain);
                thunk.start(now + 0.02);
                thunk.stop(now + 0.12);
            }

            playBreak(now) {
                // Crumble sound
                const crumbleLen = this.ctx.sampleRate * 0.2;
                const crumbleBuf = this.ctx.createBuffer(1, crumbleLen, this.ctx.sampleRate);
                const crumbleData = crumbleBuf.getChannelData(0);
                for (let i = 0; i < crumbleLen; i++) {
                    const env = Math.pow(1 - i/crumbleLen, 1.2);
                    crumbleData[i] = (Math.random() * 2 - 1) * env * (1 + Math.sin(i * 0.05) * 0.5);
                }
                const crumble = this.ctx.createBufferSource();
                crumble.buffer = crumbleBuf;
                const filter = this.ctx.createBiquadFilter();
                filter.type = 'bandpass';
                filter.frequency.setValueAtTime(3000, now);
                filter.frequency.exponentialRampToValueAtTime(800, now + 0.15);
                filter.Q.value = 1;
                const gain = this.createGain(0.35);
                crumble.connect(filter);
                filter.connect(gain);
                crumble.start(now);

                // Pop
                const pop = this.ctx.createOscillator();
                const popGain = this.createGain(0.2);
                pop.type = 'sine';
                pop.frequency.setValueAtTime(300, now);
                pop.frequency.exponentialRampToValueAtTime(100, now + 0.05);
                popGain.gain.exponentialRampToValueAtTime(0.001, now + 0.06);
                pop.connect(popGain);
                pop.start(now);
                pop.stop(now + 0.06);
            }

            playFreeze(now) {
                // Icy crystalline sound
                for (let i = 0; i < 4; i++) {
                    const osc = this.ctx.createOscillator();
                    const gain = this.createGain(0.15);
                    osc.type = 'sine';
                    const freq = 2000 + i * 500 + Math.random() * 200;
                    osc.frequency.setValueAtTime(freq, now + i * 0.03);
                    osc.frequency.exponentialRampToValueAtTime(freq * 0.3, now + 0.3 + i * 0.03);
                    gain.gain.setValueAtTime(0.15 * this.masterVolume, now + i * 0.03);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.35 + i * 0.03);
                    osc.connect(gain);
                    osc.start(now + i * 0.03);
                    osc.stop(now + 0.4);
                }

                // Crackle
                const crackleLen = this.ctx.sampleRate * 0.3;
                const crackleBuf = this.ctx.createBuffer(1, crackleLen, this.ctx.sampleRate);
                const crackleData = crackleBuf.getChannelData(0);
                for (let i = 0; i < crackleLen; i++) {
                    crackleData[i] = (Math.random() > 0.92 ? Math.random() * 2 - 1 : 0) * (1 - i/crackleLen);
                }
                const crackle = this.ctx.createBufferSource();
                crackle.buffer = crackleBuf;
                const crackleFilter = this.ctx.createBiquadFilter();
                crackleFilter.type = 'highpass';
                crackleFilter.frequency.value = 4000;
                const crackleGain = this.createGain(0.2);
                crackle.connect(crackleFilter);
                crackleFilter.connect(crackleGain);
                crackle.start(now);
            }

            playSword(now) {
                // Sharp swoosh
                const swooshLen = this.ctx.sampleRate * 0.15;
                const swooshBuf = this.ctx.createBuffer(1, swooshLen, this.ctx.sampleRate);
                const swooshData = swooshBuf.getChannelData(0);
                for (let i = 0; i < swooshLen; i++) {
                    const t = i / swooshLen;
                    swooshData[i] = (Math.random() * 2 - 1) * Math.sin(t * Math.PI) * Math.pow(1 - t, 0.5);
                }
                const swoosh = this.ctx.createBufferSource();
                swoosh.buffer = swooshBuf;
                const filter = this.ctx.createBiquadFilter();
                filter.type = 'bandpass';
                filter.frequency.setValueAtTime(4000, now);
                filter.frequency.exponentialRampToValueAtTime(1000, now + 0.12);
                filter.Q.value = 3;
                const gain = this.createGain(0.4);
                swoosh.connect(filter);
                filter.connect(gain);
                swoosh.start(now);

                // Metallic ring
                const ring = this.ctx.createOscillator();
                const ringGain = this.createGain(0.12);
                ring.type = 'sine';
                ring.frequency.setValueAtTime(1800, now);
                ring.frequency.exponentialRampToValueAtTime(1200, now + 0.15);
                ringGain.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
                ring.connect(ringGain);
                ring.start(now);
                ring.stop(now + 0.2);
            }

            playBow(now) {
                // String release twang
                const twang = this.ctx.createOscillator();
                const twangGain = this.createGain(0.3);
                twang.type = 'triangle';
                twang.frequency.setValueAtTime(180, now);
                twang.frequency.exponentialRampToValueAtTime(60, now + 0.25);
                twangGain.gain.setValueAtTime(0.3 * this.masterVolume, now);
                twangGain.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
                twang.connect(twangGain);
                twang.start(now);
                twang.stop(now + 0.3);

                // String vibrato
                const vib = this.ctx.createOscillator();
                const vibGain = this.createGain(0.15);
                vib.type = 'sine';
                vib.frequency.setValueAtTime(600, now);
                vib.frequency.setValueAtTime(580, now + 0.02);
                vib.frequency.setValueAtTime(620, now + 0.04);
                vib.frequency.setValueAtTime(590, now + 0.06);
                vib.frequency.exponentialRampToValueAtTime(300, now + 0.2);
                vibGain.gain.exponentialRampToValueAtTime(0.001, now + 0.25);
                vib.connect(vibGain);
                vib.start(now);
                vib.stop(now + 0.25);

                // Woosh of arrow
                const wooshLen = this.ctx.sampleRate * 0.1;
                const wooshBuf = this.ctx.createBuffer(1, wooshLen, this.ctx.sampleRate);
                const wooshData = wooshBuf.getChannelData(0);
                for (let i = 0; i < wooshLen; i++) wooshData[i] = (Math.random() * 2 - 1) * (i/wooshLen) * Math.pow(1 - i/wooshLen, 2);
                const woosh = this.ctx.createBufferSource();
                woosh.buffer = wooshBuf;
                const wooshFilter = this.ctx.createBiquadFilter();
                wooshFilter.type = 'highpass';
                wooshFilter.frequency.value = 2000;
                const wooshGain = this.createGain(0.15);
                woosh.connect(wooshFilter);
                wooshFilter.connect(wooshGain);
                woosh.start(now + 0.05);
            }

            playThrow(now) {
                // Grunt effort
                const grunt = this.ctx.createOscillator();
                const gruntGain = this.createGain(0.15);
                grunt.type = 'sawtooth';
                grunt.frequency.setValueAtTime(120, now);
                grunt.frequency.exponentialRampToValueAtTime(80, now + 0.1);
                gruntGain.gain.exponentialRampToValueAtTime(0.001, now + 0.12);
                grunt.connect(gruntGain);
                grunt.start(now);
                grunt.stop(now + 0.12);

                // Woosh
                const wooshLen = this.ctx.sampleRate * 0.12;
                const wooshBuf = this.ctx.createBuffer(1, wooshLen, this.ctx.sampleRate);
                const wooshData = wooshBuf.getChannelData(0);
                for (let i = 0; i < wooshLen; i++) wooshData[i] = (Math.random() * 2 - 1) * Math.sin((i/wooshLen) * Math.PI);
                const woosh = this.ctx.createBufferSource();
                woosh.buffer = wooshBuf;
                const wooshFilter = this.ctx.createBiquadFilter();
                wooshFilter.type = 'bandpass';
                wooshFilter.frequency.setValueAtTime(1500, now);
                wooshFilter.frequency.exponentialRampToValueAtTime(800, now + 0.1);
                const wooshGain = this.createGain(0.25);
                woosh.connect(wooshFilter);
                wooshFilter.connect(wooshGain);
                woosh.start(now);
            }

            playFootstep(now) {
                // Varied footstep
                const pitch = 0.8 + Math.random() * 0.4;
                const step = this.ctx.createOscillator();
                const stepGain = this.createGain(0.12);
                step.type = 'sine';
                step.frequency.setValueAtTime(100 * pitch, now);
                step.frequency.exponentialRampToValueAtTime(50, now + 0.05);
                stepGain.gain.exponentialRampToValueAtTime(0.001, now + 0.08);
                step.connect(stepGain);
                step.start(now);
                step.stop(now + 0.08);

                // Crunch
                const crunchLen = this.ctx.sampleRate * 0.06;
                const crunchBuf = this.ctx.createBuffer(1, crunchLen, this.ctx.sampleRate);
                const crunchData = crunchBuf.getChannelData(0);
                for (let i = 0; i < crunchLen; i++) crunchData[i] = (Math.random() * 2 - 1) * Math.pow(1 - i/crunchLen, 3);
                const crunch = this.ctx.createBufferSource();
                crunch.buffer = crunchBuf;
                const crunchFilter = this.ctx.createBiquadFilter();
                crunchFilter.type = 'highpass';
                crunchFilter.frequency.value = 1200;
                const crunchGain = this.createGain(0.08);
                crunch.connect(crunchFilter);
                crunchFilter.connect(crunchGain);
                crunch.start(now);
            }

            playHurt(now) {
                // Oof sound
                const oof = this.ctx.createOscillator();
                const oofGain = this.createGain(0.4);
                const oofFilter = this.ctx.createBiquadFilter();
                oofFilter.type = 'lowpass';
                oofFilter.frequency.value = 500;
                oof.type = 'sawtooth';
                oof.frequency.setValueAtTime(150, now);
                oof.frequency.exponentialRampToValueAtTime(80, now + 0.15);
                oofGain.gain.setValueAtTime(0.4 * this.masterVolume, now);
                oofGain.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
                oof.connect(oofFilter);
                oofFilter.connect(oofGain);
                oof.start(now);
                oof.stop(now + 0.2);

                // Impact thud
                const thud = this.ctx.createOscillator();
                const thudGain = this.createGain(0.25);
                thud.type = 'sine';
                thud.frequency.setValueAtTime(100, now);
                thud.frequency.exponentialRampToValueAtTime(40, now + 0.1);
                thudGain.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
                thud.connect(thudGain);
                thud.start(now);
                thud.stop(now + 0.15);
            }

            playJump(now) {
                const jump = this.ctx.createOscillator();
                const jumpGain = this.createGain(0.15);
                jump.type = 'sine';
                jump.frequency.setValueAtTime(150, now);
                jump.frequency.exponentialRampToValueAtTime(400, now + 0.1);
                jumpGain.gain.exponentialRampToValueAtTime(0.001, now + 0.12);
                jump.connect(jumpGain);
                jump.start(now);
                jump.stop(now + 0.12);
            }

            playLand(now) {
                const land = this.ctx.createOscillator();
                const landGain = this.createGain(0.2);
                land.type = 'sine';
                land.frequency.setValueAtTime(120, now);
                land.frequency.exponentialRampToValueAtTime(40, now + 0.08);
                landGain.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
                land.connect(landGain);
                land.start(now);
                land.stop(now + 0.1);

                // Thump
                const thumpLen = this.ctx.sampleRate * 0.08;
                const thumpBuf = this.ctx.createBuffer(1, thumpLen, this.ctx.sampleRate);
                const thumpData = thumpBuf.getChannelData(0);
                for (let i = 0; i < thumpLen; i++) thumpData[i] = (Math.random() * 2 - 1) * Math.pow(1 - i/thumpLen, 4);
                const thump = this.ctx.createBufferSource();
                thump.buffer = thumpBuf;
                const thumpFilter = this.ctx.createBiquadFilter();
                thumpFilter.type = 'lowpass';
                thumpFilter.frequency.value = 400;
                const thumpGain = this.createGain(0.15);
                thump.connect(thumpFilter);
                thumpFilter.connect(thumpGain);
                thump.start(now);
            }

            playAmbient(now) {
                // Wind
                const windLen = this.ctx.sampleRate * 3;
                const windBuf = this.ctx.createBuffer(1, windLen, this.ctx.sampleRate);
                const windData = windBuf.getChannelData(0);
                for (let i = 0; i < windLen; i++) {
                    const env = Math.sin((i/windLen) * Math.PI);
                    windData[i] = (Math.random() * 2 - 1) * env * 0.3;
                }
                const wind = this.ctx.createBufferSource();
                wind.buffer = windBuf;
                const windFilter = this.ctx.createBiquadFilter();
                windFilter.type = 'lowpass';
                windFilter.frequency.value = 400;
                const windGain = this.createGain(0.05);
                wind.connect(windFilter);
                windFilter.connect(windGain);
                wind.start(now);
            }

            // ========== DOOM-STYLE SOUNDS ==========

            playShotgun(now) {
                // Heavy mechanical blast
                const blast = this.ctx.createOscillator();
                const blastGain = this.createGain(0.9);
                const blastDist = this.createDistortion(200);
                blast.type = 'sawtooth';
                blast.frequency.setValueAtTime(200, now);
                blast.frequency.exponentialRampToValueAtTime(30, now + 0.15);
                blastGain.gain.setValueAtTime(0.9 * this.masterVolume, now);
                blastGain.gain.exponentialRampToValueAtTime(0.001, now + 0.25);
                blast.connect(blastDist);
                blastDist.connect(blastGain);
                blast.start(now);
                blast.stop(now + 0.25);

                // Massive noise burst
                const noiseLen = this.ctx.sampleRate * 0.15;
                const noiseBuf = this.ctx.createBuffer(2, noiseLen, this.ctx.sampleRate);
                for (let ch = 0; ch < 2; ch++) {
                    const data = noiseBuf.getChannelData(ch);
                    for (let i = 0; i < noiseLen; i++) {
                        data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i/noiseLen, 1.5);
                    }
                }
                const noise = this.ctx.createBufferSource();
                noise.buffer = noiseBuf;
                const noiseGain = this.createGain(0.7);
                const noiseDist = this.createDistortion(100);
                noise.connect(noiseDist);
                noiseDist.connect(noiseGain);
                noise.start(now);

                // Shell eject
                setTimeout(() => {
                    const eject = this.ctx.createOscillator();
                    const ejectGain = this.createGain(0.15);
                    eject.type = 'sine';
                    eject.frequency.setValueAtTime(3000, this.ctx.currentTime);
                    eject.frequency.exponentialRampToValueAtTime(800, this.ctx.currentTime + 0.05);
                    ejectGain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.08);
                    eject.connect(ejectGain);
                    eject.start(this.ctx.currentTime);
                    eject.stop(this.ctx.currentTime + 0.08);
                }, 150);

                // Pump action
                setTimeout(() => {
                    const pumpLen = this.ctx.sampleRate * 0.12;
                    const pumpBuf = this.ctx.createBuffer(1, pumpLen, this.ctx.sampleRate);
                    const pumpData = pumpBuf.getChannelData(0);
                    for (let i = 0; i < pumpLen; i++) {
                        const t = i / pumpLen;
                        pumpData[i] = (Math.random() * 2 - 1) * (t < 0.5 ? t * 2 : (1 - t) * 2) * 0.5;
                    }
                    const pump = this.ctx.createBufferSource();
                    pump.buffer = pumpBuf;
                    const pumpFilter = this.ctx.createBiquadFilter();
                    pumpFilter.type = 'bandpass';
                    pumpFilter.frequency.value = 800;
                    pumpFilter.Q.value = 2;
                    const pumpGain = this.createGain(0.3);
                    pump.connect(pumpFilter);
                    pumpFilter.connect(pumpGain);
                    pump.start(this.ctx.currentTime);
                }, 350);
            }

            playRocket(now) {
                // Whoosh launch
                const whoosh = this.ctx.createOscillator();
                const whooshGain = this.createGain(0.5);
                whoosh.type = 'sawtooth';
                whoosh.frequency.setValueAtTime(100, now);
                whoosh.frequency.exponentialRampToValueAtTime(400, now + 0.2);
                whooshGain.gain.setValueAtTime(0.5 * this.masterVolume, now);
                whooshGain.gain.exponentialRampToValueAtTime(0.1 * this.masterVolume, now + 0.3);
                whooshGain.gain.exponentialRampToValueAtTime(0.001, now + 0.5);
                whoosh.connect(whooshGain);
                whoosh.start(now);
                whoosh.stop(now + 0.5);

                // Ignition burst
                const noiseLen = this.ctx.sampleRate * 0.2;
                const noiseBuf = this.ctx.createBuffer(1, noiseLen, this.ctx.sampleRate);
                const noiseData = noiseBuf.getChannelData(0);
                for (let i = 0; i < noiseLen; i++) {
                    noiseData[i] = (Math.random() * 2 - 1) * (1 - i/noiseLen) * 0.8;
                }
                const noise = this.ctx.createBufferSource();
                noise.buffer = noiseBuf;
                const noiseGain = this.createGain(0.4);
                noise.connect(noiseGain);
                noise.start(now);
            }

            playPlasma(now) {
                // Electric zap
                const zap = this.ctx.createOscillator();
                const zapGain = this.createGain(0.4);
                zap.type = 'square';
                zap.frequency.setValueAtTime(800, now);
                zap.frequency.setValueAtTime(1200, now + 0.02);
                zap.frequency.setValueAtTime(600, now + 0.04);
                zap.frequency.exponentialRampToValueAtTime(200, now + 0.1);
                zapGain.gain.exponentialRampToValueAtTime(0.001, now + 0.12);
                zap.connect(zapGain);
                zap.start(now);
                zap.stop(now + 0.12);

                // Buzz
                const buzz = this.ctx.createOscillator();
                const buzzGain = this.createGain(0.2);
                buzz.type = 'sawtooth';
                buzz.frequency.setValueAtTime(150, now);
                buzzGain.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
                buzz.connect(buzzGain);
                buzz.start(now);
                buzz.stop(now + 0.15);
            }

            playBFG(now) {
                // Massive charge up
                const charge = this.ctx.createOscillator();
                const chargeGain = this.createGain(0.6);
                const chargeDist = this.createDistortion(150);
                charge.type = 'sawtooth';
                charge.frequency.setValueAtTime(50, now);
                charge.frequency.exponentialRampToValueAtTime(2000, now + 0.3);
                chargeGain.gain.setValueAtTime(0.1, now);
                chargeGain.gain.linearRampToValueAtTime(0.6 * this.masterVolume, now + 0.25);
                chargeGain.gain.exponentialRampToValueAtTime(0.001, now + 0.8);
                charge.connect(chargeDist);
                chargeDist.connect(chargeGain);
                charge.start(now);
                charge.stop(now + 0.8);

                // Bass drop
                const drop = this.ctx.createOscillator();
                const dropGain = this.createGain(0.8);
                drop.type = 'sine';
                drop.frequency.setValueAtTime(100, now + 0.3);
                drop.frequency.exponentialRampToValueAtTime(20, now + 0.8);
                dropGain.gain.setValueAtTime(0.8 * this.masterVolume, now + 0.3);
                dropGain.gain.exponentialRampToValueAtTime(0.001, now + 1);
                drop.connect(dropGain);
                drop.start(now + 0.3);
                drop.stop(now + 1);

                // Electric storm
                const stormLen = this.ctx.sampleRate * 0.6;
                const stormBuf = this.ctx.createBuffer(2, stormLen, this.ctx.sampleRate);
                for (let ch = 0; ch < 2; ch++) {
                    const data = stormBuf.getChannelData(ch);
                    for (let i = 0; i < stormLen; i++) {
                        const t = i / stormLen;
                        data[i] = (Math.random() * 2 - 1) * Math.sin(t * Math.PI) * (Math.random() > 0.8 ? 2 : 0.5);
                    }
                }
                const storm = this.ctx.createBufferSource();
                storm.buffer = stormBuf;
                const stormGain = this.createGain(0.4);
                const stormReverb = this.createReverbSend(stormGain, 0.5);
                storm.connect(stormGain);
                storm.connect(stormReverb);
                storm.start(now + 0.3);
            }

            playNuke(now) {
                // Air raid siren intro
                const siren = this.ctx.createOscillator();
                const sirenGain = this.createGain(0.3);
                siren.type = 'sine';
                siren.frequency.setValueAtTime(400, now);
                siren.frequency.linearRampToValueAtTime(600, now + 0.15);
                siren.frequency.linearRampToValueAtTime(400, now + 0.3);
                sirenGain.gain.exponentialRampToValueAtTime(0.001, now + 0.4);
                siren.connect(sirenGain);
                siren.start(now);
                siren.stop(now + 0.4);

                // Mechanical clunk
                const clunk = this.ctx.createOscillator();
                const clunkGain = this.createGain(0.5);
                clunk.type = 'square';
                clunk.frequency.setValueAtTime(60, now);
                clunkGain.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
                clunk.connect(clunkGain);
                clunk.start(now);
                clunk.stop(now + 0.1);
            }

            playDemonGrowl(now) {
                // Low menacing growl
                const growl = this.ctx.createOscillator();
                const growlGain = this.createGain(0.5);
                const growlDist = this.createDistortion(80);
                const growlFilter = this.ctx.createBiquadFilter();
                growlFilter.type = 'lowpass';
                growlFilter.frequency.value = 300;
                growl.type = 'sawtooth';
                growl.frequency.setValueAtTime(80 + Math.random() * 40, now);
                growl.frequency.linearRampToValueAtTime(60 + Math.random() * 30, now + 0.3);
                growlGain.gain.setValueAtTime(0.5 * this.masterVolume, now);
                growlGain.gain.exponentialRampToValueAtTime(0.001, now + 0.5);
                growl.connect(growlDist);
                growlDist.connect(growlFilter);
                growlFilter.connect(growlGain);
                growl.start(now);
                growl.stop(now + 0.5);

                // Rumble undertone
                const rumble = this.ctx.createOscillator();
                const rumbleGain = this.createGain(0.3);
                rumble.type = 'sine';
                rumble.frequency.setValueAtTime(40, now);
                rumbleGain.gain.exponentialRampToValueAtTime(0.001, now + 0.6);
                rumble.connect(rumbleGain);
                rumble.start(now);
                rumble.stop(now + 0.6);
            }

            playDemonDeath(now) {
                // Anguished roar
                const roar = this.ctx.createOscillator();
                const roarGain = this.createGain(0.7);
                const roarDist = this.createDistortion(120);
                roar.type = 'sawtooth';
                roar.frequency.setValueAtTime(200, now);
                roar.frequency.exponentialRampToValueAtTime(50, now + 0.6);
                roarGain.gain.setValueAtTime(0.7 * this.masterVolume, now);
                roarGain.gain.exponentialRampToValueAtTime(0.001, now + 0.8);
                roar.connect(roarDist);
                roarDist.connect(roarGain);
                roar.start(now);
                roar.stop(now + 0.8);

                // Gurgle
                const gurgleLen = this.ctx.sampleRate * 0.5;
                const gurgleBuf = this.ctx.createBuffer(1, gurgleLen, this.ctx.sampleRate);
                const gurgleData = gurgleBuf.getChannelData(0);
                for (let i = 0; i < gurgleLen; i++) {
                    const mod = Math.sin(i * 0.05) * 0.5;
                    gurgleData[i] = (Math.random() * 2 - 1 + mod) * Math.pow(1 - i/gurgleLen, 1.5) * 0.4;
                }
                const gurgle = this.ctx.createBufferSource();
                gurgle.buffer = gurgleBuf;
                const gurgleFilter = this.ctx.createBiquadFilter();
                gurgleFilter.type = 'lowpass';
                gurgleFilter.frequency.value = 600;
                const gurgleGain = this.createGain(0.4);
                gurgle.connect(gurgleFilter);
                gurgleFilter.connect(gurgleGain);
                gurgle.start(now + 0.2);
            }

            playGore(now) {
                // Wet splatter
                const splatLen = this.ctx.sampleRate * 0.15;
                const splatBuf = this.ctx.createBuffer(1, splatLen, this.ctx.sampleRate);
                const splatData = splatBuf.getChannelData(0);
                for (let i = 0; i < splatLen; i++) {
                    splatData[i] = (Math.random() * 2 - 1) * Math.pow(1 - i/splatLen, 2) * (Math.random() > 0.7 ? 1.5 : 0.5);
                }
                const splat = this.ctx.createBufferSource();
                splat.buffer = splatBuf;
                const splatFilter = this.ctx.createBiquadFilter();
                splatFilter.type = 'lowpass';
                splatFilter.frequency.value = 2000;
                const splatGain = this.createGain(0.4);
                splat.connect(splatFilter);
                splatFilter.connect(splatGain);
                splat.start(now);

                // Squish
                const squish = this.ctx.createOscillator();
                const squishGain = this.createGain(0.2);
                squish.type = 'sine';
                squish.frequency.setValueAtTime(200, now);
                squish.frequency.exponentialRampToValueAtTime(80, now + 0.1);
                squishGain.gain.exponentialRampToValueAtTime(0.001, now + 0.12);
                squish.connect(squishGain);
                squish.start(now);
                squish.stop(now + 0.12);
            }

            playMetalImpact(now) {
                // Clang
                const clang = this.ctx.createOscillator();
                const clangGain = this.createGain(0.5);
                clang.type = 'square';
                clang.frequency.setValueAtTime(800 + Math.random() * 400, now);
                clang.frequency.exponentialRampToValueAtTime(200, now + 0.15);
                clangGain.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
                clang.connect(clangGain);
                clang.start(now);
                clang.stop(now + 0.2);

                // Ring
                const ring = this.ctx.createOscillator();
                const ringGain = this.createGain(0.15);
                ring.type = 'sine';
                ring.frequency.setValueAtTime(2000 + Math.random() * 1000, now);
                ringGain.gain.exponentialRampToValueAtTime(0.001, now + 0.4);
                ring.connect(ringGain);
                ring.start(now);
                ring.stop(now + 0.4);
            }

            playPickup(now) {
                // Ascending chime
                for (let i = 0; i < 3; i++) {
                    const chime = this.ctx.createOscillator();
                    const chimeGain = this.createGain(0.25);
                    chime.type = 'sine';
                    chime.frequency.setValueAtTime(600 + i * 200, now + i * 0.08);
                    chimeGain.gain.setValueAtTime(0.25 * this.masterVolume, now + i * 0.08);
                    chimeGain.gain.exponentialRampToValueAtTime(0.001, now + i * 0.08 + 0.2);
                    chime.connect(chimeGain);
                    chime.start(now + i * 0.08);
                    chime.stop(now + i * 0.08 + 0.2);
                }
            }

            playPowerup(now) {
                // Epic ascending
                const sweep = this.ctx.createOscillator();
                const sweepGain = this.createGain(0.4);
                sweep.type = 'sawtooth';
                sweep.frequency.setValueAtTime(200, now);
                sweep.frequency.exponentialRampToValueAtTime(1200, now + 0.4);
                sweepGain.gain.setValueAtTime(0.4 * this.masterVolume, now);
                sweepGain.gain.exponentialRampToValueAtTime(0.001, now + 0.5);
                sweep.connect(sweepGain);
                sweep.start(now);
                sweep.stop(now + 0.5);

                // Sparkle
                for (let i = 0; i < 5; i++) {
                    const sparkle = this.ctx.createOscillator();
                    const sparkleGain = this.createGain(0.15);
                    sparkle.type = 'sine';
                    sparkle.frequency.setValueAtTime(1000 + i * 300 + Math.random() * 200, now + i * 0.06);
                    sparkleGain.gain.exponentialRampToValueAtTime(0.001, now + i * 0.06 + 0.15);
                    sparkle.connect(sparkleGain);
                    sparkle.start(now + i * 0.06);
                    sparkle.stop(now + i * 0.06 + 0.15);
                }
            }

            playChainsaw(now) {
                // Engine rev
                const engineLen = this.ctx.sampleRate * 0.3;
                const engineBuf = this.ctx.createBuffer(1, engineLen, this.ctx.sampleRate);
                const engineData = engineBuf.getChannelData(0);
                for (let i = 0; i < engineLen; i++) {
                    const freq = 30 + Math.sin(i * 0.003) * 10;
                    engineData[i] = Math.sin(i * freq * 0.01) * 0.5 + (Math.random() * 2 - 1) * 0.3;
                }
                const engine = this.ctx.createBufferSource();
                engine.buffer = engineBuf;
                const engineDist = this.createDistortion(150);
                const engineGain = this.createGain(0.5);
                engine.connect(engineDist);
                engineDist.connect(engineGain);
                engine.start(now);

                // High pitched whine
                const whine = this.ctx.createOscillator();
                const whineGain = this.createGain(0.2);
                whine.type = 'sawtooth';
                whine.frequency.setValueAtTime(800, now);
                whine.frequency.linearRampToValueAtTime(1200, now + 0.1);
                whine.frequency.linearRampToValueAtTime(900, now + 0.2);
                whineGain.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
                whine.connect(whineGain);
                whine.start(now);
                whine.stop(now + 0.3);
            }

            playLightning(now) {
                // Electric crack
                const crackLen = this.ctx.sampleRate * 0.2;
                const crackBuf = this.ctx.createBuffer(2, crackLen, this.ctx.sampleRate);
                for (let ch = 0; ch < 2; ch++) {
                    const data = crackBuf.getChannelData(ch);
                    for (let i = 0; i < crackLen; i++) {
                        data[i] = (Math.random() > 0.9 ? (Math.random() * 2 - 1) * 2 : (Math.random() * 2 - 1) * 0.3) * Math.pow(1 - i/crackLen, 1.5);
                    }
                }
                const crack = this.ctx.createBufferSource();
                crack.buffer = crackBuf;
                const crackGain = this.createGain(0.6);
                crack.connect(crackGain);
                crack.start(now);

                // Thunder rumble
                const thunder = this.ctx.createOscillator();
                const thunderGain = this.createGain(0.4);
                thunder.type = 'sine';
                thunder.frequency.setValueAtTime(60, now + 0.05);
                thunder.frequency.exponentialRampToValueAtTime(20, now + 0.4);
                thunderGain.gain.setValueAtTime(0.4 * this.masterVolume, now + 0.05);
                thunderGain.gain.exponentialRampToValueAtTime(0.001, now + 0.5);
                thunder.connect(thunderGain);
                thunder.start(now + 0.05);
                thunder.stop(now + 0.5);
            }

            playBlackHole(now) {
                // Deep warping
                const warp = this.ctx.createOscillator();
                const warpGain = this.createGain(0.5);
                warp.type = 'sine';
                warp.frequency.setValueAtTime(100, now);
                warp.frequency.exponentialRampToValueAtTime(20, now + 0.5);
                warpGain.gain.setValueAtTime(0.5 * this.masterVolume, now);
                warpGain.gain.exponentialRampToValueAtTime(0.001, now + 0.8);
                warp.connect(warpGain);
                warp.start(now);
                warp.stop(now + 0.8);

                // Suction
                const suckLen = this.ctx.sampleRate * 0.4;
                const suckBuf = this.ctx.createBuffer(1, suckLen, this.ctx.sampleRate);
                const suckData = suckBuf.getChannelData(0);
                for (let i = 0; i < suckLen; i++) {
                    const t = i / suckLen;
                    suckData[i] = (Math.random() * 2 - 1) * (1 - t) * Math.sin(t * 50);
                }
                const suck = this.ctx.createBufferSource();
                suck.buffer = suckBuf;
                const suckFilter = this.ctx.createBiquadFilter();
                suckFilter.type = 'lowpass';
                suckFilter.frequency.setValueAtTime(2000, now);
                suckFilter.frequency.exponentialRampToValueAtTime(100, now + 0.4);
                const suckGain = this.createGain(0.4);
                suck.connect(suckFilter);
                suckFilter.connect(suckGain);
                suck.start(now);
            }

            playSplash(now) {
                // Water splash - white noise burst with lowpass filter
                const splashLen = this.ctx.sampleRate * 0.3;
                const splashBuf = this.ctx.createBuffer(1, splashLen, this.ctx.sampleRate);
                const splashData = splashBuf.getChannelData(0);
                for (let i = 0; i < splashLen; i++) {
                    const t = i / splashLen;
                    const env = Math.sin(t * Math.PI) * (1 - t);
                    splashData[i] = (Math.random() * 2 - 1) * env;
                }
                const splash = this.ctx.createBufferSource();
                splash.buffer = splashBuf;
                const filter = this.ctx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.setValueAtTime(3000, now);
                filter.frequency.exponentialRampToValueAtTime(500, now + 0.2);
                const gain = this.createGain(0.4);
                splash.connect(filter);
                filter.connect(gain);
                splash.start(now);
            }

            playUnderwater(now) {
                // Muffled underwater ambient - low rumble with bubbles
                const rumble = this.ctx.createOscillator();
                rumble.type = 'sine';
                rumble.frequency.value = 60;
                const rumbleGain = this.createGain(0.15);
                rumbleGain.gain.setValueAtTime(0.15 * this.masterVolume, now);
                rumbleGain.gain.linearRampToValueAtTime(0.001, now + 1);
                rumble.connect(rumbleGain);
                rumble.start(now);
                rumble.stop(now + 1);

                // Bubble pop
                const bubble = this.ctx.createOscillator();
                bubble.type = 'sine';
                bubble.frequency.setValueAtTime(800, now);
                bubble.frequency.exponentialRampToValueAtTime(400, now + 0.1);
                const bubbleGain = this.createGain(0.1);
                bubbleGain.gain.setValueAtTime(0.1 * this.masterVolume, now);
                bubbleGain.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
                bubble.connect(bubbleGain);
                bubble.start(now);
                bubble.stop(now + 0.1);
            }
        }

        // ============================================
        // PROCEDURAL TEXTURE GENERATOR
        // ============================================
        class TextureGenerator {
            constructor(size = 64) {
                this.size = size;
                this.textures = {};
                this.generateAllTextures();
            }

            createCanvas() {
                const canvas = document.createElement('canvas');
                canvas.width = this.size;
                canvas.height = this.size;
                return canvas;
            }

            noise(x, y, seed = 0) {
                const n = Math.sin(x * 12.9898 + y * 78.233 + seed) * 43758.5453;
                return n - Math.floor(n);
            }

            fbm(x, y, octaves = 4, seed = 0) {
                let value = 0, amplitude = 0.5, frequency = 1;
                for (let i = 0; i < octaves; i++) {
                    value += amplitude * this.noise(x * frequency, y * frequency, seed + i * 100);
                    amplitude *= 0.5;
                    frequency *= 2;
                }
                return value;
            }

            hexToRgb(hex) {
                return {
                    r: (hex >> 16) & 255,
                    g: (hex >> 8) & 255,
                    b: hex & 255
                };
            }

            varyColor(r, g, b, amount) {
                const vary = () => Math.floor((Math.random() - 0.5) * amount * 2);
                return `rgb(${Math.max(0, Math.min(255, r + vary()))},${Math.max(0, Math.min(255, g + vary()))},${Math.max(0, Math.min(255, b + vary()))})`;
            }

            // Generate all block textures
            generateAllTextures() {
                // Basic blocks
                this.textures[BLOCKS.GRASS] = {
                    top: this.generateGrassTop(),
                    side: this.generateGrassSide(),
                    bottom: this.generateDirt()
                };
                this.textures[BLOCKS.DIRT] = { top: this.generateDirt(), side: this.generateDirt(), bottom: this.generateDirt() };
                this.textures[BLOCKS.STONE] = { top: this.generateStone(), side: this.generateStone(), bottom: this.generateStone() };
                this.textures[BLOCKS.WOOD] = { top: this.generateWoodTop(), side: this.generateWoodSide(), bottom: this.generateWoodTop() };
                this.textures[BLOCKS.LEAVES] = { top: this.generateLeaves(), side: this.generateLeaves(), bottom: this.generateLeaves() };
                this.textures[BLOCKS.SAND] = { top: this.generateSand(), side: this.generateSand(), bottom: this.generateSand() };
                this.textures[BLOCKS.WATER] = { top: this.generateWater(), side: this.generateWater(), bottom: this.generateWater() };
                this.textures[BLOCKS.COBBLESTONE] = { top: this.generateCobblestone(), side: this.generateCobblestone(), bottom: this.generateCobblestone() };
                this.textures[BLOCKS.PLANKS] = { top: this.generatePlanks(), side: this.generatePlanks(), bottom: this.generatePlanks() };
                this.textures[BLOCKS.BEDROCK] = { top: this.generateBedrock(), side: this.generateBedrock(), bottom: this.generateBedrock() };
                this.textures[BLOCKS.TNT] = { top: this.generateTNTTop(), side: this.generateTNTSide(), bottom: this.generateTNTTop() };
                this.textures[BLOCKS.ICE] = { top: this.generateIce(), side: this.generateIce(), bottom: this.generateIce() };
                this.textures[BLOCKS.SNOW] = { top: this.generateSnow(), side: this.generateSnow(), bottom: this.generateSnow() };
                this.textures[BLOCKS.SNOW_GRASS] = { top: this.generateSnow(), side: this.generateSnowGrassSide(), bottom: this.generateDirt() };
                this.textures[BLOCKS.CACTUS] = { top: this.generateCactusTop(), side: this.generateCactusSide(), bottom: this.generateCactusTop() };

                // Ores
                this.textures[BLOCKS.COAL_ORE] = { top: this.generateOre(0x222222), side: this.generateOre(0x222222), bottom: this.generateOre(0x222222) };
                this.textures[BLOCKS.IRON_ORE] = { top: this.generateOre(0xd8af93), side: this.generateOre(0xd8af93), bottom: this.generateOre(0xd8af93) };
                this.textures[BLOCKS.GOLD_ORE] = { top: this.generateOre(0xffd700), side: this.generateOre(0xffd700), bottom: this.generateOre(0xffd700) };
                this.textures[BLOCKS.DIAMOND_ORE] = { top: this.generateOre(0x4aedd9), side: this.generateOre(0x4aedd9), bottom: this.generateOre(0x4aedd9) };

                // Other natural blocks
                this.textures[BLOCKS.GRAVEL] = { top: this.generateGravel(), side: this.generateGravel(), bottom: this.generateGravel() };
                this.textures[BLOCKS.CLAY] = { top: this.generateClay(), side: this.generateClay(), bottom: this.generateClay() };
                this.textures[BLOCKS.GLASS] = { top: this.generateGlass(), side: this.generateGlass(), bottom: this.generateGlass() };
                this.textures[BLOCKS.BRICK] = { top: this.generateBrick(), side: this.generateBrick(), bottom: this.generateBrick() };
                this.textures[BLOCKS.OBSIDIAN] = { top: this.generateObsidian(), side: this.generateObsidian(), bottom: this.generateObsidian() };
                this.textures[BLOCKS.LAVA] = { top: this.generateLava(), side: this.generateLava(), bottom: this.generateLava() };

                // DOOM blocks
                this.textures[BLOCKS.METAL_FLOOR] = { top: this.generateMetalFloor(), side: this.generateMetalWall(), bottom: this.generateMetalFloor() };
                this.textures[BLOCKS.METAL_WALL] = { top: this.generateMetalFloor(), side: this.generateMetalWall(), bottom: this.generateMetalFloor() };
                this.textures[BLOCKS.RUSTY_METAL] = { top: this.generateRustyMetal(), side: this.generateRustyMetal(), bottom: this.generateRustyMetal() };
                this.textures[BLOCKS.GRATE] = { top: this.generateGrate(), side: this.generateGrate(), bottom: this.generateGrate() };
                this.textures[BLOCKS.FLESH] = { top: this.generateFlesh(), side: this.generateFlesh(), bottom: this.generateFlesh() };
                this.textures[BLOCKS.BLOOD] = { top: this.generateBlood(), side: this.generateBlood(), bottom: this.generateBlood() };
                this.textures[BLOCKS.BONE] = { top: this.generateBone(), side: this.generateBone(), bottom: this.generateBone() };
                this.textures[BLOCKS.SKULL_WALL] = { top: this.generateSkullWall(), side: this.generateSkullWall(), bottom: this.generateSkullWall() };
                this.textures[BLOCKS.HELL_BRICK] = { top: this.generateHellBrick(), side: this.generateHellBrick(), bottom: this.generateHellBrick() };
                this.textures[BLOCKS.MARBLE] = { top: this.generateMarble(), side: this.generateMarble(), bottom: this.generateMarble() };
                this.textures[BLOCKS.TECH_PANEL] = { top: this.generateTechPanel(), side: this.generateTechPanel(), bottom: this.generateTechPanel() };
                this.textures[BLOCKS.COMPUTER] = { top: this.generateComputer(), side: this.generateComputer(), bottom: this.generateComputer() };
                this.textures[BLOCKS.PIPES] = { top: this.generatePipes(), side: this.generatePipes(), bottom: this.generatePipes() };
                this.textures[BLOCKS.VENT] = { top: this.generateVent(), side: this.generateVent(), bottom: this.generateVent() };
                this.textures[BLOCKS.WARNING] = { top: this.generateWarning(), side: this.generateWarningStripes(), bottom: this.generateWarning() };
                this.textures[BLOCKS.NUKE_BARREL] = { top: this.generateNukeBarrelTop(), side: this.generateNukeBarrelSide(), bottom: this.generateMetalFloor() };
                this.textures[BLOCKS.PENTAGRAM] = { top: this.generatePentagram(), side: this.generateHellBrick(), bottom: this.generateHellBrick() };
                this.textures[BLOCKS.LAVA_ROCK] = { top: this.generateLavaRock(), side: this.generateLavaRock(), bottom: this.generateLavaRock() };
                this.textures[BLOCKS.ASH] = { top: this.generateAsh(), side: this.generateAsh(), bottom: this.generateAsh() };
                this.textures[BLOCKS.CORRUPTION] = { top: this.generateCorruption(), side: this.generateCorruption(), bottom: this.generateCorruption() };
            }

            // Basic block textures
            generateGrassTop() {
                const canvas = this.createCanvas();
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#5d9b3a';
                ctx.fillRect(0, 0, this.size, this.size);
                // Add grass blade details
                for (let i = 0; i < 200; i++) {
                    const x = Math.random() * this.size;
                    const y = Math.random() * this.size;
                    ctx.fillStyle = this.varyColor(93, 155, 58, 30);
                    ctx.fillRect(x, y, 2, 2);
                }
                // Darker patches
                for (let i = 0; i < 20; i++) {
                    ctx.fillStyle = `rgba(0, 80, 0, 0.3)`;
                    ctx.beginPath();
                    ctx.arc(Math.random() * this.size, Math.random() * this.size, Math.random() * 8 + 2, 0, Math.PI * 2);
                    ctx.fill();
                }
                return canvas;
            }

            generateGrassSide() {
                const canvas = this.createCanvas();
                const ctx = canvas.getContext('2d');
                // Dirt part
                ctx.fillStyle = '#8b6914';
                ctx.fillRect(0, 0, this.size, this.size);
                for (let i = 0; i < 100; i++) {
                    ctx.fillStyle = this.varyColor(139, 105, 20, 25);
                    ctx.fillRect(Math.random() * this.size, Math.random() * this.size, 3, 3);
                }
                // Grass top strip
                ctx.fillStyle = '#5d9b3a';
                ctx.fillRect(0, 0, this.size, 8);
                // Hanging grass
                for (let x = 0; x < this.size; x += 4) {
                    const h = Math.random() * 6 + 4;
                    ctx.fillStyle = this.varyColor(93, 155, 58, 20);
                    ctx.fillRect(x, 8, 2, h);
                }
                return canvas;
            }

            generateDirt() {
                const canvas = this.createCanvas();
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#8b6914';
                ctx.fillRect(0, 0, this.size, this.size);
                // Dirt texture noise
                for (let i = 0; i < 150; i++) {
                    ctx.fillStyle = this.varyColor(139, 105, 20, 30);
                    ctx.fillRect(Math.random() * this.size, Math.random() * this.size, Math.random() * 4 + 1, Math.random() * 4 + 1);
                }
                // Small rocks
                for (let i = 0; i < 10; i++) {
                    ctx.fillStyle = `rgba(60, 50, 30, 0.5)`;
                    ctx.beginPath();
                    ctx.arc(Math.random() * this.size, Math.random() * this.size, Math.random() * 3 + 1, 0, Math.PI * 2);
                    ctx.fill();
                }
                return canvas;
            }

            generateStone() {
                const canvas = this.createCanvas();
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#7a7a7a';
                ctx.fillRect(0, 0, this.size, this.size);
                // Stone texture
                for (let x = 0; x < this.size; x++) {
                    for (let y = 0; y < this.size; y++) {
                        const n = this.fbm(x / 8, y / 8);
                        const gray = 100 + n * 50;
                        ctx.fillStyle = `rgb(${gray},${gray},${gray})`;
                        ctx.fillRect(x, y, 1, 1);
                    }
                }
                // Cracks
                ctx.strokeStyle = 'rgba(50,50,50,0.4)';
                ctx.lineWidth = 1;
                for (let i = 0; i < 5; i++) {
                    ctx.beginPath();
                    let x = Math.random() * this.size;
                    let y = Math.random() * this.size;
                    ctx.moveTo(x, y);
                    for (let j = 0; j < 4; j++) {
                        x += (Math.random() - 0.5) * 15;
                        y += (Math.random() - 0.5) * 15;
                        ctx.lineTo(x, y);
                    }
                    ctx.stroke();
                }
                return canvas;
            }

            generateWoodSide() {
                const canvas = this.createCanvas();
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#5a3a1a';
                ctx.fillRect(0, 0, this.size, this.size);
                // Bark lines
                for (let y = 0; y < this.size; y += 2) {
                    ctx.strokeStyle = this.varyColor(90, 58, 26, 20);
                    ctx.lineWidth = 1 + Math.random();
                    ctx.beginPath();
                    ctx.moveTo(0, y + Math.random() * 2);
                    for (let x = 0; x < this.size; x += 8) {
                        ctx.lineTo(x, y + Math.random() * 3);
                    }
                    ctx.stroke();
                }
                // Knots
                for (let i = 0; i < 2; i++) {
                    const x = Math.random() * this.size;
                    const y = Math.random() * this.size;
                    ctx.fillStyle = '#3a2a0a';
                    ctx.beginPath();
                    ctx.ellipse(x, y, 4, 6, 0, 0, Math.PI * 2);
                    ctx.fill();
                }
                return canvas;
            }

            generateWoodTop() {
                const canvas = this.createCanvas();
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#9a7a4a';
                ctx.fillRect(0, 0, this.size, this.size);
                // Tree rings
                const cx = this.size / 2, cy = this.size / 2;
                for (let r = 4; r < this.size / 2; r += 3) {
                    ctx.strokeStyle = `rgba(60, 40, 20, ${0.3 + Math.random() * 0.3})`;
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.arc(cx, cy, r + Math.random() * 2, 0, Math.PI * 2);
                    ctx.stroke();
                }
                return canvas;
            }

            generateLeaves() {
                const canvas = this.createCanvas();
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#2a6a1a';
                ctx.fillRect(0, 0, this.size, this.size);
                // Leaf clusters
                for (let i = 0; i < 60; i++) {
                    ctx.fillStyle = this.varyColor(42, 106, 26, 30);
                    ctx.beginPath();
                    ctx.arc(Math.random() * this.size, Math.random() * this.size, Math.random() * 5 + 2, 0, Math.PI * 2);
                    ctx.fill();
                }
                // Gaps (transparency effect)
                for (let i = 0; i < 15; i++) {
                    ctx.fillStyle = 'rgba(0,30,0,0.5)';
                    ctx.beginPath();
                    ctx.arc(Math.random() * this.size, Math.random() * this.size, Math.random() * 3 + 1, 0, Math.PI * 2);
                    ctx.fill();
                }
                return canvas;
            }

            generateSand() {
                const canvas = this.createCanvas();
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#d4c896';
                ctx.fillRect(0, 0, this.size, this.size);
                // Sand grains
                for (let i = 0; i < 300; i++) {
                    ctx.fillStyle = this.varyColor(212, 200, 150, 20);
                    ctx.fillRect(Math.random() * this.size, Math.random() * this.size, 1, 1);
                }
                // Darker spots
                for (let i = 0; i < 20; i++) {
                    ctx.fillStyle = 'rgba(150, 130, 80, 0.3)';
                    ctx.fillRect(Math.random() * this.size, Math.random() * this.size, 3, 3);
                }
                return canvas;
            }

            generateWater() {
                const canvas = this.createCanvas();
                const ctx = canvas.getContext('2d');
                // Create gradient for depth
                const gradient = ctx.createLinearGradient(0, 0, this.size, this.size);
                gradient.addColorStop(0, '#3080c0');
                gradient.addColorStop(0.5, '#2070b0');
                gradient.addColorStop(1, '#3090d0');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, this.size, this.size);
                // Wave highlights
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.lineWidth = 2;
                for (let y = 0; y < this.size; y += 8) {
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    for (let x = 0; x < this.size; x += 4) {
                        ctx.lineTo(x, y + Math.sin(x * 0.2) * 2);
                    }
                    ctx.stroke();
                }
                // Foam/bubbles
                for (let i = 0; i < 15; i++) {
                    ctx.fillStyle = 'rgba(200, 230, 255, 0.4)';
                    ctx.beginPath();
                    ctx.arc(Math.random() * this.size, Math.random() * this.size, Math.random() * 2 + 1, 0, Math.PI * 2);
                    ctx.fill();
                }
                return canvas;
            }

            generateCobblestone() {
                const canvas = this.createCanvas();
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#5a5a5a';
                ctx.fillRect(0, 0, this.size, this.size);
                // Cobblestones
                const stones = [];
                for (let i = 0; i < 12; i++) {
                    stones.push({
                        x: Math.random() * this.size,
                        y: Math.random() * this.size,
                        r: Math.random() * 8 + 5
                    });
                }
                for (const stone of stones) {
                    ctx.fillStyle = this.varyColor(90, 90, 90, 30);
                    ctx.beginPath();
                    ctx.ellipse(stone.x, stone.y, stone.r, stone.r * 0.8, Math.random() * Math.PI, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = 'rgba(30,30,30,0.5)';
                    ctx.stroke();
                }
                return canvas;
            }

            generatePlanks() {
                const canvas = this.createCanvas();
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#ba9458';
                ctx.fillRect(0, 0, this.size, this.size);
                // Plank lines
                const plankHeight = this.size / 4;
                for (let y = 0; y < this.size; y += plankHeight) {
                    ctx.fillStyle = this.varyColor(186, 148, 88, 15);
                    ctx.fillRect(0, y, this.size, plankHeight - 1);
                    ctx.strokeStyle = 'rgba(80, 50, 20, 0.5)';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(0, y + plankHeight - 1);
                    ctx.lineTo(this.size, y + plankHeight - 1);
                    ctx.stroke();
                    // Wood grain
                    for (let i = 0; i < 5; i++) {
                        ctx.strokeStyle = 'rgba(120, 80, 40, 0.2)';
                        ctx.beginPath();
                        ctx.moveTo(0, y + Math.random() * plankHeight);
                        ctx.lineTo(this.size, y + Math.random() * plankHeight);
                        ctx.stroke();
                    }
                }
                // Nail holes
                for (let y = plankHeight / 2; y < this.size; y += plankHeight) {
                    ctx.fillStyle = '#3a2a1a';
                    ctx.beginPath();
                    ctx.arc(8, y, 2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(this.size - 8, y, 2, 0, Math.PI * 2);
                    ctx.fill();
                }
                return canvas;
            }

            generateBedrock() {
                const canvas = this.createCanvas();
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#1a1a1a';
                ctx.fillRect(0, 0, this.size, this.size);
                // Chaotic dark pattern
                for (let x = 0; x < this.size; x++) {
                    for (let y = 0; y < this.size; y++) {
                        const n = this.noise(x * 0.3, y * 0.3);
                        const gray = 20 + n * 40;
                        ctx.fillStyle = `rgb(${gray},${gray},${gray})`;
                        ctx.fillRect(x, y, 1, 1);
                    }
                }
                return canvas;
            }

            generateTNTSide() {
                const canvas = this.createCanvas();
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#cc2200';
                ctx.fillRect(0, 0, this.size, this.size);
                // TNT label band
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, this.size * 0.3, this.size, this.size * 0.4);
                // TNT text
                ctx.fillStyle = '#cc0000';
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('TNT', this.size / 2, this.size * 0.55);
                // Top/bottom bands
                ctx.fillStyle = '#8b0000';
                ctx.fillRect(0, 0, this.size, 4);
                ctx.fillRect(0, this.size - 4, this.size, 4);
                return canvas;
            }

            generateTNTTop() {
                const canvas = this.createCanvas();
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#8b0000';
                ctx.fillRect(0, 0, this.size, this.size);
                // Fuse hole
                ctx.fillStyle = '#333333';
                ctx.beginPath();
                ctx.arc(this.size / 2, this.size / 2, 6, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#666666';
                ctx.beginPath();
                ctx.arc(this.size / 2, this.size / 2, 3, 0, Math.PI * 2);
                ctx.fill();
                return canvas;
            }

            generateIce() {
                const canvas = this.createCanvas();
                const ctx = canvas.getContext('2d');
                const gradient = ctx.createLinearGradient(0, 0, this.size, this.size);
                gradient.addColorStop(0, '#aaddff');
                gradient.addColorStop(0.5, '#cceeFF');
                gradient.addColorStop(1, '#99ccff');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, this.size, this.size);
                // Ice cracks
                ctx.strokeStyle = 'rgba(255,255,255,0.6)';
                ctx.lineWidth = 1;
                for (let i = 0; i < 8; i++) {
                    ctx.beginPath();
                    let x = Math.random() * this.size;
                    let y = Math.random() * this.size;
                    ctx.moveTo(x, y);
                    for (let j = 0; j < 3; j++) {
                        x += (Math.random() - 0.5) * 20;
                        y += (Math.random() - 0.5) * 20;
                        ctx.lineTo(x, y);
                    }
                    ctx.stroke();
                }
                return canvas;
            }

            generateSnow() {
                const canvas = this.createCanvas();
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, this.size, this.size);
                // Subtle shadows
                for (let i = 0; i < 30; i++) {
                    ctx.fillStyle = `rgba(200, 210, 230, ${Math.random() * 0.3})`;
                    ctx.beginPath();
                    ctx.arc(Math.random() * this.size, Math.random() * this.size, Math.random() * 6 + 2, 0, Math.PI * 2);
                    ctx.fill();
                }
                // Sparkles
                for (let i = 0; i < 10; i++) {
                    ctx.fillStyle = 'rgba(255, 255, 255, 1)';
                    ctx.fillRect(Math.random() * this.size, Math.random() * this.size, 1, 1);
                }
                return canvas;
            }

            generateSnowGrassSide() {
                const canvas = this.createCanvas();
                const ctx = canvas.getContext('2d');
                // Dirt base
                ctx.fillStyle = '#8b6914';
                ctx.fillRect(0, 0, this.size, this.size);
                for (let i = 0; i < 80; i++) {
                    ctx.fillStyle = this.varyColor(139, 105, 20, 25);
                    ctx.fillRect(Math.random() * this.size, Math.random() * this.size, 3, 3);
                }
                // Snow top
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, this.size, 10);
                // Dripping snow
                for (let x = 0; x < this.size; x += 4) {
                    const h = Math.random() * 8 + 2;
                    ctx.fillStyle = '#eeeeee';
                    ctx.fillRect(x, 10, 3, h);
                }
                return canvas;
            }

            generateCactusSide() {
                const canvas = this.createCanvas();
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#1d5a0a';
                ctx.fillRect(0, 0, this.size, this.size);
                // Vertical ridges
                for (let x = 0; x < this.size; x += 8) {
                    ctx.fillStyle = '#2d6a1a';
                    ctx.fillRect(x, 0, 4, this.size);
                }
                // Spines
                ctx.fillStyle = '#aaaa77';
                for (let y = 4; y < this.size; y += 8) {
                    for (let x = 2; x < this.size; x += 8) {
                        ctx.fillRect(x, y, 2, 2);
                    }
                }
                return canvas;
            }

            generateCactusTop() {
                const canvas = this.createCanvas();
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#2d6a1a';
                ctx.fillRect(0, 0, this.size, this.size);
                // Star pattern
                ctx.fillStyle = '#1d5a0a';
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2;
                    ctx.beginPath();
                    ctx.moveTo(this.size / 2, this.size / 2);
                    ctx.lineTo(this.size / 2 + Math.cos(angle) * 25, this.size / 2 + Math.sin(angle) * 25);
                    ctx.lineTo(this.size / 2 + Math.cos(angle + 0.2) * 30, this.size / 2 + Math.sin(angle + 0.2) * 30);
                    ctx.fill();
                }
                return canvas;
            }

            generateOre(oreColor) {
                const canvas = this.createCanvas();
                const ctx = canvas.getContext('2d');
                // Stone base
                ctx.fillStyle = '#7a7a7a';
                ctx.fillRect(0, 0, this.size, this.size);
                for (let x = 0; x < this.size; x++) {
                    for (let y = 0; y < this.size; y++) {
                        const n = this.fbm(x / 8, y / 8);
                        const gray = 100 + n * 50;
                        ctx.fillStyle = `rgb(${gray},${gray},${gray})`;
                        ctx.fillRect(x, y, 1, 1);
                    }
                }
                // Ore deposits
                const rgb = this.hexToRgb(oreColor);
                for (let i = 0; i < 8; i++) {
                    const x = Math.random() * this.size;
                    const y = Math.random() * this.size;
                    ctx.fillStyle = `rgb(${rgb.r}, ${rgb.g}, ${rgb.b})`;
                    ctx.beginPath();
                    ctx.arc(x, y, Math.random() * 4 + 2, 0, Math.PI * 2);
                    ctx.fill();
                    // Highlight
                    ctx.fillStyle = `rgba(255,255,255,0.3)`;
                    ctx.beginPath();
                    ctx.arc(x - 1, y - 1, 2, 0, Math.PI * 2);
                    ctx.fill();
                }
                return canvas;
            }

            generateGravel() {
                const canvas = this.createCanvas();
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#6a6a6a';
                ctx.fillRect(0, 0, this.size, this.size);
                // Pebbles
                for (let i = 0; i < 25; i++) {
                    ctx.fillStyle = this.varyColor(106, 106, 106, 40);
                    ctx.beginPath();
                    ctx.ellipse(Math.random() * this.size, Math.random() * this.size, Math.random() * 5 + 2, Math.random() * 4 + 2, Math.random() * Math.PI, 0, Math.PI * 2);
                    ctx.fill();
                }
                return canvas;
            }

            generateClay() {
                const canvas = this.createCanvas();
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#9a9aaa';
                ctx.fillRect(0, 0, this.size, this.size);
                // Smooth texture
                for (let i = 0; i < 50; i++) {
                    ctx.fillStyle = this.varyColor(154, 154, 170, 15);
                    ctx.beginPath();
                    ctx.arc(Math.random() * this.size, Math.random() * this.size, Math.random() * 8 + 3, 0, Math.PI * 2);
                    ctx.fill();
                }
                return canvas;
            }

            generateGlass() {
                const canvas = this.createCanvas();
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = 'rgba(200, 230, 255, 0.3)';
                ctx.fillRect(0, 0, this.size, this.size);
                // Frame
                ctx.strokeStyle = 'rgba(150, 200, 230, 0.5)';
                ctx.lineWidth = 2;
                ctx.strokeRect(1, 1, this.size - 2, this.size - 2);
                // Reflection
                ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.beginPath();
                ctx.moveTo(4, 4);
                ctx.lineTo(12, 4);
                ctx.lineTo(4, 12);
                ctx.fill();
                return canvas;
            }

            generateBrick() {
                const canvas = this.createCanvas();
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#8b4513';
                ctx.fillRect(0, 0, this.size, this.size);
                // Mortar
                ctx.fillStyle = '#aaaaaa';
                ctx.fillRect(0, 0, this.size, this.size);
                // Bricks
                const brickH = this.size / 4;
                const brickW = this.size / 2;
                for (let row = 0; row < 4; row++) {
                    const offset = (row % 2) * (brickW / 2);
                    for (let col = -1; col < 3; col++) {
                        ctx.fillStyle = this.varyColor(139, 69, 19, 20);
                        ctx.fillRect(col * brickW + offset + 1, row * brickH + 1, brickW - 2, brickH - 2);
                    }
                }
                return canvas;
            }

            generateObsidian() {
                const canvas = this.createCanvas();
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#1a0a2a';
                ctx.fillRect(0, 0, this.size, this.size);
                // Glossy reflections
                for (let i = 0; i < 15; i++) {
                    ctx.fillStyle = `rgba(80, 40, 120, ${Math.random() * 0.3})`;
                    ctx.beginPath();
                    ctx.arc(Math.random() * this.size, Math.random() * this.size, Math.random() * 10 + 3, 0, Math.PI * 2);
                    ctx.fill();
                }
                // Highlight streaks
                ctx.strokeStyle = 'rgba(100, 60, 150, 0.4)';
                for (let i = 0; i < 5; i++) {
                    ctx.beginPath();
                    ctx.moveTo(Math.random() * this.size, Math.random() * this.size);
                    ctx.lineTo(Math.random() * this.size, Math.random() * this.size);
                    ctx.stroke();
                }
                return canvas;
            }

            generateLava() {
                const canvas = this.createCanvas();
                const ctx = canvas.getContext('2d');
                // Hot gradient
                const gradient = ctx.createRadialGradient(this.size / 2, this.size / 2, 0, this.size / 2, this.size / 2, this.size / 2);
                gradient.addColorStop(0, '#ffff00');
                gradient.addColorStop(0.3, '#ff8800');
                gradient.addColorStop(0.7, '#ff4400');
                gradient.addColorStop(1, '#cc2200');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, this.size, this.size);
                // Swirls
                for (let i = 0; i < 10; i++) {
                    ctx.fillStyle = `rgba(255, ${150 + Math.random() * 100}, 0, 0.5)`;
                    ctx.beginPath();
                    ctx.arc(Math.random() * this.size, Math.random() * this.size, Math.random() * 8 + 3, 0, Math.PI * 2);
                    ctx.fill();
                }
                // Hot spots
                for (let i = 0; i < 5; i++) {
                    ctx.fillStyle = 'rgba(255, 255, 200, 0.6)';
                    ctx.beginPath();
                    ctx.arc(Math.random() * this.size, Math.random() * this.size, Math.random() * 4 + 2, 0, Math.PI * 2);
                    ctx.fill();
                }
                return canvas;
            }

            // DOOM-style textures
            generateMetalFloor() {
                const canvas = this.createCanvas();
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#4a4a5a';
                ctx.fillRect(0, 0, this.size, this.size);
                // Diamond plate pattern
                for (let y = 0; y < this.size; y += 8) {
                    for (let x = (y % 16 === 0 ? 0 : 4); x < this.size; x += 8) {
                        ctx.fillStyle = '#5a5a6a';
                        ctx.beginPath();
                        ctx.moveTo(x + 4, y);
                        ctx.lineTo(x + 8, y + 4);
                        ctx.lineTo(x + 4, y + 8);
                        ctx.lineTo(x, y + 4);
                        ctx.fill();
                    }
                }
                // Scratches
                ctx.strokeStyle = 'rgba(30,30,40,0.3)';
                for (let i = 0; i < 5; i++) {
                    ctx.beginPath();
                    ctx.moveTo(Math.random() * this.size, Math.random() * this.size);
                    ctx.lineTo(Math.random() * this.size, Math.random() * this.size);
                    ctx.stroke();
                }
                return canvas;
            }

            generateMetalWall() {
                const canvas = this.createCanvas();
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#5a5a6a';
                ctx.fillRect(0, 0, this.size, this.size);
                // Rivets
                for (let x = 8; x < this.size; x += 16) {
                    for (let y = 8; y < this.size; y += 16) {
                        ctx.fillStyle = '#3a3a4a';
                        ctx.beginPath();
                        ctx.arc(x, y, 3, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.fillStyle = '#6a6a7a';
                        ctx.beginPath();
                        ctx.arc(x - 1, y - 1, 1.5, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
                // Panel lines
                ctx.strokeStyle = '#3a3a4a';
                ctx.lineWidth = 2;
                ctx.strokeRect(4, 4, this.size - 8, this.size - 8);
                return canvas;
            }

            generateRustyMetal() {
                const canvas = this.createCanvas();
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#5a3a2a';
                ctx.fillRect(0, 0, this.size, this.size);
                // Rust patches
                for (let x = 0; x < this.size; x++) {
                    for (let y = 0; y < this.size; y++) {
                        const n = this.fbm(x / 10, y / 10, 3);
                        if (n > 0.5) {
                            ctx.fillStyle = `rgb(${100 + n * 60}, ${50 + n * 30}, ${20 + n * 20})`;
                            ctx.fillRect(x, y, 1, 1);
                        }
                    }
                }
                // Drip stains
                ctx.fillStyle = 'rgba(60, 30, 10, 0.5)';
                for (let i = 0; i < 5; i++) {
                    const x = Math.random() * this.size;
                    ctx.fillRect(x, 0, 3, Math.random() * 30 + 10);
                }
                return canvas;
            }

            generateGrate() {
                const canvas = this.createCanvas();
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = 'rgba(0,0,0,0)';
                ctx.clearRect(0, 0, this.size, this.size);
                // Grate bars
                ctx.fillStyle = '#2a2a2a';
                for (let x = 0; x < this.size; x += 8) {
                    ctx.fillRect(x, 0, 3, this.size);
                }
                for (let y = 0; y < this.size; y += 8) {
                    ctx.fillRect(0, y, this.size, 3);
                }
                return canvas;
            }

            generateFlesh() {
                const canvas = this.createCanvas();
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#8a3a3a';
                ctx.fillRect(0, 0, this.size, this.size);
                // Veins
                ctx.strokeStyle = '#5a1a1a';
                ctx.lineWidth = 2;
                for (let i = 0; i < 8; i++) {
                    ctx.beginPath();
                    let x = Math.random() * this.size;
                    let y = Math.random() * this.size;
                    ctx.moveTo(x, y);
                    for (let j = 0; j < 5; j++) {
                        x += (Math.random() - 0.5) * 20;
                        y += (Math.random() - 0.5) * 20;
                        ctx.lineTo(x, y);
                    }
                    ctx.stroke();
                }
                // Bumps
                for (let i = 0; i < 15; i++) {
                    ctx.fillStyle = this.varyColor(138, 58, 58, 30);
                    ctx.beginPath();
                    ctx.arc(Math.random() * this.size, Math.random() * this.size, Math.random() * 5 + 2, 0, Math.PI * 2);
                    ctx.fill();
                }
                return canvas;
            }

            generateBlood() {
                const canvas = this.createCanvas();
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#6a0000';
                ctx.fillRect(0, 0, this.size, this.size);
                // Darker pools
                for (let i = 0; i < 10; i++) {
                    ctx.fillStyle = `rgba(40, 0, 0, ${Math.random() * 0.5})`;
                    ctx.beginPath();
                    ctx.arc(Math.random() * this.size, Math.random() * this.size, Math.random() * 10 + 5, 0, Math.PI * 2);
                    ctx.fill();
                }
                // Highlights
                for (let i = 0; i < 5; i++) {
                    ctx.fillStyle = 'rgba(150, 0, 0, 0.4)';
                    ctx.beginPath();
                    ctx.arc(Math.random() * this.size, Math.random() * this.size, Math.random() * 4 + 2, 0, Math.PI * 2);
                    ctx.fill();
                }
                return canvas;
            }

            generateBone() {
                const canvas = this.createCanvas();
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#ddd8c8';
                ctx.fillRect(0, 0, this.size, this.size);
                // Cracks
                ctx.strokeStyle = 'rgba(100, 90, 70, 0.5)';
                ctx.lineWidth = 1;
                for (let i = 0; i < 10; i++) {
                    ctx.beginPath();
                    let x = Math.random() * this.size;
                    let y = Math.random() * this.size;
                    ctx.moveTo(x, y);
                    for (let j = 0; j < 3; j++) {
                        x += (Math.random() - 0.5) * 15;
                        y += (Math.random() - 0.5) * 15;
                        ctx.lineTo(x, y);
                    }
                    ctx.stroke();
                }
                // Marrow spots
                for (let i = 0; i < 5; i++) {
                    ctx.fillStyle = 'rgba(180, 160, 140, 0.4)';
                    ctx.beginPath();
                    ctx.arc(Math.random() * this.size, Math.random() * this.size, Math.random() * 4 + 2, 0, Math.PI * 2);
                    ctx.fill();
                }
                return canvas;
            }

            generateSkullWall() {
                const canvas = this.createCanvas();
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#4a3a3a';
                ctx.fillRect(0, 0, this.size, this.size);
                // Skulls
                const drawSkull = (x, y, size) => {
                    ctx.fillStyle = '#ccc8b8';
                    ctx.beginPath();
                    ctx.arc(x, y, size, 0, Math.PI * 2);
                    ctx.fill();
                    // Eye sockets
                    ctx.fillStyle = '#1a1a1a';
                    ctx.beginPath();
                    ctx.arc(x - size * 0.3, y - size * 0.1, size * 0.25, 0, Math.PI * 2);
                    ctx.arc(x + size * 0.3, y - size * 0.1, size * 0.25, 0, Math.PI * 2);
                    ctx.fill();
                    // Nose
                    ctx.beginPath();
                    ctx.moveTo(x, y + size * 0.1);
                    ctx.lineTo(x - size * 0.15, y + size * 0.4);
                    ctx.lineTo(x + size * 0.15, y + size * 0.4);
                    ctx.fill();
                };
                drawSkull(16, 16, 10);
                drawSkull(48, 16, 8);
                drawSkull(32, 48, 10);
                return canvas;
            }

            generateHellBrick() {
                const canvas = this.createCanvas();
                const ctx = canvas.getContext('2d');
                // Mortar
                ctx.fillStyle = '#2a0000';
                ctx.fillRect(0, 0, this.size, this.size);
                // Bricks
                const brickH = this.size / 4;
                const brickW = this.size / 2;
                for (let row = 0; row < 4; row++) {
                    const offset = (row % 2) * (brickW / 2);
                    for (let col = -1; col < 3; col++) {
                        ctx.fillStyle = this.varyColor(90, 26, 26, 20);
                        ctx.fillRect(col * brickW + offset + 1, row * brickH + 1, brickW - 2, brickH - 2);
                    }
                }
                // Glowing cracks
                ctx.strokeStyle = 'rgba(255, 100, 0, 0.5)';
                ctx.lineWidth = 1;
                for (let i = 0; i < 3; i++) {
                    ctx.beginPath();
                    ctx.moveTo(Math.random() * this.size, Math.random() * this.size);
                    ctx.lineTo(Math.random() * this.size, Math.random() * this.size);
                    ctx.stroke();
                }
                return canvas;
            }

            generateMarble() {
                const canvas = this.createCanvas();
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#eaeaea';
                ctx.fillRect(0, 0, this.size, this.size);
                // Veins
                ctx.strokeStyle = 'rgba(180, 180, 190, 0.6)';
                ctx.lineWidth = 2;
                for (let i = 0; i < 5; i++) {
                    ctx.beginPath();
                    let x = Math.random() * this.size;
                    let y = 0;
                    ctx.moveTo(x, y);
                    while (y < this.size) {
                        x += (Math.random() - 0.5) * 10;
                        y += Math.random() * 10 + 5;
                        ctx.lineTo(x, y);
                    }
                    ctx.stroke();
                }
                return canvas;
            }

            generateTechPanel() {
                const canvas = this.createCanvas();
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#2a3a4a';
                ctx.fillRect(0, 0, this.size, this.size);
                // Circuit lines
                ctx.strokeStyle = '#00aaff';
                ctx.lineWidth = 1;
                for (let i = 0; i < 8; i++) {
                    ctx.beginPath();
                    let x = Math.random() * this.size;
                    let y = Math.random() * this.size;
                    ctx.moveTo(x, y);
                    for (let j = 0; j < 4; j++) {
                        if (Math.random() > 0.5) x += (Math.random() > 0.5 ? 1 : -1) * 10;
                        else y += (Math.random() > 0.5 ? 1 : -1) * 10;
                        ctx.lineTo(x, y);
                    }
                    ctx.stroke();
                }
                // LEDs
                for (let i = 0; i < 5; i++) {
                    ctx.fillStyle = Math.random() > 0.5 ? '#00ff00' : '#ff0000';
                    ctx.beginPath();
                    ctx.arc(Math.random() * this.size, Math.random() * this.size, 2, 0, Math.PI * 2);
                    ctx.fill();
                }
                return canvas;
            }

            generateComputer() {
                const canvas = this.createCanvas();
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#1a2a1a';
                ctx.fillRect(0, 0, this.size, this.size);
                // Screen
                ctx.fillStyle = '#003300';
                ctx.fillRect(8, 8, this.size - 16, this.size - 16);
                // Text lines
                ctx.fillStyle = '#00ff00';
                for (let y = 12; y < this.size - 12; y += 6) {
                    const width = Math.random() * 30 + 10;
                    ctx.fillRect(12, y, width, 3);
                }
                // Cursor blink
                ctx.fillStyle = '#00ff00';
                ctx.fillRect(12, this.size - 18, 4, 6);
                return canvas;
            }

            generatePipes() {
                const canvas = this.createCanvas();
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#3a3a1a';
                ctx.fillRect(0, 0, this.size, this.size);
                // Pipes
                const pipeColor = '#5a5a3a';
                ctx.fillStyle = pipeColor;
                ctx.fillRect(0, 8, this.size, 12);
                ctx.fillRect(0, 44, this.size, 12);
                // Pipe highlights
                ctx.fillStyle = '#6a6a4a';
                ctx.fillRect(0, 8, this.size, 4);
                ctx.fillRect(0, 44, this.size, 4);
                // Joints
                ctx.fillStyle = '#4a4a2a';
                ctx.fillRect(20, 4, 8, 20);
                ctx.fillRect(44, 40, 8, 20);
                return canvas;
            }

            generateVent() {
                const canvas = this.createCanvas();
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#3a3a3a';
                ctx.fillRect(0, 0, this.size, this.size);
                // Slats
                ctx.fillStyle = '#1a1a1a';
                for (let y = 4; y < this.size - 4; y += 6) {
                    ctx.fillRect(4, y, this.size - 8, 3);
                }
                // Frame
                ctx.strokeStyle = '#2a2a2a';
                ctx.lineWidth = 4;
                ctx.strokeRect(2, 2, this.size - 4, this.size - 4);
                return canvas;
            }

            generateWarning() {
                const canvas = this.createCanvas();
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#ffaa00';
                ctx.fillRect(0, 0, this.size, this.size);
                // Hazard symbol
                ctx.fillStyle = '#000000';
                ctx.beginPath();
                ctx.moveTo(this.size / 2, 8);
                ctx.lineTo(this.size - 8, this.size - 8);
                ctx.lineTo(8, this.size - 8);
                ctx.closePath();
                ctx.fill();
                ctx.fillStyle = '#ffaa00';
                ctx.beginPath();
                ctx.moveTo(this.size / 2, 16);
                ctx.lineTo(this.size - 14, this.size - 12);
                ctx.lineTo(14, this.size - 12);
                ctx.closePath();
                ctx.fill();
                // Exclamation
                ctx.fillStyle = '#000000';
                ctx.fillRect(this.size / 2 - 3, 28, 6, 16);
                ctx.beginPath();
                ctx.arc(this.size / 2, this.size - 18, 4, 0, Math.PI * 2);
                ctx.fill();
                return canvas;
            }

            generateWarningStripes() {
                const canvas = this.createCanvas();
                const ctx = canvas.getContext('2d');
                // Diagonal stripes
                for (let i = -this.size; i < this.size * 2; i += 16) {
                    ctx.fillStyle = (Math.floor(i / 16) % 2 === 0) ? '#ffaa00' : '#2a2a2a';
                    ctx.beginPath();
                    ctx.moveTo(i, 0);
                    ctx.lineTo(i + 8, 0);
                    ctx.lineTo(i + 8 + this.size, this.size);
                    ctx.lineTo(i + this.size, this.size);
                    ctx.fill();
                }
                return canvas;
            }

            generateNukeBarrelSide() {
                const canvas = this.createCanvas();
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#008800';
                ctx.fillRect(0, 0, this.size, this.size);
                // Bands
                ctx.fillStyle = '#2a2a2a';
                ctx.fillRect(0, 0, this.size, 6);
                ctx.fillRect(0, this.size - 6, this.size, 6);
                // Radiation symbol
                const cx = this.size / 2, cy = this.size / 2;
                ctx.fillStyle = '#ffff00';
                ctx.beginPath();
                ctx.arc(cx, cy, 6, 0, Math.PI * 2);
                ctx.fill();
                for (let i = 0; i < 3; i++) {
                    const angle = (i / 3) * Math.PI * 2 - Math.PI / 2;
                    ctx.beginPath();
                    ctx.moveTo(cx, cy);
                    ctx.arc(cx, cy, 15, angle - 0.4, angle + 0.4);
                    ctx.fill();
                }
                ctx.fillStyle = '#008800';
                ctx.beginPath();
                ctx.arc(cx, cy, 4, 0, Math.PI * 2);
                ctx.fill();
                return canvas;
            }

            generateNukeBarrelTop() {
                const canvas = this.createCanvas();
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#00aa00';
                ctx.fillRect(0, 0, this.size, this.size);
                // Lid rim
                ctx.strokeStyle = '#2a2a2a';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.arc(this.size / 2, this.size / 2, this.size / 2 - 4, 0, Math.PI * 2);
                ctx.stroke();
                // Center cap
                ctx.fillStyle = '#2a2a2a';
                ctx.beginPath();
                ctx.arc(this.size / 2, this.size / 2, 8, 0, Math.PI * 2);
                ctx.fill();
                return canvas;
            }

            generatePentagram() {
                const canvas = this.createCanvas();
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#4a0000';
                ctx.fillRect(0, 0, this.size, this.size);
                // Pentagram
                const cx = this.size / 2, cy = this.size / 2, r = this.size / 2 - 4;
                ctx.strokeStyle = '#ff0000';
                ctx.lineWidth = 2;
                ctx.beginPath();
                for (let i = 0; i < 5; i++) {
                    const angle = (i * 4 * Math.PI / 5) - Math.PI / 2;
                    const x = cx + Math.cos(angle) * r;
                    const y = cy + Math.sin(angle) * r;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.stroke();
                // Circle
                ctx.beginPath();
                ctx.arc(cx, cy, r, 0, Math.PI * 2);
                ctx.stroke();
                // Glow effect
                ctx.shadowColor = '#ff0000';
                ctx.shadowBlur = 10;
                ctx.stroke();
                return canvas;
            }

            generateLavaRock() {
                const canvas = this.createCanvas();
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#2a1a1a';
                ctx.fillRect(0, 0, this.size, this.size);
                // Cracks with lava
                for (let x = 0; x < this.size; x++) {
                    for (let y = 0; y < this.size; y++) {
                        const n = this.fbm(x / 8, y / 8);
                        if (n > 0.6) {
                            ctx.fillStyle = `rgb(${200 + n * 55}, ${80 + n * 50}, 0)`;
                            ctx.fillRect(x, y, 1, 1);
                        }
                    }
                }
                // Surface texture
                for (let i = 0; i < 30; i++) {
                    ctx.fillStyle = this.varyColor(42, 26, 26, 20);
                    ctx.fillRect(Math.random() * this.size, Math.random() * this.size, 3, 3);
                }
                return canvas;
            }

            generateAsh() {
                const canvas = this.createCanvas();
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#3a3a3a';
                ctx.fillRect(0, 0, this.size, this.size);
                // Ash particles
                for (let i = 0; i < 200; i++) {
                    ctx.fillStyle = this.varyColor(58, 58, 58, 20);
                    ctx.fillRect(Math.random() * this.size, Math.random() * this.size, 2, 2);
                }
                // Ember spots
                for (let i = 0; i < 5; i++) {
                    ctx.fillStyle = `rgba(255, ${Math.random() * 100 + 50}, 0, 0.3)`;
                    ctx.beginPath();
                    ctx.arc(Math.random() * this.size, Math.random() * this.size, 2, 0, Math.PI * 2);
                    ctx.fill();
                }
                return canvas;
            }

            generateCorruption() {
                const canvas = this.createCanvas();
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#2a0a2a';
                ctx.fillRect(0, 0, this.size, this.size);
                // Pulsing veins
                ctx.strokeStyle = '#ff00ff';
                ctx.lineWidth = 2;
                for (let i = 0; i < 6; i++) {
                    ctx.beginPath();
                    let x = Math.random() * this.size;
                    let y = Math.random() * this.size;
                    ctx.moveTo(x, y);
                    for (let j = 0; j < 4; j++) {
                        x += (Math.random() - 0.5) * 20;
                        y += (Math.random() - 0.5) * 20;
                        ctx.lineTo(x, y);
                    }
                    ctx.stroke();
                }
                // Eyes
                for (let i = 0; i < 3; i++) {
                    const x = Math.random() * this.size;
                    const y = Math.random() * this.size;
                    ctx.fillStyle = '#ff00ff';
                    ctx.beginPath();
                    ctx.ellipse(x, y, 4, 6, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#000000';
                    ctx.beginPath();
                    ctx.arc(x, y, 2, 0, Math.PI * 2);
                    ctx.fill();
                }
                return canvas;
            }

            // Weapon textures for hotbar display
            generateWeaponTexture(weaponKey) {
                const canvas = document.createElement('canvas');
                canvas.width = 64;
                canvas.height = 64;
                const ctx = canvas.getContext('2d');
                const weapon = WEAPONS[weaponKey];
                if (!weapon) return canvas;

                // Background
                ctx.fillStyle = '#222';
                ctx.fillRect(0, 0, 64, 64);

                switch(weaponKey) {
                    case 'CHAINSAW':
                        this.drawChainsaw(ctx);
                        break;
                    case 'SWORD':
                        this.drawSword(ctx);
                        break;
                    case 'SHOTGUN':
                        this.drawShotgun(ctx);
                        break;
                    case 'MINIGUN':
                        this.drawMinigun(ctx);
                        break;
                    case 'TNT_GUN':
                        this.drawTNTLauncher(ctx);
                        break;
                    case 'ROCKET_LAUNCHER':
                        this.drawRocketLauncher(ctx);
                        break;
                    case 'LASER_GUN':
                        this.drawLaserGun(ctx);
                        break;
                    case 'PLASMA_CANNON':
                        this.drawPlasmaCannon(ctx);
                        break;
                    case 'RAILGUN':
                        this.drawRailgun(ctx);
                        break;
                    case 'FLAMETHROWER':
                        this.drawFlamethrower(ctx);
                        break;
                    case 'LIGHTNING_STAFF':
                        this.drawLightningStaff(ctx);
                        break;
                    case 'FREEZE_RAY':
                        this.drawFreezeRay(ctx);
                        break;
                    case 'BFG':
                        this.drawBFG(ctx);
                        break;
                    case 'NUKE_LAUNCHER':
                        this.drawNukeLauncher(ctx);
                        break;
                    case 'BLACK_HOLE':
                        this.drawBlackHoleGun(ctx);
                        break;
                    case 'GRAVITY_GUN':
                        this.drawGravityGun(ctx);
                        break;
                    case 'GRENADE':
                        this.drawGrenade(ctx);
                        break;
                    case 'CLUSTER_BOMB':
                        this.drawClusterBomb(ctx);
                        break;
                    case 'BOW':
                        this.drawBow(ctx);
                        break;
                    default:
                        // Generic gun shape
                        ctx.fillStyle = weapon.color || '#888';
                        ctx.fillRect(8, 24, 48, 16);
                        ctx.fillRect(16, 32, 12, 16);
                }
                return canvas;
            }

            drawChainsaw(ctx) {
                // Body
                ctx.fillStyle = '#444';
                ctx.fillRect(8, 28, 30, 12);
                // Handle
                ctx.fillStyle = '#8b4513';
                ctx.fillRect(32, 24, 12, 20);
                // Blade
                ctx.fillStyle = '#888';
                ctx.fillRect(4, 30, 28, 8);
                // Teeth
                ctx.fillStyle = '#aaa';
                for (let x = 6; x < 30; x += 4) {
                    ctx.fillRect(x, 28, 2, 3);
                    ctx.fillRect(x, 37, 2, 3);
                }
                // Engine
                ctx.fillStyle = '#ff4400';
                ctx.fillRect(38, 28, 8, 8);
            }

            drawSword(ctx) {
                // Blade
                ctx.fillStyle = '#55ffff';
                ctx.beginPath();
                ctx.moveTo(32, 4);
                ctx.lineTo(36, 40);
                ctx.lineTo(32, 44);
                ctx.lineTo(28, 40);
                ctx.closePath();
                ctx.fill();
                // Guard
                ctx.fillStyle = '#ffd700';
                ctx.fillRect(24, 42, 16, 4);
                // Handle
                ctx.fillStyle = '#8b4513';
                ctx.fillRect(29, 46, 6, 14);
                // Pommel
                ctx.fillStyle = '#ffd700';
                ctx.beginPath();
                ctx.arc(32, 60, 4, 0, Math.PI * 2);
                ctx.fill();
            }

            drawShotgun(ctx) {
                // Barrel
                ctx.fillStyle = '#444';
                ctx.fillRect(4, 28, 40, 6);
                ctx.fillRect(4, 35, 40, 6);
                // Receiver
                ctx.fillStyle = '#555';
                ctx.fillRect(36, 26, 16, 16);
                // Stock
                ctx.fillStyle = '#8b4513';
                ctx.fillRect(48, 28, 12, 10);
                // Pump
                ctx.fillStyle = '#333';
                ctx.fillRect(20, 26, 10, 4);
            }

            drawMinigun(ctx) {
                // Barrels
                ctx.fillStyle = '#555';
                for (let i = 0; i < 6; i++) {
                    const angle = (i / 6) * Math.PI * 2;
                    const y = 32 + Math.sin(angle) * 8;
                    ctx.fillRect(4, y - 2, 36, 4);
                }
                // Body
                ctx.fillStyle = '#666';
                ctx.fillRect(36, 20, 20, 24);
                // Handle
                ctx.fillStyle = '#333';
                ctx.fillRect(44, 44, 8, 12);
            }

            drawTNTLauncher(ctx) {
                // Tube
                ctx.fillStyle = '#666';
                ctx.fillRect(8, 24, 36, 16);
                // TNT
                ctx.fillStyle = '#cc2200';
                ctx.fillRect(10, 26, 12, 12);
                ctx.fillStyle = '#fff';
                ctx.fillRect(12, 28, 8, 8);
                // Handle
                ctx.fillStyle = '#444';
                ctx.fillRect(40, 28, 16, 8);
                ctx.fillRect(44, 36, 8, 12);
            }

            drawRocketLauncher(ctx) {
                // Tube
                ctx.fillStyle = '#555';
                ctx.fillRect(4, 22, 44, 20);
                // Rocket tip visible
                ctx.fillStyle = '#ff0000';
                ctx.beginPath();
                ctx.moveTo(4, 32);
                ctx.lineTo(8, 26);
                ctx.lineTo(8, 38);
                ctx.fill();
                // Scope
                ctx.fillStyle = '#333';
                ctx.fillRect(24, 18, 12, 6);
                // Handle
                ctx.fillStyle = '#444';
                ctx.fillRect(40, 38, 12, 14);
            }

            drawLaserGun(ctx) {
                // Body
                ctx.fillStyle = '#336';
                ctx.fillRect(12, 24, 36, 16);
                // Barrel
                ctx.fillStyle = '#00ffff';
                ctx.fillRect(4, 28, 12, 8);
                // Glow
                ctx.fillStyle = 'rgba(0, 255, 255, 0.3)';
                ctx.beginPath();
                ctx.arc(10, 32, 8, 0, Math.PI * 2);
                ctx.fill();
                // Handle
                ctx.fillStyle = '#224';
                ctx.fillRect(32, 36, 10, 14);
            }

            drawPlasmaCannon(ctx) {
                // Body
                ctx.fillStyle = '#226';
                ctx.fillRect(16, 22, 32, 20);
                // Plasma chamber
                ctx.fillStyle = '#00ff88';
                ctx.beginPath();
                ctx.arc(12, 32, 10, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = 'rgba(0, 255, 136, 0.5)';
                ctx.beginPath();
                ctx.arc(12, 32, 14, 0, Math.PI * 2);
                ctx.fill();
                // Handle
                ctx.fillStyle = '#114';
                ctx.fillRect(36, 38, 10, 14);
            }

            drawRailgun(ctx) {
                // Rails
                ctx.fillStyle = '#666';
                ctx.fillRect(4, 26, 44, 4);
                ctx.fillRect(4, 34, 44, 4);
                // Capacitors
                ctx.fillStyle = '#ff00ff';
                ctx.fillRect(12, 28, 8, 8);
                ctx.fillRect(24, 28, 8, 8);
                // Body
                ctx.fillStyle = '#444';
                ctx.fillRect(40, 24, 16, 16);
                // Handle
                ctx.fillStyle = '#333';
                ctx.fillRect(44, 38, 8, 12);
            }

            drawFlamethrower(ctx) {
                // Tank
                ctx.fillStyle = '#ff4400';
                ctx.fillRect(36, 16, 20, 32);
                // Nozzle
                ctx.fillStyle = '#666';
                ctx.fillRect(4, 28, 36, 8);
                // Flame tip
                ctx.fillStyle = '#ff8800';
                ctx.beginPath();
                ctx.moveTo(4, 32);
                ctx.lineTo(8, 26);
                ctx.lineTo(8, 38);
                ctx.fill();
                // Pilot light
                ctx.fillStyle = '#ffff00';
                ctx.beginPath();
                ctx.arc(8, 32, 3, 0, Math.PI * 2);
                ctx.fill();
            }

            drawLightningStaff(ctx) {
                // Staff
                ctx.fillStyle = '#8b4513';
                ctx.fillRect(28, 8, 8, 48);
                // Orb
                ctx.fillStyle = '#ffff00';
                ctx.beginPath();
                ctx.arc(32, 12, 8, 0, Math.PI * 2);
                ctx.fill();
                // Lightning bolts
                ctx.strokeStyle = '#ffff88';
                ctx.lineWidth = 2;
                for (let i = 0; i < 4; i++) {
                    const angle = (i / 4) * Math.PI * 2;
                    ctx.beginPath();
                    ctx.moveTo(32 + Math.cos(angle) * 8, 12 + Math.sin(angle) * 8);
                    ctx.lineTo(32 + Math.cos(angle) * 16, 12 + Math.sin(angle) * 16);
                    ctx.stroke();
                }
            }

            drawFreezeRay(ctx) {
                // Body
                ctx.fillStyle = '#446688';
                ctx.fillRect(16, 24, 32, 16);
                // Barrel
                ctx.fillStyle = '#aaddff';
                ctx.fillRect(4, 28, 16, 8);
                // Ice crystal
                ctx.fillStyle = '#88ccff';
                ctx.beginPath();
                ctx.moveTo(8, 24);
                ctx.lineTo(12, 32);
                ctx.lineTo(8, 40);
                ctx.lineTo(4, 32);
                ctx.fill();
                // Handle
                ctx.fillStyle = '#334455';
                ctx.fillRect(36, 36, 10, 14);
            }

            drawBFG(ctx) {
                // Body
                ctx.fillStyle = '#228822';
                ctx.fillRect(12, 18, 40, 28);
                // Barrel
                ctx.fillStyle = '#00ff00';
                ctx.beginPath();
                ctx.arc(12, 32, 12, 0, Math.PI * 2);
                ctx.fill();
                // Glow
                ctx.fillStyle = 'rgba(0, 255, 0, 0.4)';
                ctx.beginPath();
                ctx.arc(12, 32, 18, 0, Math.PI * 2);
                ctx.fill();
                // Handle
                ctx.fillStyle = '#115511';
                ctx.fillRect(40, 42, 10, 14);
                // BFG text
                ctx.fillStyle = '#00ff00';
                ctx.font = 'bold 10px Arial';
                ctx.fillText('BFG', 24, 36);
            }

            drawNukeLauncher(ctx) {
                // Tube
                ctx.fillStyle = '#555';
                ctx.fillRect(8, 20, 40, 24);
                // Warhead
                ctx.fillStyle = '#ffff00';
                ctx.beginPath();
                ctx.arc(12, 32, 8, 0, Math.PI * 2);
                ctx.fill();
                // Radiation symbol
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(12, 32, 3, 0, Math.PI * 2);
                ctx.fill();
                // Handle
                ctx.fillStyle = '#333';
                ctx.fillRect(44, 36, 12, 16);
            }

            drawBlackHoleGun(ctx) {
                // Body
                ctx.fillStyle = '#220044';
                ctx.fillRect(16, 22, 32, 20);
                // Singularity
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(12, 32, 10, 0, Math.PI * 2);
                ctx.fill();
                // Accretion disk
                ctx.strokeStyle = '#8844ff';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(12, 32, 12, 0, Math.PI * 2);
                ctx.stroke();
                // Handle
                ctx.fillStyle = '#110022';
                ctx.fillRect(40, 38, 10, 14);
            }

            drawGravityGun(ctx) {
                // Body
                ctx.fillStyle = '#442288';
                ctx.fillRect(16, 22, 32, 20);
                // Prongs
                ctx.fillStyle = '#8844ff';
                ctx.fillRect(4, 24, 16, 4);
                ctx.fillRect(4, 36, 16, 4);
                // Energy core
                ctx.fillStyle = '#aa66ff';
                ctx.beginPath();
                ctx.arc(12, 32, 6, 0, Math.PI * 2);
                ctx.fill();
                // Handle
                ctx.fillStyle = '#331166';
                ctx.fillRect(40, 38, 10, 14);
            }

            drawGrenade(ctx) {
                // Body
                ctx.fillStyle = '#006600';
                ctx.beginPath();
                ctx.arc(32, 36, 16, 0, Math.PI * 2);
                ctx.fill();
                // Top
                ctx.fillStyle = '#444';
                ctx.fillRect(28, 16, 8, 8);
                // Pin
                ctx.fillStyle = '#888';
                ctx.beginPath();
                ctx.arc(36, 20, 4, 0, Math.PI * 2);
                ctx.stroke();
                // Ridges
                ctx.strokeStyle = '#004400';
                ctx.lineWidth = 2;
                for (let y = 28; y < 48; y += 4) {
                    ctx.beginPath();
                    ctx.arc(32, 36, 16 - Math.abs(y - 36) / 2, 0.2, Math.PI - 0.2);
                    ctx.stroke();
                }
            }

            drawClusterBomb(ctx) {
                // Main body
                ctx.fillStyle = '#ff0066';
                ctx.beginPath();
                ctx.arc(32, 32, 12, 0, Math.PI * 2);
                ctx.fill();
                // Bomblets
                ctx.fillStyle = '#ff4488';
                for (let i = 0; i < 6; i++) {
                    const angle = (i / 6) * Math.PI * 2;
                    ctx.beginPath();
                    ctx.arc(32 + Math.cos(angle) * 18, 32 + Math.sin(angle) * 18, 5, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            drawBow(ctx) {
                // Bow curve
                ctx.strokeStyle = '#8b4513';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.arc(40, 32, 24, Math.PI * 0.7, Math.PI * 1.3);
                ctx.stroke();
                // String
                ctx.strokeStyle = '#ccc';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(40 + Math.cos(Math.PI * 0.7) * 24, 32 + Math.sin(Math.PI * 0.7) * 24);
                ctx.lineTo(40 + Math.cos(Math.PI * 1.3) * 24, 32 + Math.sin(Math.PI * 1.3) * 24);
                ctx.stroke();
                // Arrow
                ctx.fillStyle = '#8b4513';
                ctx.fillRect(8, 31, 30, 2);
                ctx.fillStyle = '#555';
                ctx.beginPath();
                ctx.moveTo(4, 32);
                ctx.lineTo(10, 28);
                ctx.lineTo(10, 36);
                ctx.fill();
            }

            getTexture(blockType, face) {
                return this.textures[blockType]?.[face];
            }
        }

        // ============================================
        // CONFIGURATION
        // ============================================
        const CONFIG = {
            CHUNK_SIZE: 16, WORLD_HEIGHT: 128, RENDER_DISTANCE: 6,
            GRAVITY: 32, JUMP_FORCE: 9.5, MOVE_SPEED: 5, SNEAK_SPEED: 2,
            MOUSE_SENSITIVITY: 0.002, PLAYER_HEIGHT: 1.62, PLAYER_WIDTH: 0.6,
            PLAYER_EYE_HEIGHT: 1.52, STEP_HEIGHT: 0.6, REACH_DISTANCE: 6,
            WORKER_COUNT: navigator.hardwareConcurrency || 4,
            FLY_SPEED: 15, MAX_HEALTH: 10, FALL_DAMAGE_THRESHOLD: 4,
            DAY_LENGTH: 600, CAVE_THRESHOLD: 0.6
        };

        // Biome types
        const BIOMES = {
            PLAINS: 0, DESERT: 1, SNOW: 2, FOREST: 3, OCEAN: 4
        };

        // ============================================
        // BLOCKS & WEAPONS
        // ============================================
        const BLOCKS = {
            AIR: 0, GRASS: 1, DIRT: 2, STONE: 3, WOOD: 4, LEAVES: 5,
            SAND: 6, WATER: 7, COBBLESTONE: 8, PLANKS: 9, BEDROCK: 10, TNT: 11, ICE: 12,
            SNOW: 13, SNOW_GRASS: 14, CACTUS: 15, COAL_ORE: 16, IRON_ORE: 17,
            GOLD_ORE: 18, DIAMOND_ORE: 19, GRAVEL: 20, CLAY: 21, GLASS: 22,
            BRICK: 23, OBSIDIAN: 24, LAVA: 25,
            // DOOM-style blocks
            METAL_FLOOR: 26, METAL_WALL: 27, RUSTY_METAL: 28, GRATE: 29,
            FLESH: 30, BLOOD: 31, BONE: 32, SKULL_WALL: 33,
            HELL_BRICK: 34, MARBLE: 35, TECH_PANEL: 36, COMPUTER: 37,
            PIPES: 38, VENT: 39, WARNING: 40, NUKE_BARREL: 41,
            PENTAGRAM: 42, LAVA_ROCK: 43, ASH: 44, CORRUPTION: 45
        };

        const BLOCK_DATA = {
            [BLOCKS.GRASS]: { name: 'Grass', colors: { top: 0x5d9b3a, side: 0x8b6914, bottom: 0x8b6914 }, solid: true },
            [BLOCKS.DIRT]: { name: 'Dirt', colors: { top: 0x8b6914, side: 0x8b6914, bottom: 0x8b6914 }, solid: true },
            [BLOCKS.STONE]: { name: 'Stone', colors: { top: 0x7a7a7a, side: 0x7a7a7a, bottom: 0x7a7a7a }, solid: true },
            [BLOCKS.WOOD]: { name: 'Wood', colors: { top: 0x9a7a4a, side: 0x5a3a1a, bottom: 0x9a7a4a }, solid: true },
            [BLOCKS.LEAVES]: { name: 'Leaves', colors: { top: 0x2a6a1a, side: 0x2a6a1a, bottom: 0x2a6a1a }, solid: true, transparent: true, opacity: 0.85 },
            [BLOCKS.SAND]: { name: 'Sand', colors: { top: 0xd4c896, side: 0xd4c896, bottom: 0xd4c896 }, solid: true },
            [BLOCKS.WATER]: { name: 'Water', colors: { top: 0x3070b0, side: 0x3070b0, bottom: 0x3070b0 }, solid: false, transparent: true, opacity: 0.7 },
            [BLOCKS.COBBLESTONE]: { name: 'Cobblestone', colors: { top: 0x5a5a5a, side: 0x5a5a5a, bottom: 0x5a5a5a }, solid: true },
            [BLOCKS.PLANKS]: { name: 'Planks', colors: { top: 0xba9458, side: 0xba9458, bottom: 0xba9458 }, solid: true },
            [BLOCKS.BEDROCK]: { name: 'Bedrock', colors: { top: 0x3a3a3a, side: 0x3a3a3a, bottom: 0x3a3a3a }, solid: true },
            [BLOCKS.TNT]: { name: 'TNT', colors: { top: 0xff0000, side: 0xff3333, bottom: 0x8b0000 }, solid: true },
            [BLOCKS.ICE]: { name: 'Ice', colors: { top: 0xaaddff, side: 0x99ccff, bottom: 0x88bbff }, solid: true, transparent: true, opacity: 0.8 },
            [BLOCKS.SNOW]: { name: 'Snow', colors: { top: 0xffffff, side: 0xeeeeee, bottom: 0xdddddd }, solid: true },
            [BLOCKS.SNOW_GRASS]: { name: 'Snowy Grass', colors: { top: 0xffffff, side: 0x8b6914, bottom: 0x8b6914 }, solid: true },
            [BLOCKS.CACTUS]: { name: 'Cactus', colors: { top: 0x2d6a1a, side: 0x1d5a0a, bottom: 0x1d5a0a }, solid: true },
            [BLOCKS.COAL_ORE]: { name: 'Coal Ore', colors: { top: 0x4a4a4a, side: 0x4a4a4a, bottom: 0x4a4a4a }, solid: true },
            [BLOCKS.IRON_ORE]: { name: 'Iron Ore', colors: { top: 0x8a7a6a, side: 0x8a7a6a, bottom: 0x8a7a6a }, solid: true },
            [BLOCKS.GOLD_ORE]: { name: 'Gold Ore', colors: { top: 0x9a8a3a, side: 0x9a8a3a, bottom: 0x9a8a3a }, solid: true },
            [BLOCKS.DIAMOND_ORE]: { name: 'Diamond Ore', colors: { top: 0x5acdcd, side: 0x5acdcd, bottom: 0x5acdcd }, solid: true },
            [BLOCKS.GRAVEL]: { name: 'Gravel', colors: { top: 0x6a6a6a, side: 0x6a6a6a, bottom: 0x6a6a6a }, solid: true },
            [BLOCKS.CLAY]: { name: 'Clay', colors: { top: 0x9a9aaa, side: 0x9a9aaa, bottom: 0x9a9aaa }, solid: true },
            [BLOCKS.GLASS]: { name: 'Glass', colors: { top: 0xddffff, side: 0xddffff, bottom: 0xddffff }, solid: true, transparent: true, opacity: 0.3 },
            [BLOCKS.BRICK]: { name: 'Brick', colors: { top: 0x8b4513, side: 0x8b4513, bottom: 0x8b4513 }, solid: true },
            [BLOCKS.OBSIDIAN]: { name: 'Obsidian', colors: { top: 0x1a0a2a, side: 0x1a0a2a, bottom: 0x1a0a2a }, solid: true },
            [BLOCKS.LAVA]: { name: 'Lava', colors: { top: 0xff6600, side: 0xff4400, bottom: 0xff2200 }, solid: false, transparent: true, opacity: 0.9, emissive: true },
            // DOOM-style blocks
            [BLOCKS.METAL_FLOOR]: { name: 'Metal Floor', colors: { top: 0x4a4a5a, side: 0x3a3a4a, bottom: 0x3a3a4a }, solid: true },
            [BLOCKS.METAL_WALL]: { name: 'Metal Wall', colors: { top: 0x5a5a6a, side: 0x5a5a6a, bottom: 0x4a4a5a }, solid: true },
            [BLOCKS.RUSTY_METAL]: { name: 'Rusty Metal', colors: { top: 0x6a4a3a, side: 0x5a3a2a, bottom: 0x4a2a1a }, solid: true },
            [BLOCKS.GRATE]: { name: 'Grate', colors: { top: 0x2a2a2a, side: 0x2a2a2a, bottom: 0x1a1a1a }, solid: true, transparent: true, opacity: 0.7 },
            [BLOCKS.FLESH]: { name: 'Flesh', colors: { top: 0x8a3a3a, side: 0x7a2a2a, bottom: 0x6a1a1a }, solid: true },
            [BLOCKS.BLOOD]: { name: 'Blood', colors: { top: 0x6a0000, side: 0x5a0000, bottom: 0x4a0000 }, solid: false, transparent: true, opacity: 0.8 },
            [BLOCKS.BONE]: { name: 'Bone', colors: { top: 0xddd8c8, side: 0xccc8b8, bottom: 0xbbb8a8 }, solid: true },
            [BLOCKS.SKULL_WALL]: { name: 'Skull Wall', colors: { top: 0x4a3a3a, side: 0x5a4a4a, bottom: 0x3a2a2a }, solid: true },
            [BLOCKS.HELL_BRICK]: { name: 'Hell Brick', colors: { top: 0x5a1a1a, side: 0x4a0a0a, bottom: 0x3a0000 }, solid: true },
            [BLOCKS.MARBLE]: { name: 'Marble', colors: { top: 0xeaeaea, side: 0xdadada, bottom: 0xcacaca }, solid: true },
            [BLOCKS.TECH_PANEL]: { name: 'Tech Panel', colors: { top: 0x2a3a4a, side: 0x3a4a5a, bottom: 0x1a2a3a }, solid: true, emissive: true },
            [BLOCKS.COMPUTER]: { name: 'Computer', colors: { top: 0x1a2a1a, side: 0x2a4a2a, bottom: 0x1a2a1a }, solid: true, emissive: true },
            [BLOCKS.PIPES]: { name: 'Pipes', colors: { top: 0x4a4a2a, side: 0x5a5a3a, bottom: 0x3a3a1a }, solid: true },
            [BLOCKS.VENT]: { name: 'Vent', colors: { top: 0x3a3a3a, side: 0x2a2a2a, bottom: 0x1a1a1a }, solid: true },
            [BLOCKS.WARNING]: { name: 'Warning', colors: { top: 0xffaa00, side: 0x2a2a2a, bottom: 0x2a2a2a }, solid: true },
            [BLOCKS.NUKE_BARREL]: { name: 'Nuke Barrel', colors: { top: 0x00aa00, side: 0x008800, bottom: 0x2a2a2a }, solid: true, explosive: true },
            [BLOCKS.PENTAGRAM]: { name: 'Pentagram', colors: { top: 0x4a0000, side: 0x2a0000, bottom: 0x1a0000 }, solid: true, emissive: true },
            [BLOCKS.LAVA_ROCK]: { name: 'Lava Rock', colors: { top: 0x3a2a2a, side: 0x2a1a1a, bottom: 0x1a0a0a }, solid: true },
            [BLOCKS.ASH]: { name: 'Ash', colors: { top: 0x3a3a3a, side: 0x2a2a2a, bottom: 0x2a2a2a }, solid: true },
            [BLOCKS.CORRUPTION]: { name: 'Corruption', colors: { top: 0x2a0a2a, side: 0x3a1a3a, bottom: 0x1a001a }, solid: true, emissive: true }
        };

        const WEAPONS = {
            TNT_GUN: {
                name: 'TNT Launcher', color: '#ff4400', fireRate: 0.15,
                crosshair: 'gun', sound: 'shoot_tnt', projectileSpeed: 60,
                explosionRadius: 4, gravity: -25
            },
            LASER_GUN: {
                name: 'Laser Rifle', color: '#00ffff', fireRate: 0.08,
                crosshair: 'laser', sound: 'shoot_laser', damage: 3, range: 100
            },
            RAILGUN: {
                name: 'Railgun', color: '#ff00ff', fireRate: 1.0,
                crosshair: 'railgun', sound: 'shoot_railgun', damage: 50,
                explosionRadius: 6, penetration: 10
            },
            MINIGUN: {
                name: 'Minigun', color: '#ffaa00', fireRate: 0.03,
                crosshair: 'gun', sound: 'shoot_minigun', damage: 1, spread: 0.05
            },
            FREEZE_RAY: {
                name: 'Freeze Ray', color: '#aaddff', fireRate: 0.2,
                crosshair: 'laser', sound: 'freeze', range: 30
            },
            SWORD: {
                name: 'Diamond Sword', color: '#55ffff', fireRate: 0.4,
                crosshair: 'default', sound: 'sword', damage: 7, range: 4, melee: true
            },
            BOW: {
                name: 'Bow', color: '#8b4513', fireRate: 0.8,
                crosshair: 'default', sound: 'bow', projectileSpeed: 50, damage: 5, gravity: -15
            },
            GRENADE: {
                name: 'Grenade', color: '#006600', fireRate: 1.0,
                crosshair: 'gun', sound: 'throw', projectileSpeed: 25,
                explosionRadius: 3, gravity: -20, fuse: 2.0
            },
            ROCKET_LAUNCHER: {
                name: 'Rocket Launcher', color: '#ff6600', fireRate: 0.8,
                crosshair: 'gun', sound: 'rocket', projectileSpeed: 40,
                explosionRadius: 6, gravity: -5, rocket: true
            },
            SHOTGUN: {
                name: 'Shotgun', color: '#884422', fireRate: 0.6,
                crosshair: 'gun', sound: 'shotgun', damage: 4, spread: 0.15, pellets: 8
            },
            PLASMA_CANNON: {
                name: 'Plasma Cannon', color: '#00ff88', fireRate: 0.5,
                crosshair: 'laser', sound: 'plasma', projectileSpeed: 80,
                explosionRadius: 3, damage: 15, plasma: true
            },
            FLAMETHROWER: {
                name: 'Flamethrower', color: '#ff8800', fireRate: 0.02,
                crosshair: 'gun', sound: 'chainsaw', damage: 2, range: 15, flame: true
            },
            LIGHTNING_STAFF: {
                name: 'Lightning Staff', color: '#ffff00', fireRate: 0.4,
                crosshair: 'laser', sound: 'lightning', damage: 8, range: 40, chain: 3, lightning: true
            },
            CLUSTER_BOMB: {
                name: 'Cluster Bomb', color: '#ff0066', fireRate: 1.5,
                crosshair: 'gun', sound: 'throw', projectileSpeed: 30,
                explosionRadius: 2, gravity: -15, cluster: 6
            },
            BFG: {
                name: 'BFG 9000', color: '#00ff00', fireRate: 2.0,
                crosshair: 'railgun', sound: 'bfg', projectileSpeed: 25,
                explosionRadius: 10, damage: 100, bfg: true
            },
            NUKE_LAUNCHER: {
                name: 'Nuke Launcher', color: '#ffff00', fireRate: 5.0,
                crosshair: 'railgun', sound: 'nuke', projectileSpeed: 30,
                explosionRadius: 15, gravity: -8, nuke: true
            },
            GRAVITY_GUN: {
                name: 'Gravity Gun', color: '#8844ff', fireRate: 0.1,
                crosshair: 'laser', sound: 'freeze', range: 30, gravity_gun: true, push: true
            },
            BLACK_HOLE: {
                name: 'Black Hole Gun', color: '#220044', fireRate: 3.0,
                crosshair: 'railgun', sound: 'black_hole', projectileSpeed: 20,
                range: 50, black_hole: true, duration: 3
            },
            CHAINSAW: {
                name: 'Chainsaw', color: '#ff4400', fireRate: 0.1,
                crosshair: 'default', sound: 'chainsaw', damage: 5, range: 3, melee: true
            }
        };

        // ============================================
        // WEB WORKER CODE
        // ============================================
        const workerCode = `
            const CONFIG = { CHUNK_SIZE: 16, WORLD_HEIGHT: 128 };
            const BLOCKS = { AIR: 0, GRASS: 1, DIRT: 2, STONE: 3, WOOD: 4, LEAVES: 5, SAND: 6, WATER: 7, COBBLESTONE: 8, PLANKS: 9, BEDROCK: 10, TNT: 11, ICE: 12, SNOW: 13, SNOW_GRASS: 14, CACTUS: 15, COAL_ORE: 16, IRON_ORE: 17, GOLD_ORE: 18, DIAMOND_ORE: 19, GRAVEL: 20, CLAY: 21, GLASS: 22, BRICK: 23, OBSIDIAN: 24, LAVA: 25 };
            const BLOCK_DATA = {
                1: { solid: true, transparent: false }, 2: { solid: true, transparent: false },
                3: { solid: true, transparent: false }, 4: { solid: true, transparent: false },
                5: { solid: true, transparent: true }, 6: { solid: true, transparent: false },
                7: { solid: false, transparent: true }, 8: { solid: true, transparent: false },
                9: { solid: true, transparent: false }, 10: { solid: true, transparent: false },
                11: { solid: true, transparent: false }, 12: { solid: true, transparent: true },
                13: { solid: true, transparent: false }, 14: { solid: true, transparent: false },
                15: { solid: true, transparent: false }, 16: { solid: true, transparent: false },
                17: { solid: true, transparent: false }, 18: { solid: true, transparent: false },
                19: { solid: true, transparent: false }, 20: { solid: true, transparent: false },
                21: { solid: true, transparent: false }, 22: { solid: true, transparent: true },
                23: { solid: true, transparent: false }, 24: { solid: true, transparent: false },
                25: { solid: false, transparent: true }
            };
            let chunkCache = new Map();
            function getLocalIndex(lx, y, lz) { return lx + lz * CONFIG.CHUNK_SIZE + y * CONFIG.CHUNK_SIZE * CONFIG.CHUNK_SIZE; }
            function getBlockFromChunks(worldX, y, worldZ, mainChunk, cx, cz) {
                if (y < 0 || y >= CONFIG.WORLD_HEIGHT) return BLOCKS.AIR;
                const targetCX = Math.floor(worldX / CONFIG.CHUNK_SIZE);
                const targetCZ = Math.floor(worldZ / CONFIG.CHUNK_SIZE);
                let chunk = (targetCX === cx && targetCZ === cz) ? mainChunk : chunkCache.get(targetCX + ',' + targetCZ);
                if (!chunk) return BLOCKS.AIR;
                const lx = ((worldX % CONFIG.CHUNK_SIZE) + CONFIG.CHUNK_SIZE) % CONFIG.CHUNK_SIZE;
                const lz = ((worldZ % CONFIG.CHUNK_SIZE) + CONFIG.CHUNK_SIZE) % CONFIG.CHUNK_SIZE;
                return chunk[getLocalIndex(lx, y, lz)];
            }
            function getTopFace(x, y, z) { return [[x, y + 1, z], [x, y + 1, z + 1], [x + 1, y + 1, z + 1], [x + 1, y + 1, z]]; }
            function getBottomFace(x, y, z) { return [[x, y, z + 1], [x, y, z], [x + 1, y, z], [x + 1, y, z + 1]]; }
            function getRightFace(x, y, z) { return [[x + 1, y, z + 1], [x + 1, y, z], [x + 1, y + 1, z], [x + 1, y + 1, z + 1]]; }
            function getLeftFace(x, y, z) { return [[x, y, z], [x, y, z + 1], [x, y + 1, z + 1], [x, y + 1, z]]; }
            function getFrontFace(x, y, z) { return [[x, y, z + 1], [x + 1, y, z + 1], [x + 1, y + 1, z + 1], [x, y + 1, z + 1]]; }
            function getBackFace(x, y, z) { return [[x + 1, y, z], [x, y, z], [x, y + 1, z], [x + 1, y + 1, z]]; }
            function buildChunkMesh(cx, cz, chunkData, neighborChunks) {
                chunkCache.clear();
                for (const [key, data] of Object.entries(neighborChunks)) { if (data) chunkCache.set(key, new Uint8Array(data)); }
                const chunk = new Uint8Array(chunkData);
                const geometryData = {};
                for (let lx = 0; lx < CONFIG.CHUNK_SIZE; lx++) {
                    for (let y = 0; y < CONFIG.WORLD_HEIGHT; y++) {
                        for (let lz = 0; lz < CONFIG.CHUNK_SIZE; lz++) {
                            const worldX = cx * CONFIG.CHUNK_SIZE + lx;
                            const worldZ = cz * CONFIG.CHUNK_SIZE + lz;
                            const block = chunk[getLocalIndex(lx, y, lz)];
                            if (block === BLOCKS.AIR) continue;
                            const blockData = BLOCK_DATA[block];
                            if (!blockData) continue;
                            const faces = [
                                { dir: [0, 1, 0], verts: getTopFace(worldX, y, worldZ), face: 'top' },
                                { dir: [0, -1, 0], verts: getBottomFace(worldX, y, worldZ), face: 'bottom' },
                                { dir: [1, 0, 0], verts: getRightFace(worldX, y, worldZ), face: 'side' },
                                { dir: [-1, 0, 0], verts: getLeftFace(worldX, y, worldZ), face: 'side' },
                                { dir: [0, 0, 1], verts: getFrontFace(worldX, y, worldZ), face: 'side' },
                                { dir: [0, 0, -1], verts: getBackFace(worldX, y, worldZ), face: 'side' }
                            ];
                            for (const faceData of faces) {
                                const nx = worldX + faceData.dir[0], ny = y + faceData.dir[1], nz = worldZ + faceData.dir[2];
                                const neighbor = getBlockFromChunks(nx, ny, nz, chunk, cx, cz);
                                const neighborData = BLOCK_DATA[neighbor];
                                const neighborTransparent = neighbor === BLOCKS.AIR || (neighborData && neighborData.transparent);
                                if (!neighborTransparent) continue;
                                if (blockData.transparent && neighbor === block) continue;
                                const matKey = block + '_' + faceData.face;
                                if (!geometryData[matKey]) { geometryData[matKey] = { positions: [], normals: [], indices: [], block: block, face: faceData.face }; }
                                const geom = geometryData[matKey];
                                const baseIndex = geom.positions.length / 3;
                                for (const v of faceData.verts) { geom.positions.push(v[0], v[1], v[2]); geom.normals.push(faceData.dir[0], faceData.dir[1], faceData.dir[2]); }
                                geom.indices.push(baseIndex, baseIndex + 1, baseIndex + 2, baseIndex, baseIndex + 2, baseIndex + 3);
                            }
                        }
                    }
                }
                const result = {}, transfers = [];
                for (const [key, data] of Object.entries(geometryData)) {
                    if (data.positions.length === 0) continue;
                    const positions = new Float32Array(data.positions), normals = new Float32Array(data.normals), indices = new Uint32Array(data.indices);
                    result[key] = { positions: positions.buffer, normals: normals.buffer, indices: indices.buffer, block: data.block, face: data.face };
                    transfers.push(positions.buffer, normals.buffer, indices.buffer);
                }
                return { result, transfers };
            }
            self.onmessage = function(e) {
                const { type, cx, cz, chunkData, neighborChunks, taskId } = e.data;
                if (type === 'buildMesh') {
                    const { result, transfers } = buildChunkMesh(cx, cz, chunkData, neighborChunks);
                    self.postMessage({ type: 'meshBuilt', cx, cz, geometryData: result, taskId }, transfers);
                }
            };
        `;

        // ============================================
        // WORKER POOL
        // ============================================
        class WorkerPool {
            constructor(numWorkers) {
                this.workers = []; this.taskQueue = []; this.pendingTasks = new Map();
                this.taskId = 0; this.availableWorkers = [];
                const blob = new Blob([workerCode], { type: 'application/javascript' });
                const workerUrl = URL.createObjectURL(blob);
                for (let i = 0; i < numWorkers; i++) {
                    const worker = new Worker(workerUrl);
                    worker.onmessage = (e) => this.handleMessage(e, i);
                    this.workers.push(worker); this.availableWorkers.push(i);
                }
            }
            handleMessage(e, workerIndex) {
                const { type, cx, cz, geometryData, taskId } = e.data;
                if (type === 'meshBuilt') {
                    const callback = this.pendingTasks.get(taskId);
                    if (callback) { callback(cx, cz, geometryData); this.pendingTasks.delete(taskId); }
                }
                this.availableWorkers.push(workerIndex); this.processQueue();
            }
            buildMesh(cx, cz, chunkData, neighborChunks, callback) {
                const taskId = this.taskId++;
                this.pendingTasks.set(taskId, callback);
                this.taskQueue.push({ type: 'buildMesh', cx, cz, chunkData, neighborChunks, taskId });
                this.processQueue();
            }
            processQueue() {
                while (this.taskQueue.length > 0 && this.availableWorkers.length > 0) {
                    const task = this.taskQueue.shift();
                    const workerIndex = this.availableWorkers.shift();
                    const transfers = [task.chunkData];
                    for (const key in task.neighborChunks) { if (task.neighborChunks[key]) transfers.push(task.neighborChunks[key]); }
                    this.workers[workerIndex].postMessage(task, transfers);
                }
            }
            cancelChunk(cx, cz) { this.taskQueue = this.taskQueue.filter(t => !(t.cx === cx && t.cz === cz)); }
        }

        // ============================================
        // SIMPLEX NOISE
        // ============================================
        class SimplexNoise {
            constructor(seed = Math.random() * 10000) {
                this.p = new Uint8Array(256);
                for (let i = 0; i < 256; i++) this.p[i] = i;
                for (let i = 255; i > 0; i--) { seed = (seed * 16807) % 2147483647; const j = Math.floor((seed / 2147483647) * (i + 1)); [this.p[i], this.p[j]] = [this.p[j], this.p[i]]; }
                this.perm = new Uint8Array(512); this.permMod12 = new Uint8Array(512);
                for (let i = 0; i < 512; i++) { this.perm[i] = this.p[i & 255]; this.permMod12[i] = this.perm[i] % 12; }
            }
            noise2D(x, y) {
                const F2 = 0.5 * (Math.sqrt(3) - 1), G2 = (3 - Math.sqrt(3)) / 6;
                const s = (x + y) * F2, i = Math.floor(x + s), j = Math.floor(y + s);
                const t = (i + j) * G2, x0 = x - (i - t), y0 = y - (j - t);
                const i1 = x0 > y0 ? 1 : 0, j1 = x0 > y0 ? 0 : 1;
                const x1 = x0 - i1 + G2, y1 = y0 - j1 + G2, x2 = x0 - 1 + 2 * G2, y2 = y0 - 1 + 2 * G2;
                const ii = i & 255, jj = j & 255;
                const grad = [[1,1],[-1,1],[1,-1],[-1,-1],[1,0],[-1,0],[0,1],[0,-1],[1,1],[-1,1],[1,-1],[-1,-1]];
                const gi0 = this.permMod12[ii + this.perm[jj]], gi1 = this.permMod12[ii + i1 + this.perm[jj + j1]], gi2 = this.permMod12[ii + 1 + this.perm[jj + 1]];
                const dot = (g, x, y) => g[0] * x + g[1] * y;
                let n0 = 0, n1 = 0, n2 = 0;
                let t0 = 0.5 - x0*x0 - y0*y0; if (t0 >= 0) { t0 *= t0; n0 = t0 * t0 * dot(grad[gi0], x0, y0); }
                let t1 = 0.5 - x1*x1 - y1*y1; if (t1 >= 0) { t1 *= t1; n1 = t1 * t1 * dot(grad[gi1], x1, y1); }
                let t2 = 0.5 - x2*x2 - y2*y2; if (t2 >= 0) { t2 *= t2; n2 = t2 * t2 * dot(grad[gi2], x2, y2); }
                return 70 * (n0 + n1 + n2);
            }
            octave2D(x, y, octaves, persistence = 0.5) {
                let total = 0, frequency = 1, amplitude = 1, maxValue = 0;
                for (let i = 0; i < octaves; i++) { total += this.noise2D(x * frequency, y * frequency) * amplitude; maxValue += amplitude; amplitude *= persistence; frequency *= 2; }
                return total / maxValue;
            }
        }

        // ============================================
        // WORLD
        // ============================================
        class World {
            constructor(seed = 12345) {
                this.seed = seed;
                this.chunks = new Map(); this.noise = new SimplexNoise(seed);
                this.noise2 = new SimplexNoise(seed * 2); this.modifiedBlocks = new Map();
                this.caveNoise = new SimplexNoise(seed * 3);
                this.oreNoise = new SimplexNoise(seed * 4);
                this.biomeNoise = new SimplexNoise(seed * 5);
                this.temperatureNoise = new SimplexNoise(seed * 6);
            }
            getChunkKey(cx, cz) { return `${cx},${cz}`; }
            getBlockKey(x, y, z) { return `${x},${y},${z}`; }
            getLocalIndex(lx, y, lz) { return lx + lz * CONFIG.CHUNK_SIZE + y * CONFIG.CHUNK_SIZE * CONFIG.CHUNK_SIZE; }

            getBiome(worldX, worldZ) {
                const temp = this.temperatureNoise.octave2D(worldX * 0.002, worldZ * 0.002, 3, 0.5);
                const moisture = this.biomeNoise.octave2D(worldX * 0.003, worldZ * 0.003, 3, 0.5);
                if (temp < -0.3) return BIOMES.SNOW;
                if (temp > 0.4 && moisture < -0.2) return BIOMES.DESERT;
                if (moisture > 0.3) return BIOMES.FOREST;
                if (moisture < -0.5) return BIOMES.OCEAN;
                return BIOMES.PLAINS;
            }

            generateChunk(cx, cz) {
                const key = this.getChunkKey(cx, cz);
                if (this.chunks.has(key)) return this.chunks.get(key);
                const chunk = new Uint8Array(CONFIG.CHUNK_SIZE * CONFIG.WORLD_HEIGHT * CONFIG.CHUNK_SIZE);
                for (let lx = 0; lx < CONFIG.CHUNK_SIZE; lx++) {
                    for (let lz = 0; lz < CONFIG.CHUNK_SIZE; lz++) {
                        const worldX = cx * CONFIG.CHUNK_SIZE + lx, worldZ = cz * CONFIG.CHUNK_SIZE + lz;
                        const biome = this.getBiome(worldX, worldZ);

                        let baseHeight = 40;
                        let mountainScale = 30, hillScale = 10;
                        if (biome === BIOMES.OCEAN) { baseHeight = 30; mountainScale = 5; hillScale = 3; }
                        else if (biome === BIOMES.DESERT) { baseHeight = 42; mountainScale = 15; hillScale = 8; }
                        else if (biome === BIOMES.SNOW) { baseHeight = 45; mountainScale = 40; hillScale = 15; }

                        const mountainHeight = this.noise.octave2D(worldX * 0.005, worldZ * 0.005, 4, 0.5) * mountainScale;
                        const hillHeight = this.noise.octave2D(worldX * 0.02, worldZ * 0.02, 3, 0.5) * hillScale;
                        const detailHeight = this.noise.noise2D(worldX * 0.1, worldZ * 0.1) * 3;
                        const height = Math.floor(baseHeight + mountainHeight + hillHeight + detailHeight);
                        const stoneHeight = height - 3 - Math.floor(Math.abs(this.noise.noise2D(worldX * 0.3, worldZ * 0.3)) * 2);
                        const waterLevel = 35;

                        for (let y = 0; y < CONFIG.WORLD_HEIGHT; y++) {
                            const idx = this.getLocalIndex(lx, y, lz);
                            if (y === 0) { chunk[idx] = BLOCKS.BEDROCK; continue; }

                            // Cave generation
                            if (y > 1 && y < height - 5) {
                                const cave = this.caveNoise.octave2D(worldX * 0.05 + y * 0.1, worldZ * 0.05, 2, 0.5);
                                const cave2 = this.caveNoise.octave2D(worldX * 0.03, worldZ * 0.03 + y * 0.05, 2, 0.5);
                                if (cave > CONFIG.CAVE_THRESHOLD && cave2 > 0.3) {
                                    chunk[idx] = y < 10 ? BLOCKS.LAVA : BLOCKS.AIR;
                                    continue;
                                }
                            }

                            if (y < stoneHeight) {
                                // Ore generation
                                let block = BLOCKS.STONE;
                                const oreVal = this.oreNoise.noise2D(worldX * 0.1 + y * 0.2, worldZ * 0.1);
                                const oreVal2 = this.oreNoise.noise2D(worldX * 0.15, worldZ * 0.15 + y * 0.15);
                                if (y < 16 && oreVal > 0.7 && oreVal2 > 0.5) block = BLOCKS.DIAMOND_ORE;
                                else if (y < 32 && oreVal > 0.65 && oreVal2 > 0.4) block = BLOCKS.GOLD_ORE;
                                else if (y < 64 && oreVal > 0.55 && oreVal2 > 0.3) block = BLOCKS.IRON_ORE;
                                else if (oreVal > 0.5 && oreVal2 > 0.2) block = BLOCKS.COAL_ORE;
                                else if (oreVal < -0.6) block = BLOCKS.GRAVEL;
                                chunk[idx] = block;
                            } else if (y < height - 1) {
                                chunk[idx] = biome === BIOMES.DESERT ? BLOCKS.SAND : BLOCKS.DIRT;
                            } else if (y === height - 1 || (y < waterLevel && height <= waterLevel)) {
                                if (biome === BIOMES.DESERT) chunk[idx] = BLOCKS.SAND;
                                else if (biome === BIOMES.SNOW) chunk[idx] = BLOCKS.SNOW_GRASS;
                                else if (biome === BIOMES.OCEAN && y < waterLevel) chunk[idx] = BLOCKS.SAND;
                                else chunk[idx] = BLOCKS.GRASS;
                            } else if (y < waterLevel && height < waterLevel) {
                                chunk[idx] = BLOCKS.WATER;
                            } else {
                                chunk[idx] = BLOCKS.AIR;
                            }
                        }

                        // Fill water for ocean biome
                        if (height < waterLevel) {
                            for (let y = height; y < waterLevel; y++) {
                                const idx = this.getLocalIndex(lx, y, lz);
                                if (chunk[idx] === BLOCKS.AIR) chunk[idx] = BLOCKS.WATER;
                            }
                        }
                    }
                }
                // Trees and vegetation
                for (let lx = 0; lx < CONFIG.CHUNK_SIZE; lx++) {
                    for (let lz = 0; lz < CONFIG.CHUNK_SIZE; lz++) {
                        const worldX = cx * CONFIG.CHUNK_SIZE + lx, worldZ = cz * CONFIG.CHUNK_SIZE + lz;
                        const biome = this.getBiome(worldX, worldZ);
                        let surfaceY = -1;
                        const surfaceBlock = biome === BIOMES.SNOW ? BLOCKS.SNOW_GRASS : (biome === BIOMES.DESERT ? BLOCKS.SAND : BLOCKS.GRASS);
                        for (let y = CONFIG.WORLD_HEIGHT - 1; y >= 0; y--) {
                            const b = chunk[this.getLocalIndex(lx, y, lz)];
                            if (b === surfaceBlock || b === BLOCKS.GRASS || b === BLOCKS.SNOW_GRASS) { surfaceY = y; break; }
                        }
                        if (surfaceY > 30 && surfaceY < CONFIG.WORLD_HEIGHT - 10 && biome !== BIOMES.OCEAN) {
                            const treeNoise = this.noise2.noise2D(worldX * 0.5, worldZ * 0.5);
                            const treeThreshold = biome === BIOMES.FOREST ? 0.5 : (biome === BIOMES.DESERT ? 0.85 : 0.7);
                            if (treeNoise > treeThreshold && lx >= 2 && lx < CONFIG.CHUNK_SIZE - 2 && lz >= 2 && lz < CONFIG.CHUNK_SIZE - 2) {
                                if (biome === BIOMES.DESERT) {
                                    this.generateCactusInChunk(chunk, lx, surfaceY + 1, lz);
                                } else {
                                    this.generateTreeInChunk(chunk, lx, surfaceY + 1, lz, biome === BIOMES.SNOW);
                                }
                            }
                        }
                    }
                }
                this.chunks.set(key, chunk); return chunk;
            }

            generateCactusInChunk(chunk, x, y, z) {
                const height = 2 + Math.floor(Math.random() * 3);
                for (let dy = 0; dy < height; dy++) {
                    if (y + dy < CONFIG.WORLD_HEIGHT) chunk[this.getLocalIndex(x, y + dy, z)] = BLOCKS.CACTUS;
                }
            }
            generateTreeInChunk(chunk, x, y, z, isSnowy = false) {
                const treeHeight = 5 + Math.floor(Math.random() * 2);
                for (let dy = 0; dy < treeHeight; dy++) { if (y + dy < CONFIG.WORLD_HEIGHT) chunk[this.getLocalIndex(x, y + dy, z)] = BLOCKS.WOOD; }
                for (let dy = treeHeight - 3; dy <= treeHeight + 1; dy++) {
                    const radius = dy < treeHeight ? 2 : 1;
                    for (let dx = -radius; dx <= radius; dx++) {
                        for (let dz = -radius; dz <= radius; dz++) {
                            if (dx === 0 && dz === 0 && dy < treeHeight) continue;
                            if (Math.abs(dx) === 2 && Math.abs(dz) === 2) continue;
                            const lx = x + dx, ly = y + dy, lz = z + dz;
                            if (lx >= 0 && lx < CONFIG.CHUNK_SIZE && lz >= 0 && lz < CONFIG.CHUNK_SIZE && ly >= 0 && ly < CONFIG.WORLD_HEIGHT) {
                                const idx = this.getLocalIndex(lx, ly, lz);
                                if (chunk[idx] === BLOCKS.AIR) chunk[idx] = BLOCKS.LEAVES;
                            }
                        }
                    }
                }
                // Add snow on top of leaves in snowy biome
                if (isSnowy) {
                    for (let dx = -2; dx <= 2; dx++) {
                        for (let dz = -2; dz <= 2; dz++) {
                            const lx = x + dx, lz = z + dz;
                            if (lx >= 0 && lx < CONFIG.CHUNK_SIZE && lz >= 0 && lz < CONFIG.CHUNK_SIZE) {
                                for (let dy = treeHeight + 2; dy >= treeHeight - 2; dy--) {
                                    const ly = y + dy;
                                    if (ly >= 0 && ly < CONFIG.WORLD_HEIGHT - 1) {
                                        const idx = this.getLocalIndex(lx, ly, lz);
                                        const idxAbove = this.getLocalIndex(lx, ly + 1, lz);
                                        if (chunk[idx] === BLOCKS.LEAVES && chunk[idxAbove] === BLOCKS.AIR) {
                                            chunk[idxAbove] = BLOCKS.SNOW;
                                            break;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            getBlock(x, y, z) {
                x = Math.floor(x); y = Math.floor(y); z = Math.floor(z);
                const blockKey = this.getBlockKey(x, y, z);
                if (this.modifiedBlocks.has(blockKey)) return this.modifiedBlocks.get(blockKey);
                if (y < 0 || y >= CONFIG.WORLD_HEIGHT) return BLOCKS.AIR;
                const cx = Math.floor(x / CONFIG.CHUNK_SIZE), cz = Math.floor(z / CONFIG.CHUNK_SIZE);
                const chunk = this.chunks.get(this.getChunkKey(cx, cz));
                if (!chunk) return BLOCKS.AIR;
                const lx = ((x % CONFIG.CHUNK_SIZE) + CONFIG.CHUNK_SIZE) % CONFIG.CHUNK_SIZE;
                const lz = ((z % CONFIG.CHUNK_SIZE) + CONFIG.CHUNK_SIZE) % CONFIG.CHUNK_SIZE;
                return chunk[this.getLocalIndex(lx, y, lz)];
            }
            setBlock(x, y, z, type) {
                x = Math.floor(x); y = Math.floor(y); z = Math.floor(z);
                if (y < 0 || y >= CONFIG.WORLD_HEIGHT) return;
                this.modifiedBlocks.set(this.getBlockKey(x, y, z), type);
                const cx = Math.floor(x / CONFIG.CHUNK_SIZE), cz = Math.floor(z / CONFIG.CHUNK_SIZE);
                const chunk = this.chunks.get(this.getChunkKey(cx, cz));
                if (chunk) {
                    const lx = ((x % CONFIG.CHUNK_SIZE) + CONFIG.CHUNK_SIZE) % CONFIG.CHUNK_SIZE;
                    const lz = ((z % CONFIG.CHUNK_SIZE) + CONFIG.CHUNK_SIZE) % CONFIG.CHUNK_SIZE;
                    chunk[this.getLocalIndex(lx, y, lz)] = type;
                }
            }
            isSolid(x, y, z) { const block = this.getBlock(x, y, z); if (block === BLOCKS.AIR) return false; const data = BLOCK_DATA[block]; return data ? data.solid : false; }
            getChunkDataCopy(cx, cz) { const chunk = this.chunks.get(this.getChunkKey(cx, cz)); return chunk ? chunk.buffer.slice(0) : null; }
        }

        // ============================================
        // MESH BUILDER
        // ============================================
        class MeshBuilder {
            constructor(scene, world) {
                this.scene = scene; this.world = world; this.chunkMeshes = new Map();
                this.pendingChunks = new Set();
                this.textureGen = new TextureGenerator(64);
                this.waterTime = 0;
                this.waterMaterials = [];
                this.materials = this.createMaterials();
                this.workerPool = new WorkerPool(CONFIG.WORKER_COUNT);
            }
            createMaterials() {
                const materials = {};
                for (const [blockType, data] of Object.entries(BLOCK_DATA)) {
                    materials[blockType] = {};
                    for (const face of ['top', 'side', 'bottom']) {
                        // Get canvas texture if available
                        const canvas = this.textureGen.getTexture(parseInt(blockType), face);
                        let mat;
                        if (canvas) {
                            const texture = new THREE.CanvasTexture(canvas);
                            texture.magFilter = THREE.NearestFilter;
                            texture.minFilter = THREE.NearestFilter;
                            texture.wrapS = THREE.RepeatWrapping;
                            texture.wrapT = THREE.RepeatWrapping;
                            mat = new THREE.MeshLambertMaterial({ map: texture, side: THREE.FrontSide });
                        } else {
                            mat = new THREE.MeshLambertMaterial({ color: data.colors[face], side: THREE.FrontSide });
                        }
                        if (data.transparent) {
                            mat.transparent = true;
                            mat.opacity = data.opacity || 0.8;
                            mat.depthWrite = false;
                        }
                        if (data.emissive) {
                            mat.emissive = new THREE.Color(data.colors[face]);
                            mat.emissiveIntensity = 0.3;
                        }
                        materials[blockType][face] = mat;
                        // Track water materials for animation
                        if (parseInt(blockType) === BLOCKS.WATER) {
                            this.waterMaterials.push(mat);
                        }
                    }
                }
                return materials;
            }
            updateWater(deltaTime) {
                this.waterTime += deltaTime;
                // Animate water texture offset for flowing effect
                for (const mat of this.waterMaterials) {
                    if (mat.map) {
                        mat.map.offset.x = Math.sin(this.waterTime * 0.5) * 0.1;
                        mat.map.offset.y = this.waterTime * 0.1 % 1;
                    }
                }
            }
            buildChunkMeshAsync(cx, cz) {
                const key = `${cx},${cz}`;
                if (this.pendingChunks.has(key)) return;
                this.pendingChunks.add(key);
                this.world.generateChunk(cx, cz);
                this.world.generateChunk(cx - 1, cz); this.world.generateChunk(cx + 1, cz);
                this.world.generateChunk(cx, cz - 1); this.world.generateChunk(cx, cz + 1);
                const chunkData = this.world.getChunkDataCopy(cx, cz);
                const neighborChunks = {
                    [`${cx-1},${cz}`]: this.world.getChunkDataCopy(cx - 1, cz),
                    [`${cx+1},${cz}`]: this.world.getChunkDataCopy(cx + 1, cz),
                    [`${cx},${cz-1}`]: this.world.getChunkDataCopy(cx, cz - 1),
                    [`${cx},${cz+1}`]: this.world.getChunkDataCopy(cx, cz + 1)
                };
                this.workerPool.buildMesh(cx, cz, chunkData, neighborChunks, (rcx, rcz, geometryData) => this.onMeshBuilt(rcx, rcz, geometryData));
            }
            onMeshBuilt(cx, cz, geometryData) {
                const key = `${cx},${cz}`;
                this.pendingChunks.delete(key);
                if (this.chunkMeshes.has(key)) {
                    const oldGroup = this.chunkMeshes.get(key);
                    this.scene.remove(oldGroup);
                    oldGroup.traverse(c => { if (c.geometry) c.geometry.dispose(); });
                }
                const group = new THREE.Group();
                for (const [matKey, data] of Object.entries(geometryData)) {
                    const geometry = new THREE.BufferGeometry();
                    geometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(data.positions), 3));
                    geometry.setAttribute('normal', new THREE.BufferAttribute(new Float32Array(data.normals), 3));
                    geometry.setIndex(new THREE.BufferAttribute(new Uint32Array(data.indices), 1));
                    geometry.computeBoundingSphere();
                    const material = this.materials[data.block]?.[data.face];
                    if (material) {
                        const mesh = new THREE.Mesh(geometry, material);
                        mesh.frustumCulled = false; // We cull at group level
                        group.add(mesh);
                    }
                }
                this.scene.add(group); this.chunkMeshes.set(key, group);
            }
            rebuildChunksNear(x, y, z) {
                const cx = Math.floor(x / CONFIG.CHUNK_SIZE), cz = Math.floor(z / CONFIG.CHUNK_SIZE);
                const rebuildList = [[cx, cz]];
                const lx = ((Math.floor(x) % CONFIG.CHUNK_SIZE) + CONFIG.CHUNK_SIZE) % CONFIG.CHUNK_SIZE;
                const lz = ((Math.floor(z) % CONFIG.CHUNK_SIZE) + CONFIG.CHUNK_SIZE) % CONFIG.CHUNK_SIZE;
                if (lx === 0) rebuildList.push([cx - 1, cz]);
                if (lx === CONFIG.CHUNK_SIZE - 1) rebuildList.push([cx + 1, cz]);
                if (lz === 0) rebuildList.push([cx, cz - 1]);
                if (lz === CONFIG.CHUNK_SIZE - 1) rebuildList.push([cx, cz + 1]);
                for (const [rcx, rcz] of rebuildList) {
                    this.pendingChunks.delete(`${rcx},${rcz}`);
                    this.workerPool.cancelChunk(rcx, rcz);
                    this.buildChunkMeshAsync(rcx, rcz);
                }
            }
            removeChunk(cx, cz) {
                const key = `${cx},${cz}`;
                this.workerPool.cancelChunk(cx, cz); this.pendingChunks.delete(key);
                if (this.chunkMeshes.has(key)) {
                    const mesh = this.chunkMeshes.get(key);
                    this.scene.remove(mesh);
                    mesh.traverse(c => { if (c.geometry) c.geometry.dispose(); });
                    this.chunkMeshes.delete(key);
                }
            }
        }

        // ============================================
        // PROJECTILE SYSTEM
        // ============================================
        class ProjectileSystem {
            constructor(scene, world, meshBuilder, audio) {
                this.scene = scene; this.world = world; this.meshBuilder = meshBuilder; this.audio = audio;
                this.projectiles = []; this.particles = []; this.beams = [];
                this.particleGeom = new THREE.BoxGeometry(0.2, 0.2, 0.2);
                this.lastExplosion = null;
                this.entityManager = null;
            }

            setEntityManager(entityManager) {
                this.entityManager = entityManager;
            }

            renderWeaponVisual(weaponKey, origin, dir) {
                // Visual-only effects for remote player weapons
                switch(weaponKey) {
                    case 'LASER_GUN': this.shootLaser(origin, dir, 100); break;
                    case 'RAILGUN': this.shootRailgun(origin, dir); break;
                    case 'MINIGUN': this.shootMinigun(origin, dir, 0.05); break;
                    case 'SHOTGUN':
                        for (let i = 0; i < 4; i++) {
                            const spread = new THREE.Vector3(dir.x + (Math.random()-0.5)*0.15, dir.y + (Math.random()-0.5)*0.15, dir.z + (Math.random()-0.5)*0.15).normalize();
                            this.shootMinigun(origin.clone(), spread, 0);
                        }
                        break;
                    case 'TNT_GUN': this.shootTNT(origin, dir, 60); break;
                    case 'ROCKET_LAUNCHER': this.shootRocket(origin, dir, 50); break;
                    case 'PLASMA_CANNON': this.shootPlasma(origin, dir, 70); break;
                    case 'FLAMETHROWER': this.shootFlame(origin, dir); break;
                    case 'LIGHTNING_STAFF': this.shootLightning(origin, dir, 30); break;
                    case 'BFG': this.shootBFG(origin, dir, 30); break;
                    case 'NUKE_LAUNCHER': this.shootNuke(origin, dir, 40); break;
                    case 'FREEZE_RAY': this.shootFreezeRay(origin, dir); break;
                    case 'BOW': this.shootBow(origin, dir, 50); break;
                    case 'GRENADE': this.shootGrenade(origin, dir, 30); break;
                    case 'SWORD': this.shootSword(origin, dir); break;
                    case 'CHAINSAW': this.shootChainsaw(origin, dir); break;
                    case 'GRAVITY_GUN': this.shootGravityWave(origin, dir); break;
                    case 'BLACK_HOLE': this.shootBlackHole(origin, dir, 20); break;
                    case 'CLUSTER_BOMB': this.shootCluster(origin, dir, 40, 6); break;
                }
            }

            shootTNT(position, direction, speed = 60) {
                const group = new THREE.Group();
                const bodyGeom = new THREE.BoxGeometry(0.3, 0.4, 0.3);
                const bodyMat = new THREE.MeshLambertMaterial({ color: 0xff2200, emissive: 0x440000 });
                group.add(new THREE.Mesh(bodyGeom, bodyMat));
                const stripeGeom = new THREE.BoxGeometry(0.31, 0.1, 0.31);
                const stripeMat = new THREE.MeshLambertMaterial({ color: 0xffffff });
                const stripe = new THREE.Mesh(stripeGeom, stripeMat); stripe.position.y = 0.12;
                group.add(stripe);
                group.position.copy(position);
                this.scene.add(group);
                this.projectiles.push({ mesh: group, velocity: direction.clone().multiplyScalar(speed), gravity: -25, life: 5, type: 'tnt' });
                this.audio.play('shoot_tnt');
            }

            shootLaser(origin, direction, range = 100) {
                this.audio.play('shoot_laser');
                const raycaster = new THREE.Raycaster(origin, direction, 0, range);
                let hitDist = range;

                // Check block collision
                for (let t = 0; t < range; t += 0.5) {
                    const pos = origin.clone().add(direction.clone().multiplyScalar(t));
                    const block = this.world.getBlock(pos.x, pos.y, pos.z);
                    if (block !== BLOCKS.AIR && block !== BLOCKS.WATER) {
                        hitDist = t;
                        const bx = Math.floor(pos.x), by = Math.floor(pos.y), bz = Math.floor(pos.z);
                        if (block !== BLOCKS.BEDROCK) {
                            this.world.setBlock(bx, by, bz, BLOCKS.AIR);
                            this.meshBuilder.rebuildChunksNear(bx, by, bz);
                            this.audio.play('hit');
                            for (let i = 0; i < 5; i++) this.spawnParticle(bx + 0.5, by + 0.5, bz + 0.5, BLOCK_DATA[block]?.colors?.top || 0x888888);
                        }
                        break;
                    }
                }

                // Create beam visual
                const beamGeom = new THREE.CylinderGeometry(0.03, 0.03, hitDist, 8);
                beamGeom.rotateX(Math.PI / 2);
                const beamMat = new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.8 });
                const beam = new THREE.Mesh(beamGeom, beamMat);
                beam.position.copy(origin).add(direction.clone().multiplyScalar(hitDist / 2));
                beam.lookAt(origin.clone().add(direction));
                this.scene.add(beam);
                this.beams.push({ mesh: beam, life: 0.1 });

                // Impact glow
                const glowGeom = new THREE.SphereGeometry(0.2, 8, 8);
                const glowMat = new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.9 });
                const glow = new THREE.Mesh(glowGeom, glowMat);
                glow.position.copy(origin).add(direction.clone().multiplyScalar(hitDist));
                this.scene.add(glow);
                this.beams.push({ mesh: glow, life: 0.15 });
            }

            shootRailgun(origin, direction) {
                this.audio.play('shoot_railgun');
                const range = 150;
                let penetration = 10;
                const hitPositions = [];

                for (let t = 0; t < range && penetration > 0; t += 0.3) {
                    const pos = origin.clone().add(direction.clone().multiplyScalar(t));
                    const block = this.world.getBlock(pos.x, pos.y, pos.z);
                    if (block !== BLOCKS.AIR && block !== BLOCKS.WATER && block !== BLOCKS.BEDROCK) {
                        const bx = Math.floor(pos.x), by = Math.floor(pos.y), bz = Math.floor(pos.z);
                        this.world.setBlock(bx, by, bz, BLOCKS.AIR);
                        hitPositions.push({ x: bx, y: by, z: bz });
                        penetration--;
                    }
                }

                // Rebuild chunks
                const chunksToRebuild = new Set();
                for (const pos of hitPositions) {
                    chunksToRebuild.add(`${Math.floor(pos.x / CONFIG.CHUNK_SIZE)},${Math.floor(pos.z / CONFIG.CHUNK_SIZE)}`);
                }
                for (const key of chunksToRebuild) {
                    const [cx, cz] = key.split(',').map(Number);
                    this.meshBuilder.rebuildChunksNear(cx * CONFIG.CHUNK_SIZE, 0, cz * CONFIG.CHUNK_SIZE);
                }

                // Create beam visual
                const beamGeom = new THREE.CylinderGeometry(0.08, 0.02, range, 8);
                beamGeom.rotateX(Math.PI / 2);
                const beamMat = new THREE.MeshBasicMaterial({ color: 0xff00ff, transparent: true, opacity: 0.9 });
                const beam = new THREE.Mesh(beamGeom, beamMat);
                beam.position.copy(origin).add(direction.clone().multiplyScalar(range / 2));
                beam.lookAt(origin.clone().add(direction));
                this.scene.add(beam);
                this.beams.push({ mesh: beam, life: 0.3, expand: true });

                // Explosion at end
                const endPos = origin.clone().add(direction.clone().multiplyScalar(range));
                this.explode(endPos.x, endPos.y, endPos.z, 6);
            }

            shootMinigun(origin, direction, spread = 0.05) {
                this.audio.play('shoot_minigun');
                const spreadDir = direction.clone();
                spreadDir.x += (Math.random() - 0.5) * spread;
                spreadDir.y += (Math.random() - 0.5) * spread;
                spreadDir.z += (Math.random() - 0.5) * spread;
                spreadDir.normalize();

                for (let t = 0; t < 80; t += 0.5) {
                    const pos = origin.clone().add(spreadDir.clone().multiplyScalar(t));
                    const block = this.world.getBlock(pos.x, pos.y, pos.z);
                    if (block !== BLOCKS.AIR && block !== BLOCKS.WATER) {
                        const bx = Math.floor(pos.x), by = Math.floor(pos.y), bz = Math.floor(pos.z);
                        if (block !== BLOCKS.BEDROCK) {
                            this.world.setBlock(bx, by, bz, BLOCKS.AIR);
                            this.meshBuilder.rebuildChunksNear(bx, by, bz);
                            for (let i = 0; i < 3; i++) this.spawnParticle(bx + 0.5, by + 0.5, bz + 0.5, 0xffaa00);
                        }
                        break;
                    }
                }

                // Tracer
                const tracerGeom = new THREE.CylinderGeometry(0.015, 0.015, 3, 4);
                tracerGeom.rotateX(Math.PI / 2);
                const tracerMat = new THREE.MeshBasicMaterial({ color: 0xffff00 });
                const tracer = new THREE.Mesh(tracerGeom, tracerMat);
                tracer.position.copy(origin).add(spreadDir.clone().multiplyScalar(1.5));
                tracer.lookAt(origin.clone().add(spreadDir));
                this.scene.add(tracer);
                this.beams.push({ mesh: tracer, life: 0.05, velocity: spreadDir.clone().multiplyScalar(200) });
            }

            shootFreezeRay(origin, direction) {
                this.audio.play('freeze');
                const range = 30;

                for (let t = 0; t < range; t += 0.5) {
                    const pos = origin.clone().add(direction.clone().multiplyScalar(t));
                    const block = this.world.getBlock(pos.x, pos.y, pos.z);
                    if (block !== BLOCKS.AIR && block !== BLOCKS.BEDROCK) {
                        const bx = Math.floor(pos.x), by = Math.floor(pos.y), bz = Math.floor(pos.z);
                        if (block === BLOCKS.WATER) {
                            this.world.setBlock(bx, by, bz, BLOCKS.ICE);
                        } else {
                            // Create ice around hit point
                            for (let dx = -1; dx <= 1; dx++) {
                                for (let dy = -1; dy <= 1; dy++) {
                                    for (let dz = -1; dz <= 1; dz++) {
                                        if (Math.random() < 0.3 && this.world.getBlock(bx+dx, by+dy, bz+dz) === BLOCKS.AIR) {
                                            this.world.setBlock(bx+dx, by+dy, bz+dz, BLOCKS.ICE);
                                        }
                                    }
                                }
                            }
                        }
                        this.meshBuilder.rebuildChunksNear(bx, by, bz);
                        for (let i = 0; i < 10; i++) this.spawnParticle(bx + 0.5, by + 0.5, bz + 0.5, 0xaaddff, false, true);
                        break;
                    }
                }

                // Create beam visual
                const beamGeom = new THREE.CylinderGeometry(0.1, 0.05, range, 8);
                beamGeom.rotateX(Math.PI / 2);
                const beamMat = new THREE.MeshBasicMaterial({ color: 0xaaddff, transparent: true, opacity: 0.6 });
                const beam = new THREE.Mesh(beamGeom, beamMat);
                beam.position.copy(origin).add(direction.clone().multiplyScalar(range / 2));
                beam.lookAt(origin.clone().add(direction));
                this.scene.add(beam);
                this.beams.push({ mesh: beam, life: 0.2 });
            }

            shootSword(origin, direction) {
                this.audio.play('sword');
                const range = 4;

                // Melee attack - destroy blocks in arc
                for (let t = 1; t < range; t += 0.5) {
                    const pos = origin.clone().add(direction.clone().multiplyScalar(t));
                    const block = this.world.getBlock(pos.x, pos.y, pos.z);
                    if (block !== BLOCKS.AIR && block !== BLOCKS.WATER && block !== BLOCKS.BEDROCK) {
                        const bx = Math.floor(pos.x), by = Math.floor(pos.y), bz = Math.floor(pos.z);
                        this.world.setBlock(bx, by, bz, BLOCKS.AIR);
                        this.meshBuilder.rebuildChunksNear(bx, by, bz);
                        this.audio.play('hit');
                        for (let i = 0; i < 8; i++) this.spawnParticle(bx + 0.5, by + 0.5, bz + 0.5, BLOCK_DATA[block]?.colors?.top || 0x888888);
                        break;
                    }
                }

                // Sword slash visual effect
                const slashGeom = new THREE.RingGeometry(0.3, 0.8, 8, 1, 0, Math.PI);
                const slashMat = new THREE.MeshBasicMaterial({ color: 0x55ffff, transparent: true, opacity: 0.7, side: THREE.DoubleSide });
                const slash = new THREE.Mesh(slashGeom, slashMat);
                slash.position.copy(origin).add(direction.clone().multiplyScalar(1.5));
                slash.lookAt(origin);
                slash.rotation.z = Math.random() * Math.PI;
                this.scene.add(slash);
                this.beams.push({ mesh: slash, life: 0.15, expand: true });
            }

            shootChainsaw(origin, direction) {
                this.audio.play('chainsaw');
                const range = 3;

                // Rip through blocks rapidly
                for (let t = 1; t < range; t += 0.3) {
                    const pos = origin.clone().add(direction.clone().multiplyScalar(t));
                    const block = this.world.getBlock(pos.x, pos.y, pos.z);
                    if (block !== BLOCKS.AIR && block !== BLOCKS.WATER && block !== BLOCKS.BEDROCK) {
                        const bx = Math.floor(pos.x), by = Math.floor(pos.y), bz = Math.floor(pos.z);
                        this.world.setBlock(bx, by, bz, BLOCKS.AIR);
                        this.meshBuilder.rebuildChunksNear(bx, by, bz);
                        // Spray particles
                        for (let i = 0; i < 12; i++) {
                            const color = BLOCK_DATA[block]?.colors?.top || 0x888888;
                            this.spawnParticle(bx + 0.5, by + 0.5, bz + 0.5, color);
                        }
                        break;
                    }
                }

                // Chainsaw sparks and gore
                for (let i = 0; i < 5; i++) {
                    const sparkPos = origin.clone().add(direction.clone().multiplyScalar(1 + Math.random()));
                    const sparkMat = new THREE.MeshBasicMaterial({ color: Math.random() > 0.5 ? 0xffaa00 : 0xff4400, transparent: true, opacity: 0.9 });
                    const spark = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.05, 0.05), sparkMat);
                    spark.position.copy(sparkPos);
                    this.scene.add(spark);
                    this.particles.push({
                        mesh: spark,
                        velocity: new THREE.Vector3((Math.random()-0.5)*8, Math.random()*5, (Math.random()-0.5)*8),
                        life: 0.2 + Math.random() * 0.1,
                        gravity: -10
                    });
                }
            }

            shootBow(origin, direction, speed = 50) {
                this.audio.play('bow');

                // Create arrow projectile
                const group = new THREE.Group();
                const shaftGeom = new THREE.CylinderGeometry(0.02, 0.02, 0.6, 4);
                shaftGeom.rotateX(Math.PI / 2);
                const shaftMat = new THREE.MeshLambertMaterial({ color: 0x8b4513 });
                group.add(new THREE.Mesh(shaftGeom, shaftMat));

                const headGeom = new THREE.ConeGeometry(0.05, 0.15, 4);
                headGeom.rotateX(-Math.PI / 2);
                const headMat = new THREE.MeshLambertMaterial({ color: 0x555555 });
                const head = new THREE.Mesh(headGeom, headMat);
                head.position.z = -0.35;
                group.add(head);

                group.position.copy(origin);
                group.lookAt(origin.clone().add(direction));
                this.scene.add(group);

                this.projectiles.push({
                    mesh: group,
                    velocity: direction.clone().multiplyScalar(speed),
                    gravity: -15,
                    life: 5,
                    type: 'arrow',
                    direction: direction.clone()
                });
            }

            shootGrenade(origin, direction, speed = 25) {
                this.audio.play('throw');

                const geom = new THREE.SphereGeometry(0.15, 8, 8);
                const mat = new THREE.MeshLambertMaterial({ color: 0x006600 });
                const grenade = new THREE.Mesh(geom, mat);
                grenade.position.copy(origin);
                this.scene.add(grenade);

                this.projectiles.push({
                    mesh: grenade,
                    velocity: direction.clone().multiplyScalar(speed),
                    gravity: -20,
                    life: 2.0,
                    type: 'grenade',
                    fuse: 2.0
                });
            }

            shootFireball(origin, target, speed = 15, damage = 3) {
                const direction = target.clone().sub(origin).normalize();

                // Create fiery projectile
                const group = new THREE.Group();
                const coreGeom = new THREE.SphereGeometry(0.2, 8, 8);
                const coreMat = new THREE.MeshBasicMaterial({ color: 0xff6600 });
                group.add(new THREE.Mesh(coreGeom, coreMat));

                const glowGeom = new THREE.SphereGeometry(0.3, 8, 8);
                const glowMat = new THREE.MeshBasicMaterial({ color: 0xffaa00, transparent: true, opacity: 0.4 });
                group.add(new THREE.Mesh(glowGeom, glowMat));

                group.position.copy(origin);
                this.scene.add(group);

                this.projectiles.push({
                    mesh: group,
                    velocity: direction.clone().multiplyScalar(speed),
                    gravity: -2,
                    life: 4.0,
                    type: 'fireball',
                    damage: damage
                });

                this.audio.play('shoot_tnt');
            }

            shootRocket(origin, direction, speed = 40) {
                this.audio.play('shoot_tnt');
                const group = new THREE.Group();
                const body = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.08, 0.5, 8), new THREE.MeshLambertMaterial({ color: 0x444444 }));
                body.rotation.x = Math.PI / 2;
                group.add(body);
                const nose = new THREE.Mesh(new THREE.ConeGeometry(0.08, 0.15, 8), new THREE.MeshLambertMaterial({ color: 0xff0000 }));
                nose.rotation.x = -Math.PI / 2;
                nose.position.z = -0.3;
                group.add(nose);
                // Fins
                for (let i = 0; i < 4; i++) {
                    const fin = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.02, 0.1), new THREE.MeshLambertMaterial({ color: 0x666666 }));
                    fin.position.z = 0.2;
                    fin.rotation.z = i * Math.PI / 2;
                    fin.position.x = Math.cos(i * Math.PI / 2) * 0.1;
                    fin.position.y = Math.sin(i * Math.PI / 2) * 0.1;
                    group.add(fin);
                }
                group.position.copy(origin);
                group.lookAt(origin.clone().add(direction));
                this.scene.add(group);
                this.projectiles.push({ mesh: group, velocity: direction.clone().multiplyScalar(speed), gravity: -5, life: 5, type: 'rocket' });
            }

            shootPlasma(origin, direction, speed = 80) {
                this.audio.play('shoot_laser');
                const group = new THREE.Group();
                const core = new THREE.Mesh(new THREE.SphereGeometry(0.15, 8, 8), new THREE.MeshBasicMaterial({ color: 0x00ff88 }));
                group.add(core);
                const glow = new THREE.Mesh(new THREE.SphereGeometry(0.25, 8, 8), new THREE.MeshBasicMaterial({ color: 0x00ffaa, transparent: true, opacity: 0.5 }));
                group.add(glow);
                group.position.copy(origin);
                this.scene.add(group);
                this.projectiles.push({ mesh: group, velocity: direction.clone().multiplyScalar(speed), gravity: 0, life: 3, type: 'plasma' });
            }

            shootFlame(origin, direction) {
                this.audio.play('freeze');
                for (let i = 0; i < 5; i++) {
                    const spread = direction.clone().add(new THREE.Vector3((Math.random() - 0.5) * 0.3, (Math.random() - 0.5) * 0.3, (Math.random() - 0.5) * 0.3));
                    const flameMat = new THREE.MeshBasicMaterial({ color: Math.random() > 0.5 ? 0xff6600 : 0xffaa00, transparent: true, opacity: 0.8 });
                    const flame = new THREE.Mesh(new THREE.SphereGeometry(0.1 + Math.random() * 0.1, 6, 6), flameMat);
                    flame.position.copy(origin).add(spread.clone().multiplyScalar(Math.random() * 2));
                    this.scene.add(flame);
                    this.particles.push({ mesh: flame, velocity: spread.clone().multiplyScalar(15 + Math.random() * 5), life: 0.3 + Math.random() * 0.2, gravity: 2 });
                }
            }

            shootLightning(origin, direction, range = 40) {
                this.audio.play('shoot_laser');
                // Create jagged lightning bolt
                const points = [origin.clone()];
                let current = origin.clone();
                const step = range / 10;
                for (let i = 0; i < 10; i++) {
                    current = current.clone().add(direction.clone().multiplyScalar(step));
                    current.x += (Math.random() - 0.5) * 1;
                    current.y += (Math.random() - 0.5) * 1;
                    current.z += (Math.random() - 0.5) * 1;
                    points.push(current.clone());
                }
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const material = new THREE.LineBasicMaterial({ color: 0xffff00, linewidth: 3 });
                const lightning = new THREE.Line(geometry, material);
                this.scene.add(lightning);
                this.beams.push({ mesh: lightning, life: 0.15 });
                // Glow at impact
                const glow = new THREE.Mesh(new THREE.SphereGeometry(0.5, 8, 8), new THREE.MeshBasicMaterial({ color: 0xffffaa, transparent: true, opacity: 0.8 }));
                glow.position.copy(points[points.length - 1]);
                this.scene.add(glow);
                this.beams.push({ mesh: glow, life: 0.2 });
            }

            shootCluster(origin, direction, speed = 30, count = 6) {
                this.audio.play('throw');
                const group = new THREE.Group();
                const main = new THREE.Mesh(new THREE.SphereGeometry(0.2, 8, 8), new THREE.MeshLambertMaterial({ color: 0xff0066 }));
                group.add(main);
                // Small bomblets visible
                for (let i = 0; i < count; i++) {
                    const bomblet = new THREE.Mesh(new THREE.SphereGeometry(0.08, 6, 6), new THREE.MeshLambertMaterial({ color: 0xff4488 }));
                    bomblet.position.set((Math.random() - 0.5) * 0.2, (Math.random() - 0.5) * 0.2, (Math.random() - 0.5) * 0.2);
                    group.add(bomblet);
                }
                group.position.copy(origin);
                this.scene.add(group);
                this.projectiles.push({ mesh: group, velocity: direction.clone().multiplyScalar(speed), gravity: -15, life: 2, type: 'cluster', count: count });
            }

            shootBFG(origin, direction, speed = 25) {
                this.audio.play('shoot_railgun');
                const group = new THREE.Group();
                const core = new THREE.Mesh(new THREE.SphereGeometry(0.5, 12, 12), new THREE.MeshBasicMaterial({ color: 0x00ff00 }));
                group.add(core);
                const glow = new THREE.Mesh(new THREE.SphereGeometry(0.8, 12, 12), new THREE.MeshBasicMaterial({ color: 0x88ff88, transparent: true, opacity: 0.4 }));
                group.add(glow);
                const outerGlow = new THREE.Mesh(new THREE.SphereGeometry(1.2, 12, 12), new THREE.MeshBasicMaterial({ color: 0xaaffaa, transparent: true, opacity: 0.2 }));
                group.add(outerGlow);
                group.position.copy(origin);
                this.scene.add(group);
                this.projectiles.push({ mesh: group, velocity: direction.clone().multiplyScalar(speed), gravity: 0, life: 5, type: 'bfg' });
            }

            shootNuke(origin, direction, speed = 30) {
                this.audio.play('shoot_tnt');
                const group = new THREE.Group();
                const body = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.15, 0.8, 8), new THREE.MeshLambertMaterial({ color: 0x333333 }));
                body.rotation.x = Math.PI / 2;
                group.add(body);
                const nose = new THREE.Mesh(new THREE.SphereGeometry(0.15, 8, 8), new THREE.MeshLambertMaterial({ color: 0xffff00 }));
                nose.position.z = -0.5;
                group.add(nose);
                // Radiation symbol
                const symbolMat = new THREE.MeshBasicMaterial({ color: 0xffff00 });
                const symbol = new THREE.Mesh(new THREE.CircleGeometry(0.1, 6), symbolMat);
                symbol.position.set(0, 0.16, 0);
                symbol.rotation.x = -Math.PI / 2;
                group.add(symbol);
                group.position.copy(origin);
                group.lookAt(origin.clone().add(direction));
                this.scene.add(group);
                this.projectiles.push({ mesh: group, velocity: direction.clone().multiplyScalar(speed), gravity: -8, life: 8, type: 'nuke' });
            }

            shootGravityWave(origin, direction) {
                this.audio.play('freeze');
                const ring = new THREE.Mesh(new THREE.TorusGeometry(0.5, 0.1, 8, 16), new THREE.MeshBasicMaterial({ color: 0x8844ff, transparent: true, opacity: 0.7 }));
                ring.position.copy(origin).add(direction.clone().multiplyScalar(2));
                ring.lookAt(origin.clone().add(direction.clone().multiplyScalar(10)));
                this.scene.add(ring);
                this.beams.push({ mesh: ring, life: 0.3, expand: true, velocity: direction.clone().multiplyScalar(30) });
            }

            shootBlackHole(origin, direction, speed = 20) {
                this.audio.play('shoot_railgun');
                const group = new THREE.Group();
                const core = new THREE.Mesh(new THREE.SphereGeometry(0.3, 12, 12), new THREE.MeshBasicMaterial({ color: 0x000000 }));
                group.add(core);
                const accretion = new THREE.Mesh(new THREE.TorusGeometry(0.5, 0.1, 8, 16), new THREE.MeshBasicMaterial({ color: 0x4400aa, transparent: true, opacity: 0.6 }));
                accretion.rotation.x = Math.PI / 2;
                group.add(accretion);
                const glow = new THREE.Mesh(new THREE.SphereGeometry(0.6, 12, 12), new THREE.MeshBasicMaterial({ color: 0x220044, transparent: true, opacity: 0.3 }));
                group.add(glow);
                group.position.copy(origin);
                this.scene.add(group);
                this.projectiles.push({ mesh: group, velocity: direction.clone().multiplyScalar(speed), gravity: 0, life: 4, type: 'blackhole', duration: 3 });
            }

            explode(x, y, z, radius = 4) {
                this.lastExplosion = { x, y, z, time: performance.now() };
                this.audio.play(radius > 5 ? 'explosion_big' : 'explosion', { size: radius / 4 });
                // Broadcast explosion in multiplayer
                if (this.game && this.game.networkManager) {
                    this.game.networkManager.broadcastExplosion(x, y, z, radius);
                }

                const blocksToDestroy = [];
                for (let dx = -radius; dx <= radius; dx++) {
                    for (let dy = -radius; dy <= radius; dy++) {
                        for (let dz = -radius; dz <= radius; dz++) {
                            const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);
                            if (dist <= radius) {
                                const bx = Math.floor(x) + dx, by = Math.floor(y) + dy, bz = Math.floor(z) + dz;
                                const block = this.world.getBlock(bx, by, bz);
                                if (block !== BLOCKS.AIR && block !== BLOCKS.BEDROCK) {
                                    if (Math.random() > dist / radius * 0.3) {
                                        blocksToDestroy.push({ x: bx, y: by, z: bz, block });
                                    }
                                }
                            }
                        }
                    }
                }

                const chunksToRebuild = new Set();
                for (const { x: bx, y: by, z: bz, block } of blocksToDestroy) {
                    this.world.setBlock(bx, by, bz, BLOCKS.AIR);
                    chunksToRebuild.add(`${Math.floor(bx / CONFIG.CHUNK_SIZE)},${Math.floor(bz / CONFIG.CHUNK_SIZE)}`);
                    const color = BLOCK_DATA[block]?.colors?.top || 0x888888;
                    this.spawnParticle(bx + 0.5, by + 0.5, bz + 0.5, color);
                }

                for (const key of chunksToRebuild) {
                    const [cx, cz] = key.split(',').map(Number);
                    this.meshBuilder.pendingChunks.delete(key);
                    this.meshBuilder.buildChunkMeshAsync(cx, cz);
                }

                // Explosion particles
                for (let i = 0; i < 40; i++) {
                    const color = [0xff6600, 0xffaa00, 0xff4400, 0xffff00][Math.floor(Math.random() * 4)];
                    this.spawnParticle(x, y, z, color, true);
                }

                // Chain TNT
                for (let dx = -radius - 1; dx <= radius + 1; dx++) {
                    for (let dy = -radius - 1; dy <= radius + 1; dy++) {
                        for (let dz = -radius - 1; dz <= radius + 1; dz++) {
                            const bx = Math.floor(x) + dx, by = Math.floor(y) + dy, bz = Math.floor(z) + dz;
                            if (this.world.getBlock(bx, by, bz) === BLOCKS.TNT) {
                                this.world.setBlock(bx, by, bz, BLOCKS.AIR);
                                setTimeout(() => this.explode(bx + 0.5, by + 0.5, bz + 0.5, radius), 50 + Math.random() * 150);
                            }
                        }
                    }
                }

                // Damage entities and players in radius
                if (this.entityManager) {
                    this.entityManager.damageEntitiesInRadius(new THREE.Vector3(x, y, z), radius * 1.5, radius * 3);
                }
                if (this.game) {
                    this.game.damagePlayersInRadius(new THREE.Vector3(x, y, z), radius * 1.5, radius * 3);
                }

                // Flash light
                const light = new THREE.PointLight(0xff6600, 5, 30);
                light.position.set(x, y, z);
                this.scene.add(light);
                this.beams.push({ mesh: light, life: 0.2, isLight: true });
            }

            spawnParticle(x, y, z, color, isExplosion = false, isCold = false) {
                // Limit particles for performance
                if (this.particles.length > 500) return;

                const mat = new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 1 });
                const mesh = new THREE.Mesh(this.particleGeom, mat);
                mesh.position.set(x, y, z);
                mesh.scale.setScalar(isExplosion ? 0.3 + Math.random() * 0.4 : 0.3);
                this.scene.add(mesh);

                const speed = isExplosion ? 10 + Math.random() * 15 : 5 + Math.random() * 5;
                const angle = Math.random() * Math.PI * 2;
                const upward = isExplosion ? 8 + Math.random() * 12 : 3 + Math.random() * 5;

                this.particles.push({
                    mesh, velocity: new THREE.Vector3(Math.cos(angle) * speed, upward, Math.sin(angle) * speed),
                    life: isCold ? 1 + Math.random() * 1 : 0.5 + Math.random() * 0.8,
                    gravity: isCold ? -5 : -30
                });
            }

            update(dt, playerPos = null) {
                let playerHit = null;

                // Update projectiles
                for (let i = this.projectiles.length - 1; i >= 0; i--) {
                    const proj = this.projectiles[i];
                    proj.life -= dt;

                    // Handle grenade fuse
                    if (proj.type === 'grenade') {
                        proj.fuse -= dt;
                        if (proj.fuse <= 0) {
                            const px = proj.mesh.position.x, py = proj.mesh.position.y, pz = proj.mesh.position.z;
                            this.explode(px, py, pz, 3);
                            this.removeProjectileMesh(proj.mesh);
                            this.projectiles.splice(i, 1);
                            continue;
                        }
                    }

                    if (proj.life <= 0) { this.removeProjectileMesh(proj.mesh); this.projectiles.splice(i, 1); continue; }
                    proj.velocity.y += proj.gravity * dt;
                    proj.mesh.position.add(proj.velocity.clone().multiplyScalar(dt));

                    // Check fireball hit on player
                    if (proj.type === 'fireball' && playerPos) {
                        const dist = proj.mesh.position.distanceTo(playerPos);
                        if (dist < 1.5) {
                            playerHit = { damage: proj.damage || 3 };
                            // Fire particles
                            for (let j = 0; j < 8; j++) {
                                this.spawnParticle(proj.mesh.position.x, proj.mesh.position.y, proj.mesh.position.z, 0xff6600);
                            }
                            this.removeProjectileMesh(proj.mesh);
                            this.projectiles.splice(i, 1);
                            continue;
                        }
                    }

                    // Arrow rotation to follow velocity
                    if (proj.type === 'arrow') {
                        proj.mesh.lookAt(proj.mesh.position.clone().add(proj.velocity.clone().normalize()));
                    } else {
                        proj.mesh.rotation.x += dt * 10; proj.mesh.rotation.z += dt * 8;
                    }

                    // Smoke trail for TNT only
                    if (proj.type === 'tnt' && Math.random() < 0.6) {
                        const smokeMat = new THREE.MeshBasicMaterial({ color: Math.random() > 0.5 ? 0x444444 : 0x666666, transparent: true, opacity: 0.5 });
                        const smokeMesh = new THREE.Mesh(this.particleGeom, smokeMat);
                        smokeMesh.position.copy(proj.mesh.position);
                        smokeMesh.scale.setScalar(0.1 + Math.random() * 0.1);
                        this.scene.add(smokeMesh);
                        this.particles.push({ mesh: smokeMesh, velocity: new THREE.Vector3((Math.random()-0.5)*2, 1+Math.random(), (Math.random()-0.5)*2), life: 0.3 + Math.random() * 0.2, gravity: 0 });
                    }

                    // Fire trail for fireballs
                    if (proj.type === 'fireball' && Math.random() < 0.8) {
                        const fireMat = new THREE.MeshBasicMaterial({ color: Math.random() > 0.5 ? 0xff6600 : 0xffaa00, transparent: true, opacity: 0.7 });
                        const fireMesh = new THREE.Mesh(this.particleGeom, fireMat);
                        fireMesh.position.copy(proj.mesh.position);
                        fireMesh.scale.setScalar(0.15 + Math.random() * 0.1);
                        this.scene.add(fireMesh);
                        this.particles.push({ mesh: fireMesh, velocity: new THREE.Vector3((Math.random()-0.5)*2, 2+Math.random()*2, (Math.random()-0.5)*2), life: 0.2 + Math.random() * 0.2, gravity: -5 });
                    }

                    // Rocket trail
                    if (proj.type === 'rocket' && Math.random() < 0.8) {
                        this.spawnParticle(proj.mesh.position.x, proj.mesh.position.y, proj.mesh.position.z, Math.random() > 0.5 ? 0xff4400 : 0xffaa00);
                    }

                    // Plasma trail
                    if (proj.type === 'plasma' && Math.random() < 0.5) {
                        const plasmaMat = new THREE.MeshBasicMaterial({ color: 0x00ff88, transparent: true, opacity: 0.6 });
                        const plasmaPart = new THREE.Mesh(this.particleGeom, plasmaMat);
                        plasmaPart.position.copy(proj.mesh.position);
                        this.scene.add(plasmaPart);
                        this.particles.push({ mesh: plasmaPart, velocity: new THREE.Vector3((Math.random()-0.5)*3, (Math.random()-0.5)*3, (Math.random()-0.5)*3), life: 0.2, gravity: 0 });
                    }

                    // BFG energy tendrils
                    if (proj.type === 'bfg' && Math.random() < 0.3) {
                        const tendrilMat = new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.7 });
                        const tendril = new THREE.Mesh(this.particleGeom, tendrilMat);
                        tendril.position.copy(proj.mesh.position);
                        tendril.scale.setScalar(0.3);
                        this.scene.add(tendril);
                        this.particles.push({ mesh: tendril, velocity: new THREE.Vector3((Math.random()-0.5)*10, (Math.random()-0.5)*10, (Math.random()-0.5)*10), life: 0.3, gravity: 0 });
                        // BFG damages nearby entities while flying
                        if (this.entityManager) {
                            this.entityManager.damageEntitiesInRadius(proj.mesh.position, 5, 2);
                        }
                    }

                    // Nuke radiation particles
                    if (proj.type === 'nuke' && Math.random() < 0.4) {
                        const radMat = new THREE.MeshBasicMaterial({ color: 0xffff00, transparent: true, opacity: 0.5 });
                        const rad = new THREE.Mesh(this.particleGeom, radMat);
                        rad.position.copy(proj.mesh.position);
                        this.scene.add(rad);
                        this.particles.push({ mesh: rad, velocity: new THREE.Vector3((Math.random()-0.5)*5, Math.random()*3, (Math.random()-0.5)*5), life: 0.5, gravity: -2 });
                    }

                    // Black hole pulls in entities and blocks
                    if (proj.type === 'blackhole') {
                        proj.mesh.rotation.y += dt * 5;
                        // Pull nearby entities
                        if (this.entityManager) {
                            for (const entity of this.entityManager.entities) {
                                const toHole = proj.mesh.position.clone().sub(entity.position);
                                const dist = toHole.length();
                                if (dist < 15 && dist > 1) {
                                    toHole.normalize().multiplyScalar(20 / dist);
                                    entity.velocity.add(toHole);
                                }
                                if (dist < 2) {
                                    entity.takeDamage(10);
                                }
                            }
                        }
                        // Visual distortion particles
                        if (Math.random() < 0.5) {
                            const distortMat = new THREE.MeshBasicMaterial({ color: 0x4400aa, transparent: true, opacity: 0.6 });
                            const distort = new THREE.Mesh(this.particleGeom, distortMat);
                            const angle = Math.random() * Math.PI * 2;
                            distort.position.copy(proj.mesh.position).add(new THREE.Vector3(Math.cos(angle) * 3, (Math.random()-0.5)*2, Math.sin(angle) * 3));
                            this.scene.add(distort);
                            const toCenter = proj.mesh.position.clone().sub(distort.position).normalize().multiplyScalar(8);
                            this.particles.push({ mesh: distort, velocity: toCenter, life: 0.4, gravity: 0 });
                        }
                    }

                    // Cluster bomb splits
                    if (proj.type === 'cluster' && proj.life < 0.5 && !proj.split) {
                        proj.split = true;
                        const px = proj.mesh.position.x, py = proj.mesh.position.y, pz = proj.mesh.position.z;
                        for (let j = 0; j < proj.count; j++) {
                            const bombletDir = new THREE.Vector3((Math.random()-0.5)*2, Math.random(), (Math.random()-0.5)*2).normalize();
                            const bomblet = new THREE.Mesh(new THREE.SphereGeometry(0.1, 6, 6), new THREE.MeshLambertMaterial({ color: 0xff4488 }));
                            bomblet.position.set(px, py, pz);
                            this.scene.add(bomblet);
                            this.projectiles.push({ mesh: bomblet, velocity: bombletDir.multiplyScalar(15), gravity: -20, life: 0.5 + Math.random() * 0.5, type: 'clusterbomblet' });
                        }
                    }

                    const px = proj.mesh.position.x, py = proj.mesh.position.y, pz = proj.mesh.position.z;
                    const block = this.world.getBlock(px, py, pz);
                    if (block !== BLOCKS.AIR && block !== BLOCKS.WATER) {
                        if (proj.type === 'arrow') {
                            // Arrow hits block and destroys it
                            const bx = Math.floor(px), by = Math.floor(py), bz = Math.floor(pz);
                            if (block !== BLOCKS.BEDROCK) {
                                this.world.setBlock(bx, by, bz, BLOCKS.AIR);
                                this.meshBuilder.rebuildChunksNear(bx, by, bz);
                                this.audio.play('hit');
                                for (let j = 0; j < 5; j++) this.spawnParticle(bx + 0.5, by + 0.5, bz + 0.5, BLOCK_DATA[block]?.colors?.top || 0x888888);
                            }
                            this.removeProjectileMesh(proj.mesh);
                            this.projectiles.splice(i, 1);
                        } else if (proj.type === 'grenade') {
                            // Grenade bounces
                            proj.velocity.y = Math.abs(proj.velocity.y) * 0.5;
                            proj.velocity.x *= 0.7;
                            proj.velocity.z *= 0.7;
                        } else if (proj.type === 'fireball') {
                            // Fireball small explosion
                            for (let j = 0; j < 12; j++) this.spawnParticle(px, py, pz, Math.random() > 0.5 ? 0xff6600 : 0xffaa00);
                            this.audio.play('explode');
                            this.removeProjectileMesh(proj.mesh);
                            this.projectiles.splice(i, 1);
                        } else if (proj.type === 'rocket') {
                            this.explode(px, py, pz, 6);
                            this.removeProjectileMesh(proj.mesh);
                            this.projectiles.splice(i, 1);
                        } else if (proj.type === 'plasma') {
                            this.explode(px, py, pz, 3);
                            for (let j = 0; j < 20; j++) this.spawnParticle(px, py, pz, 0x00ff88);
                            this.removeProjectileMesh(proj.mesh);
                            this.projectiles.splice(i, 1);
                        } else if (proj.type === 'bfg') {
                            this.explode(px, py, pz, 10);
                            // Extra green explosion
                            for (let j = 0; j < 50; j++) this.spawnParticle(px, py, pz, 0x00ff00, true);
                            this.removeProjectileMesh(proj.mesh);
                            this.projectiles.splice(i, 1);
                        } else if (proj.type === 'nuke') {
                            // MASSIVE explosion
                            this.explode(px, py, pz, 15);
                            // Secondary explosions
                            for (let j = 0; j < 5; j++) {
                                setTimeout(() => {
                                    this.explode(px + (Math.random()-0.5)*10, py + Math.random()*5, pz + (Math.random()-0.5)*10, 8);
                                }, j * 100);
                            }
                            // Mushroom cloud particles
                            for (let j = 0; j < 100; j++) this.spawnParticle(px, py, pz, Math.random() > 0.5 ? 0xff6600 : 0xffff00, true);
                            this.removeProjectileMesh(proj.mesh);
                            this.projectiles.splice(i, 1);
                        } else if (proj.type === 'blackhole') {
                            // Implosion effect
                            this.explode(px, py, pz, 8);
                            for (let j = 0; j < 30; j++) this.spawnParticle(px, py, pz, 0x4400aa, true);
                            this.removeProjectileMesh(proj.mesh);
                            this.projectiles.splice(i, 1);
                        } else if (proj.type === 'clusterbomblet') {
                            this.explode(px, py, pz, 2);
                            this.removeProjectileMesh(proj.mesh);
                            this.projectiles.splice(i, 1);
                        } else {
                            this.explode(px, py, pz, 4);
                            this.removeProjectileMesh(proj.mesh);
                            this.projectiles.splice(i, 1);
                        }
                    } else if (py < -10) {
                        this.removeProjectileMesh(proj.mesh);
                        this.projectiles.splice(i, 1);
                    }
                }

                // Update beams
                for (let i = this.beams.length - 1; i >= 0; i--) {
                    const beam = this.beams[i];
                    beam.life -= dt;
                    if (beam.life <= 0) {
                        this.scene.remove(beam.mesh);
                        if (!beam.isLight && beam.mesh.geometry) beam.mesh.geometry.dispose();
                        if (!beam.isLight && beam.mesh.material) beam.mesh.material.dispose();
                        this.beams.splice(i, 1);
                        continue;
                    }
                    if (beam.velocity) beam.mesh.position.add(beam.velocity.clone().multiplyScalar(dt));
                    if (beam.expand) beam.mesh.scale.x = beam.mesh.scale.z = 1 + (0.3 - beam.life) * 5;
                    if (!beam.isLight) beam.mesh.material.opacity = beam.life * 3;
                    if (beam.isLight) beam.mesh.intensity = beam.life * 25;
                }

                // Update particles
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    const part = this.particles[i];
                    part.life -= dt;
                    if (part.life <= 0) { this.scene.remove(part.mesh); part.mesh.material.dispose(); this.particles.splice(i, 1); continue; }
                    part.velocity.y += part.gravity * dt;
                    part.mesh.position.add(part.velocity.clone().multiplyScalar(dt));
                    part.mesh.material.opacity = Math.min(1, part.life * 2);
                    part.mesh.scale.setScalar(part.life * 0.4);
                }

                return playerHit;
            }

            removeProjectileMesh(mesh) {
                this.scene.remove(mesh);
                mesh.traverse(c => { if (c.geometry) c.geometry.dispose(); if (c.material) c.material.dispose(); });
            }
        }

        // ============================================
        // ENTITY SYSTEM
        // ============================================
        const MOB_TYPES = {
            // Passive mobs
            PIG: { name: 'Pig', health: 10, speed: 2, hostile: false, color: 0xffaaaa, drops: ['pork'], scale: 1 },
            COW: { name: 'Cow', health: 10, speed: 1.5, hostile: false, color: 0x8b4513, drops: ['beef'], scale: 1.2 },
            CHICKEN: { name: 'Chicken', health: 4, speed: 2.5, hostile: false, color: 0xffffff, drops: ['feather'], scale: 0.6 },
            SHEEP: { name: 'Sheep', health: 8, speed: 1.8, hostile: false, color: 0xeeeeee, drops: ['wool'], scale: 1, fluffy: true },
            RABBIT: { name: 'Rabbit', health: 3, speed: 4, hostile: false, color: 0xddaa77, drops: ['rabbit'], scale: 0.4, jumpy: true },
            DUCK: { name: 'Duck', health: 4, speed: 2, hostile: false, color: 0xffdd00, drops: ['feather'], scale: 0.5 },
            HORSE: { name: 'Horse', health: 15, speed: 5, hostile: false, color: 0x8b6914, drops: ['leather'], scale: 1.4, horse: true },
            FROG: { name: 'Frog', health: 3, speed: 2, hostile: false, color: 0x44aa44, drops: ['slimeball'], scale: 0.4, jumpy: true },
            TURTLE: { name: 'Turtle', health: 20, speed: 0.5, hostile: false, color: 0x228844, drops: ['shell'], scale: 0.8, armored: true },
            PENGUIN: { name: 'Penguin', health: 6, speed: 1.5, hostile: false, color: 0x222222, drops: ['feather'], scale: 0.7, waddle: true },
            BAT: { name: 'Bat', health: 2, speed: 4, hostile: false, color: 0x333333, drops: ['leather'], scale: 0.3, flying: true },
            FISH: { name: 'Fish', health: 2, speed: 3, hostile: false, color: 0xff8800, drops: ['fish'], scale: 0.3, fish: true },

            // Hostile mobs
            ZOMBIE: { name: 'Zombie', health: 20, speed: 2.5, hostile: true, color: 0x2a5a2a, damage: 3, drops: ['rotten_flesh'], scale: 1 },
            SKELETON: { name: 'Skeleton', health: 20, speed: 3, hostile: true, color: 0xcccccc, damage: 2, ranged: true, drops: ['bone'], scale: 1 },
            CREEPER: { name: 'Creeper', health: 20, speed: 2, hostile: true, color: 0x00aa00, explodes: true, drops: ['gunpowder'], scale: 1 },
            SPIDER: { name: 'Spider', health: 16, speed: 3.5, hostile: true, color: 0x3a3a3a, damage: 2, drops: ['string'], scale: 1.2, spider: true },
            SLIME: { name: 'Slime', health: 12, speed: 1.5, hostile: true, color: 0x55ff55, damage: 2, drops: ['slimeball'], scale: 1.5, bouncy: true, splits: true },
            GIANT_SLIME: { name: 'Giant Slime', health: 40, speed: 1, hostile: true, color: 0x33dd33, damage: 4, drops: ['slimeball'], scale: 3, bouncy: true, splits: true, boss: true },
            WOLF: { name: 'Wolf', health: 8, speed: 4, hostile: true, color: 0x888888, damage: 4, drops: ['bone'], scale: 0.9, pack: true },
            BLAZE: { name: 'Blaze', health: 20, speed: 2, hostile: true, color: 0xff6600, damage: 3, drops: ['blaze_rod'], scale: 1, flying: true, shoots: true },
            GHOST: { name: 'Ghost', health: 15, speed: 2.5, hostile: true, color: 0xaaaaff, damage: 2, drops: ['ectoplasm'], scale: 1.1, flying: true, transparent: true },
            BOMBER: { name: 'Bomber', health: 8, speed: 3, hostile: true, color: 0xff0000, damage: 1, drops: ['gunpowder'], scale: 0.8, explodes: true, flying: true },
            MAGMA_CUBE: { name: 'Magma Cube', health: 16, speed: 2, hostile: true, color: 0xff3300, damage: 3, drops: ['magma_cream'], scale: 1.3, bouncy: true, splits: true, glowing: true },
            WITCH: { name: 'Witch', health: 26, speed: 2, hostile: true, color: 0x340034, damage: 2, drops: ['potion'], scale: 1.1, witch: true, shoots: true },
            ENDERMAN: { name: 'Enderman', health: 40, speed: 5, hostile: true, color: 0x111111, damage: 6, drops: ['ender_pearl'], scale: 1.8, tall: true, teleports: true },
            WORM: { name: 'Worm', health: 30, speed: 3, hostile: true, color: 0x664422, damage: 4, drops: ['string'], scale: 1.5, worm: true },
            BEE: { name: 'Bee', health: 4, speed: 5, hostile: true, color: 0xffcc00, damage: 2, drops: ['honey'], scale: 0.3, flying: true, swarm: true },
            MIMIC: { name: 'Mimic', health: 25, speed: 3, hostile: true, color: 0x8b4513, damage: 5, drops: ['gold'], scale: 1, mimic: true },
            CHARGED_CREEPER: { name: 'Charged Creeper', health: 20, speed: 2.5, hostile: true, color: 0x00ffff, explodes: true, drops: ['gunpowder'], scale: 1.1, charged: true, bigExplosion: true },
            TNT_ZOMBIE: { name: 'TNT Zombie', health: 25, speed: 2, hostile: true, color: 0xff2200, damage: 3, drops: ['gunpowder'], scale: 1.1, explodes: true, tntHead: true },
            FIRE_ELEMENTAL: { name: 'Fire Elemental', health: 30, speed: 2.5, hostile: true, color: 0xff4400, damage: 4, drops: ['blaze_rod'], scale: 1.3, flying: true, shoots: true, glowing: true },
            ICE_ELEMENTAL: { name: 'Ice Elemental', health: 30, speed: 2, hostile: true, color: 0x88ddff, damage: 3, drops: ['ice'], scale: 1.3, freezes: true },
            PHANTOM: { name: 'Phantom', health: 12, speed: 4, hostile: true, color: 0x4444aa, damage: 3, drops: ['membrane'], scale: 1.2, flying: true, swoops: true },

            // Mini bosses
            MEGA_ZOMBIE: { name: 'Mega Zombie', health: 80, speed: 1.8, hostile: true, color: 0x1a3a1a, damage: 8, drops: ['diamond'], scale: 2.5, boss: true },
            KING_SLIME: { name: 'King Slime', health: 100, speed: 0.8, hostile: true, color: 0x00ff88, damage: 5, drops: ['emerald'], scale: 4, bouncy: true, splits: true, boss: true, crown: true },
            GOLEM: { name: 'Golem', health: 150, speed: 1, hostile: true, color: 0x777777, damage: 10, drops: ['iron'], scale: 2.5, boss: true, armored: true },
            HYDRA: { name: 'Hydra', health: 120, speed: 1.5, hostile: true, color: 0x226622, damage: 6, drops: ['diamond'], scale: 2.5, boss: true, multiHead: true, shoots: true },
            DRAGON: { name: 'Dragon', health: 200, speed: 3, hostile: true, color: 0x440044, damage: 10, drops: ['dragon_egg'], scale: 3, boss: true, flying: true, shoots: true },
            TITAN: { name: 'Titan', health: 300, speed: 0.8, hostile: true, color: 0x553311, damage: 15, drops: ['nether_star'], scale: 5, boss: true, earthquake: true }
        };

        class Entity {
            constructor(type, position, scene, world) {
                this.type = type;
                this.data = MOB_TYPES[type];
                this.position = position.clone();
                this.velocity = new THREE.Vector3();
                this.health = this.data.health;
                this.maxHealth = this.data.health;
                this.scene = scene;
                this.world = world;
                this.target = null;
                this.attackCooldown = 0;
                this.wanderTimer = 0;
                this.wanderDir = new THREE.Vector3();
                this.onGround = false;
                this.dead = false;
                this.deathTimer = 0;
                this.hurtTimer = 0;
                // Network properties
                this.networkId = null;
                this.networkTarget = null;
                this.networkYaw = null;

                this.createMesh();
            }

            createMesh() {
                this.mesh = new THREE.Group();
                const scale = this.data.scale || 1;
                const matOptions = { color: this.data.color };
                if (this.data.transparent) {
                    matOptions.transparent = true;
                    matOptions.opacity = 0.6;
                }
                const bodyMat = new THREE.MeshLambertMaterial(matOptions);
                this.legs = [];

                if (this.data.bouncy) {
                    // Slime - blobby sphere
                    const slimeGeom = new THREE.SphereGeometry(0.5 * scale, 12, 12);
                    const slimeMat = new THREE.MeshLambertMaterial({ color: this.data.color, transparent: true, opacity: 0.7 });
                    const slime = new THREE.Mesh(slimeGeom, slimeMat);
                    slime.position.y = 0.5 * scale;
                    this.mesh.add(slime);
                    this.body = slime;

                    // Inner core
                    const coreGeom = new THREE.SphereGeometry(0.25 * scale, 8, 8);
                    const coreMat = new THREE.MeshLambertMaterial({ color: 0x225522 });
                    const core = new THREE.Mesh(coreGeom, coreMat);
                    core.position.y = 0.4 * scale;
                    this.mesh.add(core);

                    // Eyes
                    const eyeGeom = new THREE.SphereGeometry(0.08 * scale, 6, 6);
                    const eyeMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
                    const leftEye = new THREE.Mesh(eyeGeom, eyeMat);
                    leftEye.position.set(-0.15 * scale, 0.6 * scale, -0.35 * scale);
                    this.mesh.add(leftEye);
                    const rightEye = new THREE.Mesh(eyeGeom, eyeMat);
                    rightEye.position.set(0.15 * scale, 0.6 * scale, -0.35 * scale);
                    this.mesh.add(rightEye);

                    // Crown for King Slime
                    if (this.data.crown) {
                        const crownMat = new THREE.MeshLambertMaterial({ color: 0xffd700 });
                        const crownBase = new THREE.Mesh(new THREE.CylinderGeometry(0.3 * scale, 0.35 * scale, 0.15 * scale, 8), crownMat);
                        crownBase.position.y = 1 * scale;
                        this.mesh.add(crownBase);
                        for (let i = 0; i < 5; i++) {
                            const spike = new THREE.Mesh(new THREE.ConeGeometry(0.06 * scale, 0.2 * scale, 4), crownMat);
                            spike.position.set(Math.cos(i * Math.PI * 2 / 5) * 0.2 * scale, 1.15 * scale, Math.sin(i * Math.PI * 2 / 5) * 0.2 * scale);
                            this.mesh.add(spike);
                        }
                    }
                } else if (this.data.spider) {
                    // Spider - wide body with 8 legs
                    const spiderBody = new THREE.Mesh(new THREE.SphereGeometry(0.4 * scale, 8, 8), bodyMat);
                    spiderBody.position.y = 0.4 * scale;
                    spiderBody.scale.set(1.5, 0.8, 1);
                    this.mesh.add(spiderBody);
                    this.body = spiderBody;

                    const spiderHead = new THREE.Mesh(new THREE.SphereGeometry(0.25 * scale, 8, 8), bodyMat);
                    spiderHead.position.set(0, 0.35 * scale, -0.5 * scale);
                    this.mesh.add(spiderHead);

                    // 8 red eyes
                    const eyeMat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
                    for (let i = 0; i < 8; i++) {
                        const eye = new THREE.Mesh(new THREE.SphereGeometry(0.04 * scale, 4, 4), eyeMat);
                        const row = Math.floor(i / 4);
                        const col = i % 4;
                        eye.position.set((col - 1.5) * 0.08 * scale, (0.4 - row * 0.1) * scale, (-0.7) * scale);
                        this.mesh.add(eye);
                    }

                    // 8 legs
                    const legMat = new THREE.MeshLambertMaterial({ color: 0x2a2a2a });
                    for (let i = 0; i < 8; i++) {
                        const side = i < 4 ? -1 : 1;
                        const idx = i % 4;
                        const leg = new THREE.Mesh(new THREE.CylinderGeometry(0.03 * scale, 0.02 * scale, 0.6 * scale, 4), legMat);
                        leg.position.set(side * 0.5 * scale, 0.3 * scale, (idx - 1.5) * 0.25 * scale);
                        leg.rotation.z = side * Math.PI / 3;
                        this.mesh.add(leg);
                        this.legs.push(leg);
                    }
                } else if (this.data.flying) {
                    // Flying mobs - floaty body
                    if (this.type === 'BLAZE') {
                        // Blaze - fiery rods
                        const blazeCore = new THREE.Mesh(new THREE.BoxGeometry(0.4 * scale, 0.5 * scale, 0.4 * scale), new THREE.MeshLambertMaterial({ color: 0xffaa00, emissive: 0xff6600, emissiveIntensity: 0.5 }));
                        blazeCore.position.y = 0.8 * scale;
                        this.mesh.add(blazeCore);
                        this.body = blazeCore;

                        // Rotating rods
                        const rodMat = new THREE.MeshLambertMaterial({ color: 0xffdd00, emissive: 0xff8800, emissiveIntensity: 0.3 });
                        for (let i = 0; i < 8; i++) {
                            const rod = new THREE.Mesh(new THREE.CylinderGeometry(0.04 * scale, 0.04 * scale, 0.5 * scale, 4), rodMat);
                            const angle = (i / 8) * Math.PI * 2;
                            rod.position.set(Math.cos(angle) * 0.4 * scale, 0.5 * scale + (i % 2) * 0.3 * scale, Math.sin(angle) * 0.4 * scale);
                            rod.rotation.x = Math.PI / 6;
                            this.mesh.add(rod);
                            this.legs.push(rod);
                        }
                    } else if (this.type === 'GHOST') {
                        // Ghost - wavy transparent body
                        const ghostBody = new THREE.Mesh(new THREE.ConeGeometry(0.4 * scale, 1 * scale, 8), bodyMat);
                        ghostBody.position.y = 0.6 * scale;
                        ghostBody.rotation.x = Math.PI;
                        this.mesh.add(ghostBody);
                        this.body = ghostBody;

                        // Spooky eyes
                        const eyeMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
                        const leftEye = new THREE.Mesh(new THREE.SphereGeometry(0.08 * scale, 6, 6), eyeMat);
                        leftEye.position.set(-0.12 * scale, 0.8 * scale, -0.25 * scale);
                        this.mesh.add(leftEye);
                        const rightEye = new THREE.Mesh(new THREE.SphereGeometry(0.08 * scale, 6, 6), eyeMat);
                        rightEye.position.set(0.12 * scale, 0.8 * scale, -0.25 * scale);
                        this.mesh.add(rightEye);
                    } else if (this.type === 'BOMBER') {
                        // Bomber - angry flying bomb
                        const bombBody = new THREE.Mesh(new THREE.SphereGeometry(0.35 * scale, 10, 10), new THREE.MeshLambertMaterial({ color: 0x222222 }));
                        bombBody.position.y = 0.5 * scale;
                        this.mesh.add(bombBody);
                        this.body = bombBody;

                        // Fuse
                        const fuse = new THREE.Mesh(new THREE.CylinderGeometry(0.03 * scale, 0.03 * scale, 0.2 * scale, 4), new THREE.MeshLambertMaterial({ color: 0x888888 }));
                        fuse.position.y = 0.9 * scale;
                        this.mesh.add(fuse);

                        // Spark
                        const spark = new THREE.Mesh(new THREE.SphereGeometry(0.05 * scale, 6, 6), new THREE.MeshBasicMaterial({ color: 0xffff00 }));
                        spark.position.y = 1 * scale;
                        this.mesh.add(spark);
                        this.spark = spark;

                        // Angry eyes
                        const eyeMat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
                        const leftEye = new THREE.Mesh(new THREE.BoxGeometry(0.1 * scale, 0.05 * scale, 0.02 * scale), eyeMat);
                        leftEye.position.set(-0.1 * scale, 0.55 * scale, -0.33 * scale);
                        leftEye.rotation.z = -0.3;
                        this.mesh.add(leftEye);
                        const rightEye = new THREE.Mesh(new THREE.BoxGeometry(0.1 * scale, 0.05 * scale, 0.02 * scale), eyeMat);
                        rightEye.position.set(0.1 * scale, 0.55 * scale, -0.33 * scale);
                        rightEye.rotation.z = 0.3;
                        this.mesh.add(rightEye);

                        // Wings
                        const wingMat = new THREE.MeshLambertMaterial({ color: 0x880000 });
                        const leftWing = new THREE.Mesh(new THREE.BoxGeometry(0.4 * scale, 0.02 * scale, 0.25 * scale), wingMat);
                        leftWing.position.set(-0.4 * scale, 0.5 * scale, 0);
                        this.mesh.add(leftWing);
                        const rightWing = new THREE.Mesh(new THREE.BoxGeometry(0.4 * scale, 0.02 * scale, 0.25 * scale), wingMat);
                        rightWing.position.set(0.4 * scale, 0.5 * scale, 0);
                        this.mesh.add(rightWing);
                        this.legs.push(leftWing, rightWing);
                    } else if (this.type === 'FIRE_ELEMENTAL') {
                        // Fire Elemental - swirling flame
                        const flameMat = new THREE.MeshBasicMaterial({ color: 0xff4400, transparent: true, opacity: 0.8 });
                        const core = new THREE.Mesh(new THREE.SphereGeometry(0.4 * scale, 8, 8), flameMat);
                        core.position.y = 0.6 * scale;
                        this.mesh.add(core);
                        this.body = core;
                        for (let i = 0; i < 6; i++) {
                            const flame = new THREE.Mesh(new THREE.ConeGeometry(0.2 * scale, 0.5 * scale, 6), new THREE.MeshBasicMaterial({ color: i % 2 ? 0xffaa00 : 0xff6600, transparent: true, opacity: 0.7 }));
                            flame.position.set(Math.cos(i) * 0.3 * scale, 0.9 * scale, Math.sin(i) * 0.3 * scale);
                            this.mesh.add(flame);
                            this.legs.push(flame);
                        }
                    } else if (this.type === 'PHANTOM') {
                        // Phantom - swooping wing creature
                        const phantomBody = new THREE.Mesh(new THREE.BoxGeometry(0.3 * scale, 0.2 * scale, 0.8 * scale), bodyMat);
                        phantomBody.position.y = 0.5 * scale;
                        this.mesh.add(phantomBody);
                        this.body = phantomBody;
                        const wingMat = new THREE.MeshLambertMaterial({ color: 0x6666aa, transparent: true, opacity: 0.8 });
                        const leftWing = new THREE.Mesh(new THREE.BoxGeometry(1.2 * scale, 0.05 * scale, 0.5 * scale), wingMat);
                        leftWing.position.set(-0.7 * scale, 0.5 * scale, 0);
                        this.mesh.add(leftWing);
                        const rightWing = new THREE.Mesh(new THREE.BoxGeometry(1.2 * scale, 0.05 * scale, 0.5 * scale), wingMat);
                        rightWing.position.set(0.7 * scale, 0.5 * scale, 0);
                        this.mesh.add(rightWing);
                        this.legs.push(leftWing, rightWing);
                        const eyeMat = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
                        for (let i = -1; i <= 1; i += 2) {
                            const eye = new THREE.Mesh(new THREE.SphereGeometry(0.06 * scale, 6, 6), eyeMat);
                            eye.position.set(i * 0.08 * scale, 0.55 * scale, -0.4 * scale);
                            this.mesh.add(eye);
                        }
                    } else if (this.type === 'BAT') {
                        // Bat - small with wings
                        const batBody = new THREE.Mesh(new THREE.SphereGeometry(0.15 * scale, 8, 8), bodyMat);
                        batBody.position.y = 0.3 * scale;
                        this.mesh.add(batBody);
                        this.body = batBody;
                        const wingMat = new THREE.MeshLambertMaterial({ color: 0x222222, side: THREE.DoubleSide });
                        const leftWing = new THREE.Mesh(new THREE.PlaneGeometry(0.4 * scale, 0.25 * scale), wingMat);
                        leftWing.position.set(-0.25 * scale, 0.3 * scale, 0);
                        leftWing.rotation.y = 0.3;
                        this.mesh.add(leftWing);
                        const rightWing = new THREE.Mesh(new THREE.PlaneGeometry(0.4 * scale, 0.25 * scale), wingMat);
                        rightWing.position.set(0.25 * scale, 0.3 * scale, 0);
                        rightWing.rotation.y = -0.3;
                        this.mesh.add(rightWing);
                        this.legs.push(leftWing, rightWing);
                    } else if (this.type === 'BEE') {
                        // Bee - striped buzzer
                        const beeBody = new THREE.Mesh(new THREE.SphereGeometry(0.12 * scale, 8, 8), new THREE.MeshLambertMaterial({ color: 0xffcc00 }));
                        beeBody.position.y = 0.2 * scale;
                        beeBody.scale.set(1, 0.8, 1.3);
                        this.mesh.add(beeBody);
                        this.body = beeBody;
                        // Stripes
                        for (let i = 0; i < 3; i++) {
                            const stripe = new THREE.Mesh(new THREE.TorusGeometry(0.1 * scale, 0.02 * scale, 4, 8), new THREE.MeshLambertMaterial({ color: 0x111111 }));
                            stripe.position.set(0, 0.2 * scale, (i - 1) * 0.08 * scale);
                            stripe.rotation.x = Math.PI / 2;
                            this.mesh.add(stripe);
                        }
                        // Wings
                        const wingMat = new THREE.MeshLambertMaterial({ color: 0xffffff, transparent: true, opacity: 0.5 });
                        const leftWing = new THREE.Mesh(new THREE.PlaneGeometry(0.2 * scale, 0.1 * scale), wingMat);
                        leftWing.position.set(-0.1 * scale, 0.3 * scale, 0);
                        this.mesh.add(leftWing);
                        const rightWing = new THREE.Mesh(new THREE.PlaneGeometry(0.2 * scale, 0.1 * scale), wingMat);
                        rightWing.position.set(0.1 * scale, 0.3 * scale, 0);
                        this.mesh.add(rightWing);
                        this.legs.push(leftWing, rightWing);
                    } else if (this.type === 'DRAGON') {
                        // Dragon - big scary boss
                        const dragonBody = new THREE.Mesh(new THREE.BoxGeometry(1 * scale, 0.8 * scale, 2 * scale), bodyMat);
                        dragonBody.position.y = 1 * scale;
                        this.mesh.add(dragonBody);
                        this.body = dragonBody;
                        // Head
                        const headMat = new THREE.MeshLambertMaterial({ color: this.data.color });
                        const head = new THREE.Mesh(new THREE.BoxGeometry(0.6 * scale, 0.5 * scale, 0.8 * scale), headMat);
                        head.position.set(0, 1.3 * scale, -1.2 * scale);
                        this.mesh.add(head);
                        // Wings
                        const wingMat = new THREE.MeshLambertMaterial({ color: 0x550055, side: THREE.DoubleSide });
                        const leftWing = new THREE.Mesh(new THREE.PlaneGeometry(2 * scale, 1 * scale), wingMat);
                        leftWing.position.set(-1.5 * scale, 1.2 * scale, 0);
                        leftWing.rotation.z = 0.3;
                        this.mesh.add(leftWing);
                        const rightWing = new THREE.Mesh(new THREE.PlaneGeometry(2 * scale, 1 * scale), wingMat);
                        rightWing.position.set(1.5 * scale, 1.2 * scale, 0);
                        rightWing.rotation.z = -0.3;
                        this.mesh.add(rightWing);
                        this.legs.push(leftWing, rightWing);
                        // Glowing eyes
                        const eyeMat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
                        for (let i = -1; i <= 1; i += 2) {
                            const eye = new THREE.Mesh(new THREE.SphereGeometry(0.1 * scale, 6, 6), eyeMat);
                            eye.position.set(i * 0.15 * scale, 1.4 * scale, -1.55 * scale);
                            this.mesh.add(eye);
                        }
                        // Tail
                        const tail = new THREE.Mesh(new THREE.ConeGeometry(0.2 * scale, 1.5 * scale, 6), headMat);
                        tail.position.set(0, 0.8 * scale, 1.5 * scale);
                        tail.rotation.x = Math.PI / 2;
                        this.mesh.add(tail);
                    } else {
                        // Generic flying mob
                        const flyBody = new THREE.Mesh(new THREE.SphereGeometry(0.3 * scale, 8, 8), bodyMat);
                        flyBody.position.y = 0.5 * scale;
                        this.mesh.add(flyBody);
                        this.body = flyBody;
                    }
                } else if (this.data.worm) {
                    // Worm - segmented body
                    const segmentMat = new THREE.MeshLambertMaterial({ color: this.data.color });
                    for (let i = 0; i < 8; i++) {
                        const segment = new THREE.Mesh(new THREE.SphereGeometry(0.25 * scale * (1 - i * 0.08), 8, 8), segmentMat);
                        segment.position.set(0, 0.3 * scale, i * 0.35 * scale);
                        this.mesh.add(segment);
                        if (i === 0) this.body = segment;
                        this.legs.push(segment);
                    }
                    // Head with mandibles
                    const headSeg = new THREE.Mesh(new THREE.SphereGeometry(0.3 * scale, 8, 8), segmentMat);
                    headSeg.position.set(0, 0.35 * scale, -0.35 * scale);
                    this.mesh.add(headSeg);
                    const mandibleMat = new THREE.MeshLambertMaterial({ color: 0x442211 });
                    for (let i = -1; i <= 1; i += 2) {
                        const mandible = new THREE.Mesh(new THREE.ConeGeometry(0.08 * scale, 0.25 * scale, 4), mandibleMat);
                        mandible.position.set(i * 0.15 * scale, 0.25 * scale, -0.55 * scale);
                        mandible.rotation.x = Math.PI / 2;
                        mandible.rotation.z = i * 0.5;
                        this.mesh.add(mandible);
                    }
                } else if (this.data.fish) {
                    // Fish - streamlined body
                    const fishMat = new THREE.MeshLambertMaterial({ color: this.data.color });
                    const fishBody = new THREE.Mesh(new THREE.SphereGeometry(0.2 * scale, 8, 8), fishMat);
                    fishBody.scale.set(0.6, 0.8, 1.5);
                    fishBody.position.y = 0.2 * scale;
                    this.mesh.add(fishBody);
                    this.body = fishBody;
                    // Tail fin
                    const tailMat = new THREE.MeshLambertMaterial({ color: this.data.color, side: THREE.DoubleSide });
                    const tail = new THREE.Mesh(new THREE.PlaneGeometry(0.15 * scale, 0.2 * scale), tailMat);
                    tail.position.set(0, 0.2 * scale, 0.25 * scale);
                    this.mesh.add(tail);
                    this.legs.push(tail);
                    // Eye
                    const eye = new THREE.Mesh(new THREE.SphereGeometry(0.04 * scale, 6, 6), new THREE.MeshBasicMaterial({ color: 0x000000 }));
                    eye.position.set(0.08 * scale, 0.22 * scale, -0.15 * scale);
                    this.mesh.add(eye);
                } else if (this.data.fluffy) {
                    // Sheep - fluffy wool body
                    const woolMat = new THREE.MeshLambertMaterial({ color: this.data.color });
                    const woolBody = new THREE.Mesh(new THREE.BoxGeometry(0.7 * scale, 0.6 * scale, 1 * scale), woolMat);
                    woolBody.position.y = 0.6 * scale;
                    this.mesh.add(woolBody);
                    this.body = woolBody;

                    // Fluffy bumps
                    for (let i = 0; i < 8; i++) {
                        const bump = new THREE.Mesh(new THREE.SphereGeometry(0.15 * scale, 6, 6), woolMat);
                        bump.position.set((Math.random() - 0.5) * 0.5 * scale, 0.9 * scale, (Math.random() - 0.5) * 0.7 * scale);
                        this.mesh.add(bump);
                    }

                    // Dark face
                    const faceMat = new THREE.MeshLambertMaterial({ color: 0x333333 });
                    const face = new THREE.Mesh(new THREE.BoxGeometry(0.35 * scale, 0.35 * scale, 0.3 * scale), faceMat);
                    face.position.set(0, 0.65 * scale, -0.55 * scale);
                    this.mesh.add(face);

                    // Legs
                    const legMat = new THREE.MeshLambertMaterial({ color: 0x333333 });
                    const legPositions = [[-0.2, 0.2, -0.3], [0.2, 0.2, -0.3], [-0.2, 0.2, 0.3], [0.2, 0.2, 0.3]];
                    for (const [x, y, z] of legPositions) {
                        const leg = new THREE.Mesh(new THREE.BoxGeometry(0.12 * scale, 0.4 * scale, 0.12 * scale), legMat);
                        leg.position.set(x * scale, y * scale, z * scale);
                        this.mesh.add(leg);
                        this.legs.push(leg);
                    }
                } else {
                    // Standard quadruped (pig, cow, zombie, etc.)
                    const bodyGeom = new THREE.BoxGeometry(0.6 * scale, 0.5 * scale, 0.9 * scale);
                    const body = new THREE.Mesh(bodyGeom, bodyMat);
                    body.position.y = 0.5 * scale;
                    this.mesh.add(body);
                    this.body = body;

                    // Head
                    const headGeom = new THREE.BoxGeometry(0.5 * scale, 0.5 * scale, 0.5 * scale);
                    const head = new THREE.Mesh(headGeom, bodyMat);
                    head.position.set(0, 0.8 * scale, -0.5 * scale);
                    this.mesh.add(head);
                    this.head = head;

                    // Boss indicator - bigger, meaner
                    if (this.data.boss) {
                        // Glowing eyes
                        const eyeGeom = new THREE.BoxGeometry(0.15 * scale, 0.1 * scale, 0.05 * scale);
                        const eyeMat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
                        const leftEye = new THREE.Mesh(eyeGeom, eyeMat);
                        leftEye.position.set(-0.12 * scale, 0.85 * scale, -0.77 * scale);
                        this.mesh.add(leftEye);
                        const rightEye = new THREE.Mesh(eyeGeom, eyeMat);
                        rightEye.position.set(0.12 * scale, 0.85 * scale, -0.77 * scale);
                        this.mesh.add(rightEye);

                        // Spikes
                        const spikeMat = new THREE.MeshLambertMaterial({ color: 0x440000 });
                        for (let i = 0; i < 5; i++) {
                            const spike = new THREE.Mesh(new THREE.ConeGeometry(0.08 * scale, 0.3 * scale, 4), spikeMat);
                            spike.position.set(0, 0.9 * scale, -0.2 * scale + i * 0.25 * scale);
                            this.mesh.add(spike);
                        }
                    } else if (this.data.hostile) {
                        // Red eyes for hostile
                        const eyeGeom = new THREE.BoxGeometry(0.1 * scale, 0.1 * scale, 0.05 * scale);
                        const eyeMat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
                        const leftEye = new THREE.Mesh(eyeGeom, eyeMat);
                        leftEye.position.set(-0.12 * scale, 0.85 * scale, -0.77 * scale);
                        this.mesh.add(leftEye);
                        const rightEye = new THREE.Mesh(eyeGeom, eyeMat);
                        rightEye.position.set(0.12 * scale, 0.85 * scale, -0.77 * scale);
                        this.mesh.add(rightEye);
                    } else {
                        // Cute eyes for passive
                        const eyeGeom = new THREE.SphereGeometry(0.06 * scale, 6, 6);
                        const eyeMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
                        const leftEye = new THREE.Mesh(eyeGeom, eyeMat);
                        leftEye.position.set(-0.1 * scale, 0.85 * scale, -0.75 * scale);
                        this.mesh.add(leftEye);
                        const rightEye = new THREE.Mesh(eyeGeom, eyeMat);
                        rightEye.position.set(0.1 * scale, 0.85 * scale, -0.75 * scale);
                        this.mesh.add(rightEye);
                    }

                    // Snout for pig
                    if (this.type === 'PIG') {
                        const snout = new THREE.Mesh(new THREE.BoxGeometry(0.25 * scale, 0.15 * scale, 0.1 * scale), new THREE.MeshLambertMaterial({ color: 0xffcccc }));
                        snout.position.set(0, 0.7 * scale, -0.78 * scale);
                        this.mesh.add(snout);
                    }

                    // Horns for cow
                    if (this.type === 'COW') {
                        const hornMat = new THREE.MeshLambertMaterial({ color: 0xddddcc });
                        const leftHorn = new THREE.Mesh(new THREE.ConeGeometry(0.05 * scale, 0.2 * scale, 6), hornMat);
                        leftHorn.position.set(-0.2 * scale, 1.1 * scale, -0.5 * scale);
                        leftHorn.rotation.z = 0.4;
                        this.mesh.add(leftHorn);
                        const rightHorn = new THREE.Mesh(new THREE.ConeGeometry(0.05 * scale, 0.2 * scale, 6), hornMat);
                        rightHorn.position.set(0.2 * scale, 1.1 * scale, -0.5 * scale);
                        rightHorn.rotation.z = -0.4;
                        this.mesh.add(rightHorn);
                    }

                    // Charged Creeper - electric aura
                    if (this.type === 'CHARGED_CREEPER') {
                        const auraMat = new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.3 });
                        const aura = new THREE.Mesh(new THREE.SphereGeometry(0.7 * scale, 8, 8), auraMat);
                        aura.position.y = 0.6 * scale;
                        this.mesh.add(aura);
                        this.aura = aura;
                    }

                    // TNT Zombie - TNT block for head
                    if (this.type === 'TNT_ZOMBIE') {
                        this.head.material = new THREE.MeshLambertMaterial({ color: 0xff2200 });
                        const stripe = new THREE.Mesh(new THREE.BoxGeometry(0.52 * scale, 0.15 * scale, 0.52 * scale), new THREE.MeshLambertMaterial({ color: 0xffffff }));
                        stripe.position.set(0, 0.8 * scale, -0.5 * scale);
                        this.mesh.add(stripe);
                    }

                    // Witch - hat and robe
                    if (this.type === 'WITCH' || this.data.witch) {
                        const hatMat = new THREE.MeshLambertMaterial({ color: 0x220022 });
                        const hatBrim = new THREE.Mesh(new THREE.CylinderGeometry(0.4 * scale, 0.4 * scale, 0.05 * scale, 8), hatMat);
                        hatBrim.position.set(0, 1.1 * scale, -0.5 * scale);
                        this.mesh.add(hatBrim);
                        const hatTop = new THREE.Mesh(new THREE.ConeGeometry(0.25 * scale, 0.5 * scale, 8), hatMat);
                        hatTop.position.set(0, 1.4 * scale, -0.5 * scale);
                        this.mesh.add(hatTop);
                        // Warty nose
                        const nose = new THREE.Mesh(new THREE.ConeGeometry(0.08 * scale, 0.2 * scale, 6), new THREE.MeshLambertMaterial({ color: 0x55aa55 }));
                        nose.position.set(0, 0.75 * scale, -0.8 * scale);
                        nose.rotation.x = Math.PI / 2;
                        this.mesh.add(nose);
                    }

                    // Enderman - tall and slender
                    if (this.type === 'ENDERMAN' || this.data.tall) {
                        this.body.scale.set(0.6, 2, 0.6);
                        this.body.position.y = 1 * scale;
                        this.head.position.y = 2 * scale;
                        // Purple eyes
                        const eyeMat = new THREE.MeshBasicMaterial({ color: 0xff00ff });
                        const leftEye = new THREE.Mesh(new THREE.BoxGeometry(0.15 * scale, 0.05 * scale, 0.02 * scale), eyeMat);
                        leftEye.position.set(-0.1 * scale, 2.05 * scale, -0.77 * scale);
                        this.mesh.add(leftEye);
                        const rightEye = new THREE.Mesh(new THREE.BoxGeometry(0.15 * scale, 0.05 * scale, 0.02 * scale), eyeMat);
                        rightEye.position.set(0.1 * scale, 2.05 * scale, -0.77 * scale);
                        this.mesh.add(rightEye);
                        // Particles
                        for (let i = 0; i < 5; i++) {
                            const particle = new THREE.Mesh(new THREE.BoxGeometry(0.05 * scale, 0.05 * scale, 0.05 * scale), new THREE.MeshBasicMaterial({ color: 0x880088 }));
                            particle.position.set((Math.random() - 0.5) * scale, Math.random() * 2 * scale, (Math.random() - 0.5) * scale);
                            this.mesh.add(particle);
                        }
                    }

                    // Golem - chunky and armored
                    if (this.type === 'GOLEM') {
                        this.body.scale.set(1.5, 1.5, 1.2);
                        this.head.scale.set(1.3, 1.3, 1.3);
                        // Armor plates
                        const armorMat = new THREE.MeshLambertMaterial({ color: 0x555555 });
                        const chest = new THREE.Mesh(new THREE.BoxGeometry(0.7 * scale, 0.4 * scale, 0.3 * scale), armorMat);
                        chest.position.set(0, 0.7 * scale, -0.6 * scale);
                        this.mesh.add(chest);
                    }

                    // Hydra - multiple heads
                    if (this.type === 'HYDRA' || this.data.multiHead) {
                        for (let i = -1; i <= 1; i++) {
                            if (i === 0) continue;
                            const extraHead = new THREE.Mesh(new THREE.BoxGeometry(0.4 * scale, 0.4 * scale, 0.5 * scale), bodyMat);
                            extraHead.position.set(i * 0.5 * scale, 0.7 * scale, -0.7 * scale);
                            this.mesh.add(extraHead);
                            const eye = new THREE.Mesh(new THREE.SphereGeometry(0.08 * scale, 6, 6), new THREE.MeshBasicMaterial({ color: 0xff0000 }));
                            eye.position.set(i * 0.5 * scale, 0.75 * scale, -0.95 * scale);
                            this.mesh.add(eye);
                        }
                    }

                    // Titan - massive with ground shake
                    if (this.type === 'TITAN') {
                        // Extra armor
                        const armorMat = new THREE.MeshLambertMaterial({ color: 0x443322 });
                        const shoulder1 = new THREE.Mesh(new THREE.BoxGeometry(0.5 * scale, 0.3 * scale, 0.5 * scale), armorMat);
                        shoulder1.position.set(-0.5 * scale, 0.8 * scale, 0);
                        this.mesh.add(shoulder1);
                        const shoulder2 = new THREE.Mesh(new THREE.BoxGeometry(0.5 * scale, 0.3 * scale, 0.5 * scale), armorMat);
                        shoulder2.position.set(0.5 * scale, 0.8 * scale, 0);
                        this.mesh.add(shoulder2);
                    }

                    // Mimic - chest appearance
                    if (this.type === 'MIMIC' || this.data.mimic) {
                        this.body.material = new THREE.MeshLambertMaterial({ color: 0x8b4513 });
                        // Chest lid
                        const lid = new THREE.Mesh(new THREE.BoxGeometry(0.65 * scale, 0.1 * scale, 0.5 * scale), new THREE.MeshLambertMaterial({ color: 0x8b4513 }));
                        lid.position.set(0, 0.8 * scale, 0);
                        this.mesh.add(lid);
                        // Gold trim
                        const trim = new THREE.Mesh(new THREE.BoxGeometry(0.15 * scale, 0.15 * scale, 0.1 * scale), new THREE.MeshLambertMaterial({ color: 0xffd700 }));
                        trim.position.set(0, 0.55 * scale, -0.48 * scale);
                        this.mesh.add(trim);
                        // Teeth
                        const toothMat = new THREE.MeshLambertMaterial({ color: 0xffffee });
                        for (let i = -2; i <= 2; i++) {
                            const tooth = new THREE.Mesh(new THREE.ConeGeometry(0.04 * scale, 0.15 * scale, 4), toothMat);
                            tooth.position.set(i * 0.12 * scale, 0.65 * scale, -0.48 * scale);
                            tooth.rotation.x = Math.PI;
                            this.mesh.add(tooth);
                        }
                    }

                    // Ice Elemental - crystalline
                    if (this.type === 'ICE_ELEMENTAL' || this.data.freezes) {
                        const iceMat = new THREE.MeshLambertMaterial({ color: 0x88ddff, transparent: true, opacity: 0.7 });
                        this.body.material = iceMat;
                        // Ice crystals
                        for (let i = 0; i < 4; i++) {
                            const crystal = new THREE.Mesh(new THREE.OctahedronGeometry(0.15 * scale), iceMat);
                            crystal.position.set((Math.random() - 0.5) * 0.5 * scale, 0.8 * scale + Math.random() * 0.3 * scale, (Math.random() - 0.5) * 0.5 * scale);
                            crystal.rotation.set(Math.random(), Math.random(), Math.random());
                            this.mesh.add(crystal);
                        }
                    }

                    // Horse - longer body, mane
                    if (this.type === 'HORSE' || this.data.horse) {
                        this.body.scale.set(0.8, 1, 1.4);
                        // Mane
                        const maneMat = new THREE.MeshLambertMaterial({ color: 0x332211 });
                        for (let i = 0; i < 5; i++) {
                            const maneSegment = new THREE.Mesh(new THREE.BoxGeometry(0.05 * scale, 0.2 * scale, 0.1 * scale), maneMat);
                            maneSegment.position.set(0, 0.95 * scale, -0.35 * scale + i * 0.15 * scale);
                            this.mesh.add(maneSegment);
                        }
                        // Ears
                        const ear1 = new THREE.Mesh(new THREE.ConeGeometry(0.06 * scale, 0.15 * scale, 4), bodyMat);
                        ear1.position.set(-0.12 * scale, 1.1 * scale, -0.5 * scale);
                        this.mesh.add(ear1);
                        const ear2 = new THREE.Mesh(new THREE.ConeGeometry(0.06 * scale, 0.15 * scale, 4), bodyMat);
                        ear2.position.set(0.12 * scale, 1.1 * scale, -0.5 * scale);
                        this.mesh.add(ear2);
                    }

                    // Turtle - shell
                    if (this.type === 'TURTLE' || this.data.armored) {
                        const shellMat = new THREE.MeshLambertMaterial({ color: 0x336633 });
                        const shell = new THREE.Mesh(new THREE.SphereGeometry(0.45 * scale, 8, 6), shellMat);
                        shell.position.y = 0.55 * scale;
                        shell.scale.set(1.2, 0.6, 1.4);
                        this.mesh.add(shell);
                    }

                    // Penguin - tuxedo pattern
                    if (this.type === 'PENGUIN' || this.data.waddle) {
                        // White belly
                        const bellyMat = new THREE.MeshLambertMaterial({ color: 0xffffff });
                        const belly = new THREE.Mesh(new THREE.BoxGeometry(0.35 * scale, 0.45 * scale, 0.2 * scale), bellyMat);
                        belly.position.set(0, 0.5 * scale, -0.28 * scale);
                        this.mesh.add(belly);
                        // Orange beak
                        const beak = new THREE.Mesh(new THREE.ConeGeometry(0.08 * scale, 0.15 * scale, 4), new THREE.MeshLambertMaterial({ color: 0xff8800 }));
                        beak.position.set(0, 0.7 * scale, -0.8 * scale);
                        beak.rotation.x = Math.PI / 2;
                        this.mesh.add(beak);
                    }

                    // Magma Cube - glowing core
                    if (this.data.glowing) {
                        this.body.material = new THREE.MeshBasicMaterial({ color: this.data.color });
                    }

                    // Legs
                    const legGeom = new THREE.BoxGeometry(0.15 * scale, 0.4 * scale, 0.15 * scale);
                    const legMat = new THREE.MeshLambertMaterial({ color: this.data.color });
                    const legPositions = [[-0.15, 0.2, -0.25], [0.15, 0.2, -0.25], [-0.15, 0.2, 0.25], [0.15, 0.2, 0.25]];
                    for (const [x, y, z] of legPositions) {
                        const leg = new THREE.Mesh(legGeom, legMat);
                        leg.position.set(x * scale, y * scale, z * scale);
                        this.mesh.add(leg);
                        this.legs.push(leg);
                    }
                }

                this.mesh.position.copy(this.position);
                this.scene.add(this.mesh);
            }

            takeDamage(amount, knockbackDir = null) {
                if (this.dead) return;
                this.health -= amount;
                this.hurtTimer = 0.2;

                // Flash red
                this.mesh.traverse(c => {
                    if (c.material) c.material.emissive = new THREE.Color(0xff0000);
                });

                // Knockback
                if (knockbackDir) {
                    this.velocity.add(knockbackDir.clone().multiplyScalar(8));
                    this.velocity.y = 5;
                }

                if (this.health <= 0) {
                    this.die();
                }
            }

            die() {
                this.dead = true;
                this.deathTimer = 1.0;
                this.velocity.set(0, 5, 0);
            }

            update(dt, playerPos, isNight) {
                if (this.dead) {
                    this.deathTimer -= dt;
                    this.mesh.rotation.z += dt * 5;
                    this.mesh.position.y -= dt * 2;
                    this.mesh.scale.setScalar(Math.max(0.1, this.deathTimer));

                    // Slimes split on death
                    if (this.deathTimer <= 0 && this.data.splits && (this.data.scale || 1) > 0.8) {
                        return { split: true, position: this.position.clone(), scale: (this.data.scale || 1) / 2 };
                    }
                    return this.deathTimer <= 0;
                }

                // Hurt flash timer
                if (this.hurtTimer > 0) {
                    this.hurtTimer -= dt;
                    if (this.hurtTimer <= 0) {
                        this.mesh.traverse(c => {
                            if (c.material && c.material.emissive) c.material.emissive = new THREE.Color(0x000000);
                        });
                    }
                }

                this.attackCooldown -= dt;

                // AI behavior
                const aiResult = this.data.hostile ? this.hostileAI(dt, playerPos, isNight) : this.passiveAI(dt, playerPos);

                // Flying mobs don't use gravity the same way
                if (this.data.flying) {
                    // Hover with slight bobbing
                    this.hoverOffset = (this.hoverOffset || 0) + dt * 3;
                    const targetY = this.position.y + Math.sin(this.hoverOffset) * 0.02;
                    this.velocity.y *= 0.9;

                    // Fly towards player height
                    const heightDiff = playerPos.y + 2 - this.position.y;
                    this.velocity.y += Math.sign(heightDiff) * Math.min(Math.abs(heightDiff), 5) * dt * 3;
                } else if (this.data.bouncy) {
                    // Slimes bounce
                    if (this.onGround) {
                        this.velocity.y = 8 + Math.random() * 4;
                        this.onGround = false;
                    }
                    this.velocity.y -= 20 * dt;
                } else {
                    // Normal gravity
                    this.velocity.y -= 25 * dt;
                }
                this.velocity.y = Math.max(this.velocity.y, -30);

                // Apply friction
                this.velocity.x *= 0.9;
                this.velocity.z *= 0.9;

                // Move with collision
                if (this.data.flying) {
                    this.moveFlying(dt);
                } else {
                    this.moveWithCollision(dt);
                }

                // Update mesh position
                this.mesh.position.copy(this.position);

                // Animate based on type
                const speed = Math.sqrt(this.velocity.x ** 2 + this.velocity.z ** 2);
                const time = performance.now() * 0.01;

                if (this.data.bouncy && this.body) {
                    // Squash and stretch for slimes
                    const squash = 1 + Math.sin(time * 5) * 0.1;
                    this.body.scale.set(squash, 1 / squash, squash);
                } else if (this.data.flying && this.legs.length > 0) {
                    // Wing flapping or rod spinning
                    if (this.type === 'BLAZE') {
                        this.mesh.rotation.y += dt * 2;
                    } else {
                        for (let i = 0; i < this.legs.length; i++) {
                            this.legs[i].rotation.z = Math.sin(time * 10 + i) * 0.5;
                        }
                    }
                    // Bomber spark flicker
                    if (this.spark) {
                        this.spark.visible = Math.random() > 0.3;
                        this.spark.scale.setScalar(0.8 + Math.random() * 0.4);
                    }
                } else if (this.data.spider && this.legs.length >= 8) {
                    // Spider leg animation
                    for (let i = 0; i < 8; i++) {
                        this.legs[i].rotation.z = (i < 4 ? -1 : 1) * (Math.PI / 3 + Math.sin(time * speed + i * 0.5) * 0.3);
                    }
                } else if (this.legs.length >= 4 && speed > 0.5) {
                    // Normal walk cycle
                    const walkCycle = time * speed;
                    this.legs[0].rotation.x = Math.sin(walkCycle) * 0.5;
                    this.legs[1].rotation.x = -Math.sin(walkCycle) * 0.5;
                    this.legs[2].rotation.x = -Math.sin(walkCycle) * 0.5;
                    this.legs[3].rotation.x = Math.sin(walkCycle) * 0.5;
                }

                // Face movement direction
                if (speed > 0.1) {
                    const targetYaw = Math.atan2(this.velocity.x, this.velocity.z);
                    this.mesh.rotation.y = targetYaw;
                }

                // Despawn if too far
                const dist = this.position.distanceTo(playerPos);
                return dist > 80;
            }

            passiveAI(dt, playerPos) {
                // Run away if player is too close
                const dist = this.position.distanceTo(playerPos);
                if (dist < 5) {
                    const awayDir = this.position.clone().sub(playerPos).normalize();
                    this.velocity.x = awayDir.x * this.data.speed * 1.5;
                    this.velocity.z = awayDir.z * this.data.speed * 1.5;
                    return;
                }

                // Wander randomly
                this.wanderTimer -= dt;
                if (this.wanderTimer <= 0) {
                    this.wanderTimer = 2 + Math.random() * 3;
                    if (Math.random() < 0.5) {
                        const angle = Math.random() * Math.PI * 2;
                        this.wanderDir.set(Math.cos(angle), 0, Math.sin(angle));
                    } else {
                        this.wanderDir.set(0, 0, 0);
                    }
                }

                this.velocity.x = this.wanderDir.x * this.data.speed;
                this.velocity.z = this.wanderDir.z * this.data.speed;

                // Random jump
                if (this.onGround && Math.random() < 0.01) {
                    this.velocity.y = 6;
                    this.onGround = false;
                }
            }

            hostileAI(dt, playerPos, isNight) {
                const dist = this.position.distanceTo(playerPos);

                // Only chase during night or if very close
                if (!isNight && dist > 10) {
                    this.passiveAI(dt, playerPos);
                    return;
                }

                // Flying mobs circle and swoop
                if (this.data.flying) {
                    const toPlayer = playerPos.clone().sub(this.position);
                    toPlayer.y = 0;
                    toPlayer.normalize();

                    if (dist < 25 && dist > 4) {
                        // Circle around player
                        const circleAngle = Math.atan2(toPlayer.z, toPlayer.x) + Math.PI / 2;
                        this.velocity.x = Math.cos(circleAngle) * this.data.speed * 0.7 + toPlayer.x * this.data.speed * 0.5;
                        this.velocity.z = Math.sin(circleAngle) * this.data.speed * 0.7 + toPlayer.z * this.data.speed * 0.5;
                    } else if (dist <= 4) {
                        // Swoop in
                        this.velocity.x = toPlayer.x * this.data.speed * 1.5;
                        this.velocity.z = toPlayer.z * this.data.speed * 1.5;
                    }

                    // Blaze shoots fireballs
                    if (this.data.shoots && dist < 15 && this.attackCooldown <= 0) {
                        this.attackCooldown = 2.0;
                        return { shoot: true, position: this.position.clone(), target: playerPos.clone(), damage: this.data.damage };
                    }

                    // Bomber dives to explode
                    if (this.data.explodes && dist < 4) {
                        this.velocity.y = -10; // Dive down
                        if (dist < 2.5) {
                            this.health = 0;
                            return { explode: true, position: this.position.clone() };
                        }
                    }

                    // Ghost phases through and attacks
                    if (this.data.transparent && dist < 2.5 && this.attackCooldown <= 0) {
                        this.attackCooldown = 1.5;
                        return { attack: true, damage: this.data.damage };
                    }

                    return null;
                }

                // Chase player
                if (dist < 30 && dist > 2) {
                    const toPlayer = playerPos.clone().sub(this.position).normalize();
                    this.velocity.x = toPlayer.x * this.data.speed;
                    this.velocity.z = toPlayer.z * this.data.speed;

                    // Jump if blocked
                    if (this.onGround && this.isBlocked()) {
                        this.velocity.y = 7;
                        this.onGround = false;
                    }
                }

                // Wolves attack from the side
                if (this.data.pack && dist < 20 && dist > 2) {
                    const toPlayer = playerPos.clone().sub(this.position);
                    const flankAngle = Math.atan2(toPlayer.z, toPlayer.x) + (Math.random() > 0.5 ? 0.5 : -0.5);
                    this.velocity.x = Math.cos(flankAngle) * this.data.speed;
                    this.velocity.z = Math.sin(flankAngle) * this.data.speed;
                }

                // Enderman teleports when hit or randomly
                if (this.data.teleports && (this.hurtTimer > 0 || (dist < 5 && Math.random() < 0.02))) {
                    const teleportDist = 5 + Math.random() * 10;
                    const teleportAngle = Math.random() * Math.PI * 2;
                    this.position.x += Math.cos(teleportAngle) * teleportDist;
                    this.position.z += Math.sin(teleportAngle) * teleportDist;
                    this.mesh.position.copy(this.position);
                }

                // Witch shoots potions from range
                if (this.data.witch && dist < 12 && dist > 3 && this.attackCooldown <= 0) {
                    this.attackCooldown = 2.5;
                    return { shoot: true, position: this.position.clone().add(new THREE.Vector3(0, 1, 0)), target: playerPos.clone(), damage: this.data.damage };
                }

                // Worm burrows and surfaces
                if (this.data.worm && dist < 15) {
                    if (Math.random() < 0.01) {
                        // Burrow underground briefly
                        this.position.y -= 2;
                        setTimeout(() => {
                            this.position.y += 2;
                            this.position.x += (Math.random() - 0.5) * 6;
                            this.position.z += (Math.random() - 0.5) * 6;
                        }, 500);
                    }
                }

                // Titan earthquake stomp
                if (this.data.earthquake && dist < 8 && this.attackCooldown <= 0 && this.onGround) {
                    this.attackCooldown = 3.0;
                    return { earthquake: true, position: this.position.clone(), damage: this.data.damage * 0.5 };
                }

                // Hydra multi-attack
                if (this.data.multiHead && dist < 10 && this.attackCooldown <= 0) {
                    this.attackCooldown = 1.5;
                    // Triple fireball
                    return { multiShoot: true, position: this.position.clone().add(new THREE.Vector3(0, 0.8, 0)), target: playerPos.clone(), damage: this.data.damage };
                }

                // Big explosion for charged creeper
                if (this.data.bigExplosion && dist < 3) {
                    this.health = 0;
                    return { bigExplode: true, position: this.position.clone() };
                }

                // Attack if close enough
                if (dist < 2 && this.attackCooldown <= 0) {
                    this.attackCooldown = 1.0;
                    return { attack: true, damage: this.data.damage };
                }

                // Ground-based explosives (creeper)
                if (this.data.explodes && !this.data.flying && !this.data.bigExplosion && dist < 3) {
                    this.health = 0;
                    return { explode: true, position: this.position.clone() };
                }

                return null;
            }

            isBlocked() {
                const checkPos = this.position.clone().add(new THREE.Vector3(
                    Math.sign(this.velocity.x) * 0.5,
                    0.5,
                    Math.sign(this.velocity.z) * 0.5
                ));
                return this.world.isSolid(checkPos.x, checkPos.y, checkPos.z);
            }

            moveFlying(dt) {
                // Flying mobs can pass through air freely
                this.position.x += this.velocity.x * dt;
                this.position.y += this.velocity.y * dt;
                this.position.z += this.velocity.z * dt;

                // Keep above ground
                if (this.position.y < 5) this.position.y = 5;
                if (this.position.y > CONFIG.WORLD_HEIGHT - 10) this.position.y = CONFIG.WORLD_HEIGHT - 10;
            }

            moveWithCollision(dt) {
                // X movement
                const newX = this.position.x + this.velocity.x * dt;
                if (!this.checkCollision(newX, this.position.y, this.position.z)) {
                    this.position.x = newX;
                } else {
                    this.velocity.x = 0;
                }

                // Z movement
                const newZ = this.position.z + this.velocity.z * dt;
                if (!this.checkCollision(this.position.x, this.position.y, newZ)) {
                    this.position.z = newZ;
                } else {
                    this.velocity.z = 0;
                }

                // Y movement
                const newY = this.position.y + this.velocity.y * dt;
                if (!this.checkCollision(this.position.x, newY, this.position.z)) {
                    this.position.y = newY;
                    this.onGround = false;
                } else {
                    if (this.velocity.y < 0) this.onGround = true;
                    this.velocity.y = 0;
                }
            }

            checkCollision(x, y, z) {
                const hw = 0.3;
                const points = [
                    [x - hw, y, z - hw], [x + hw, y, z - hw],
                    [x - hw, y, z + hw], [x + hw, y, z + hw],
                    [x - hw, y + 0.5, z - hw], [x + hw, y + 0.5, z - hw],
                    [x - hw, y + 0.5, z + hw], [x + hw, y + 0.5, z + hw],
                    [x - hw, y + 1, z - hw], [x + hw, y + 1, z - hw],
                    [x - hw, y + 1, z + hw], [x + hw, y + 1, z + hw]
                ];
                for (const [px, py, pz] of points) {
                    if (this.world.isSolid(px, py, pz)) return true;
                }
                return false;
            }

            dispose() {
                this.scene.remove(this.mesh);
                this.mesh.traverse(c => {
                    if (c.geometry) c.geometry.dispose();
                    if (c.material) c.material.dispose();
                });
            }
        }

        class EntityManager {
            constructor(scene, world, audio) {
                this.scene = scene;
                this.world = world;
                this.audio = audio;
                this.entities = [];
                this.spawnTimer = 0;
                this.maxEntities = 50;
            }

            update(dt, playerPos, isNight, projectileSystem) {
                // Client mode: only interpolate entities, don't run AI
                const isNetClient = this.game && this.game.networkManager && !this.game.networkManager.isHost && this.game.isMultiplayer;
                if (isNetClient) {
                    for (let i = this.entities.length - 1; i >= 0; i--) {
                        const entity = this.entities[i];
                        // Interpolate toward network target
                        if (entity.networkTarget) {
                            entity.position.lerp(entity.networkTarget, dt * 10);
                            if (entity.networkYaw !== null) entity.mesh.rotation.y = entity.networkYaw;
                        }
                        // Handle death animation
                        if (entity.dead) {
                            entity.deathTimer -= dt;
                            if (entity.deathTimer <= 0) {
                                entity.dispose();
                                this.entities.splice(i, 1);
                            } else if (entity.mesh) {
                                entity.mesh.rotation.z = (0.5 - entity.deathTimer) * Math.PI;
                                entity.mesh.position.y -= dt * 2;
                            }
                        } else if (entity.mesh) {
                            entity.mesh.position.copy(entity.position);
                        }
                    }
                    return null;
                }

                this.spawnTimer -= dt;

                // Spawn mobs periodically
                if (this.spawnTimer <= 0 && this.entities.length < this.maxEntities) {
                    this.spawnTimer = 3 + Math.random() * 5;
                    this.spawnNearPlayer(playerPos, isNight);
                }

                // Update all entities
                for (let i = this.entities.length - 1; i >= 0; i--) {
                    const entity = this.entities[i];
                    const result = entity.update(dt, playerPos, isNight);

                    // Check for attacks on local player
                    if (result && result.attack) {
                        // In multiplayer, also check attacks against remote players
                        if (this.game && this.game.networkManager && this.game.networkManager.isHost) {
                            for (const [peerId, rp] of this.game.networkManager.remotePlayers) {
                                const dist = entity.position.distanceTo(rp.position);
                                if (dist < 2.5) {
                                    this.game.networkManager.broadcastPlayerDamage(peerId, result.damage);
                                }
                            }
                        }
                        return { damage: result.damage };
                    }

                    // Check for ranged attacks (Blaze fireballs, Witch potions)
                    if (result && result.shoot) {
                        projectileSystem.shootFireball(result.position, result.target, 15, result.damage);
                    }

                    // Hydra multi-shot
                    if (result && result.multiShoot) {
                        for (let angle = -0.3; angle <= 0.3; angle += 0.3) {
                            const offset = new THREE.Vector3(Math.sin(angle) * 2, 0, Math.cos(angle) * 2);
                            projectileSystem.shootFireball(result.position.clone().add(offset), result.target.clone(), 12, result.damage);
                        }
                    }

                    // Titan earthquake
                    if (result && result.earthquake) {
                        this.audio.play('explode');
                        return { damage: result.damage, earthquake: true };
                    }

                    // Check for explosions
                    if (result && result.explode) {
                        projectileSystem.explode(result.position.x, result.position.y, result.position.z, 3);
                        entity.dispose();
                        this.entities.splice(i, 1);
                        continue;
                    }

                    // Big explosion (charged creeper)
                    if (result && result.bigExplode) {
                        projectileSystem.explode(result.position.x, result.position.y, result.position.z, 6);
                        entity.dispose();
                        this.entities.splice(i, 1);
                        continue;
                    }

                    // Handle slime splitting
                    if (result && result.split) {
                        const splitCount = result.scale > 1.5 ? 4 : 2;
                        for (let j = 0; j < splitCount; j++) {
                            const offset = new THREE.Vector3(
                                (Math.random() - 0.5) * 2,
                                0.5,
                                (Math.random() - 0.5) * 2
                            );
                            const smallSlime = new Entity('SLIME', result.position.clone().add(offset), this.scene, this.world);
                            smallSlime.velocity.set((Math.random() - 0.5) * 8, 6, (Math.random() - 0.5) * 8);
                            // Assign network ID for multiplayer
                            if (this.game && this.game.networkManager) {
                                smallSlime.networkId = this.game.networkManager.getNextEntityNetId();
                                this.game.networkManager.broadcastEntitySpawn(smallSlime);
                            }
                            this.entities.push(smallSlime);
                        }
                        entity.dispose();
                        this.entities.splice(i, 1);
                        continue;
                    }

                    // Remove dead or despawned entities
                    if (result === true) {
                        // Play death sound based on entity type
                        if (entity.data.hostile) {
                            this.audio.play(entity.data.boss ? 'demon_death' : 'gore');
                        }
                        // Broadcast entity death
                        if (entity.networkId && this.game && this.game.networkManager) {
                            this.game.networkManager.broadcastEntityDeath(entity.networkId);
                        }
                        entity.dispose();
                        this.entities.splice(i, 1);
                    }
                }

                return null;
            }

            spawnNearPlayer(playerPos, isNight) {
                // Find spawn position
                const angle = Math.random() * Math.PI * 2;
                const distance = 20 + Math.random() * 20;
                const spawnX = playerPos.x + Math.cos(angle) * distance;
                const spawnZ = playerPos.z + Math.sin(angle) * distance;

                // Find ground level
                let spawnY = -1;
                for (let y = CONFIG.WORLD_HEIGHT - 1; y >= 0; y--) {
                    if (this.world.isSolid(spawnX, y, spawnZ)) {
                        spawnY = y + 1;
                        break;
                    }
                }

                if (spawnY < 0 || spawnY > 100) return;

                // Choose mob type based on time and rarity
                let type;
                const roll = Math.random();

                if (isNight && Math.random() < 0.7) {
                    // Night spawns - mostly hostile
                    if (roll < 0.01 && this.entities.length < 15) {
                        // Ultra rare boss spawn (1% chance)
                        const epicBosses = ['DRAGON', 'TITAN', 'HYDRA'];
                        type = epicBosses[Math.floor(Math.random() * epicBosses.length)];
                        if (type === 'DRAGON') spawnY += 10;
                    } else if (roll < 0.04 && this.entities.length < 20) {
                        // Rare boss spawn (3% chance)
                        const bossTypes = ['MEGA_ZOMBIE', 'KING_SLIME', 'GIANT_SLIME', 'GOLEM'];
                        type = bossTypes[Math.floor(Math.random() * bossTypes.length)];
                    } else if (roll < 0.12) {
                        // Special hostile (8% chance)
                        const specialTypes = ['WITCH', 'ENDERMAN', 'CHARGED_CREEPER', 'TNT_ZOMBIE', 'MIMIC', 'WORM'];
                        type = specialTypes[Math.floor(Math.random() * specialTypes.length)];
                    } else if (roll < 0.22) {
                        // Uncommon mobs (10% chance)
                        const uncommonTypes = ['SPIDER', 'SLIME', 'WOLF', 'MAGMA_CUBE', 'ICE_ELEMENTAL'];
                        type = uncommonTypes[Math.floor(Math.random() * uncommonTypes.length)];
                    } else if (roll < 0.38) {
                        // Flying mobs (16% chance)
                        const flyingTypes = ['BLAZE', 'GHOST', 'BOMBER', 'PHANTOM', 'FIRE_ELEMENTAL', 'BEE'];
                        type = flyingTypes[Math.floor(Math.random() * flyingTypes.length)];
                        spawnY += 5 + Math.random() * 10; // Spawn in air
                    } else {
                        // Common hostile mobs
                        const commonHostile = ['ZOMBIE', 'SKELETON', 'CREEPER', 'ZOMBIE', 'SKELETON', 'ZOMBIE'];
                        type = commonHostile[Math.floor(Math.random() * commonHostile.length)];
                    }
                } else {
                    // Daytime spawns - mostly passive
                    if (roll < 0.03) {
                        // Rare daytime hostile
                        const hostileTypes = ['SPIDER', 'SLIME', 'BEE'];
                        type = hostileTypes[Math.floor(Math.random() * hostileTypes.length)];
                        if (type === 'BEE') spawnY += 3;
                    } else if (roll < 0.08) {
                        // Flying passive
                        const flyingPassive = ['BAT', 'BEE'];
                        type = flyingPassive[Math.floor(Math.random() * flyingPassive.length)];
                        spawnY += 3 + Math.random() * 5;
                    } else {
                        // Passive mobs - expanded
                        const passiveTypes = ['PIG', 'COW', 'CHICKEN', 'SHEEP', 'RABBIT', 'DUCK', 'HORSE', 'FROG', 'TURTLE', 'PENGUIN', 'PIG', 'COW', 'CHICKEN'];
                        type = passiveTypes[Math.floor(Math.random() * passiveTypes.length)];
                    }
                }

                const entity = new Entity(type, new THREE.Vector3(spawnX, spawnY, spawnZ), this.scene, this.world);
                // Assign network ID and broadcast spawn
                if (this.game && this.game.networkManager) {
                    entity.networkId = this.game.networkManager.getNextEntityNetId();
                    this.game.networkManager.broadcastEntitySpawn(entity);
                }
                this.entities.push(entity);

                // Pack/swarm animals spawn in groups
                if ((MOB_TYPES[type].pack || MOB_TYPES[type].swarm) && Math.random() < 0.6) {
                    const groupSize = MOB_TYPES[type].swarm ? 4 + Math.floor(Math.random() * 4) : 2 + Math.floor(Math.random() * 2);
                    for (let i = 0; i < groupSize; i++) {
                        const packOffset = new THREE.Vector3((Math.random() - 0.5) * 4, MOB_TYPES[type].flying ? Math.random() * 2 : 0, (Math.random() - 0.5) * 4);
                        const packMember = new Entity(type, new THREE.Vector3(spawnX, spawnY, spawnZ).add(packOffset), this.scene, this.world);
                        if (this.game && this.game.networkManager) {
                            packMember.networkId = this.game.networkManager.getNextEntityNetId();
                            this.game.networkManager.broadcastEntitySpawn(packMember);
                        }
                        this.entities.push(packMember);
                    }
                }
            }

            damageEntitiesInRadius(position, radius, damage) {
                for (const entity of this.entities) {
                    const dist = entity.position.distanceTo(position);
                    if (dist < radius) {
                        const knockback = entity.position.clone().sub(position).normalize();
                        const dmg = damage * (1 - dist / radius);
                        if (this.game && this.game.networkManager && this.game.networkManager.connected && entity.networkId) {
                            this.game.networkManager.sendDamageEntity(entity.networkId, dmg, knockback);
                        } else {
                            entity.takeDamage(dmg, knockback);
                        }
                    }
                }
            }

            damageEntityAtRay(origin, direction, range, damage) {
                let closestEntity = null;
                let closestDist = range;

                for (const entity of this.entities) {
                    // Simple ray-sphere intersection
                    const toEntity = entity.position.clone().sub(origin);
                    const projection = toEntity.dot(direction);
                    if (projection < 0 || projection > range) continue;

                    const closestPoint = origin.clone().add(direction.clone().multiplyScalar(projection));
                    const dist = entity.position.distanceTo(closestPoint);

                    if (dist < 1 && projection < closestDist) {
                        closestDist = projection;
                        closestEntity = entity;
                    }
                }

                if (closestEntity) {
                    const knockback = direction.clone();
                    // In multiplayer, route damage through network
                    if (this.game && this.game.networkManager && this.game.networkManager.connected && closestEntity.networkId) {
                        this.game.networkManager.sendDamageEntity(closestEntity.networkId, damage, knockback);
                    } else {
                        closestEntity.takeDamage(damage, knockback);
                    }
                    this.audio.play('hit');
                    return true;
                }
                return false;
            }

            getEntityCount() {
                return this.entities.length;
            }

            dispose() {
                for (const entity of this.entities) {
                    entity.dispose();
                }
                this.entities = [];
            }
        }

        // ============================================
        // PLAYER
        // ============================================
        class Player {
            constructor(camera, world) {
                this.camera = camera; this.world = world;
                this.position = new THREE.Vector3(8, 60, 8);
                this.velocity = new THREE.Vector3(0, 0, 0);
                this.yaw = 0; this.pitch = -0.4;
                this.onGround = false; this.sneaking = false;
                this.keys = { forward: false, backward: false, left: false, right: false, jump: false, sneak: false };
                this.hotbar = [
                    'CHAINSAW', 'SWORD', 'SHOTGUN', 'MINIGUN', 'TNT_GUN', 'ROCKET_LAUNCHER',
                    'LASER_GUN', 'PLASMA_CANNON', 'RAILGUN', 'FLAMETHROWER', 'LIGHTNING_STAFF',
                    'FREEZE_RAY', 'BFG', 'NUKE_LAUNCHER', 'BLACK_HOLE', 'GRAVITY_GUN',
                    'GRENADE', 'CLUSTER_BOMB', 'BOW',
                    BLOCKS.WATER, BLOCKS.LAVA, BLOCKS.METAL_FLOOR, BLOCKS.HELL_BRICK, BLOCKS.FLESH,
                    BLOCKS.SKULL_WALL, BLOCKS.PENTAGRAM, BLOCKS.CORRUPTION, BLOCKS.NUKE_BARREL, BLOCKS.TNT
                ];
                this.hotbarIndex = 0;
                this.selectedBlock = null;
                this.creativeMode = false;
                this.flying = false;
                this.health = CONFIG.MAX_HEALTH;
                this.lastY = 60;
                this.fallDistance = 0;
                this.spawnGrace = 1.0;
            }
            get width() { return CONFIG.PLAYER_WIDTH; }
            get height() { return CONFIG.PLAYER_HEIGHT; }

            takeDamage(amount) {
                if (this.creativeMode) return;
                this.health = Math.max(0, this.health - amount);
                if (this.health <= 0) this.respawn();
            }

            heal(amount) {
                this.health = Math.min(CONFIG.MAX_HEALTH, this.health + amount);
            }

            respawn() {
                this.position.set(8, 60, 8);
                this.velocity.set(0, 0, 0);
                this.health = CONFIG.MAX_HEALTH;
                this.fallDistance = 0;
                this.lastY = this.position.y;
                this.spawnGrace = 1.0;
                this.camera.position.set(this.position.x, this.position.y + CONFIG.PLAYER_EYE_HEIGHT, this.position.z);
            }

            toggleCreativeMode() {
                this.creativeMode = !this.creativeMode;
                if (this.creativeMode) {
                    this.health = CONFIG.MAX_HEALTH;
                    this.flying = true;
                } else {
                    this.flying = false;
                }
            }

            update(dt) {
                dt = Math.min(dt, 0.05);
                this.sneaking = this.keys.sneak;
                const moveSpeed = this.flying ? CONFIG.FLY_SPEED : (this.sneaking ? CONFIG.SNEAK_SPEED : CONFIG.MOVE_SPEED);
                const inputDir = new THREE.Vector3(0, 0, 0);
                if (this.keys.forward) inputDir.z -= 1;
                if (this.keys.backward) inputDir.z += 1;
                if (this.keys.left) inputDir.x -= 1;
                if (this.keys.right) inputDir.x += 1;
                if (inputDir.lengthSq() > 0) {
                    inputDir.normalize();
                    const sin = Math.sin(this.yaw), cos = Math.cos(this.yaw);
                    this.velocity.x = (inputDir.x * cos + inputDir.z * sin) * moveSpeed;
                    this.velocity.z = (inputDir.z * cos - inputDir.x * sin) * moveSpeed;
                } else {
                    this.velocity.x *= 0.8; this.velocity.z *= 0.8;
                    if (Math.abs(this.velocity.x) < 0.01) this.velocity.x = 0;
                    if (Math.abs(this.velocity.z) < 0.01) this.velocity.z = 0;
                }

                if (this.flying) {
                    // Flying controls
                    if (this.keys.jump) this.velocity.y = moveSpeed;
                    else if (this.keys.sneak) this.velocity.y = -moveSpeed;
                    else this.velocity.y *= 0.8;
                    if (Math.abs(this.velocity.y) < 0.01) this.velocity.y = 0;
                } else {
                    // Normal gravity
                    if (this.keys.jump && this.onGround) { this.velocity.y = CONFIG.JUMP_FORCE; this.onGround = false; }
                    this.velocity.y -= CONFIG.GRAVITY * dt;
                    this.velocity.y = Math.max(this.velocity.y, -50);
                }

                // Spawn grace period  immune to fall damage briefly after spawn/respawn
                if (this.spawnGrace > 0) {
                    this.spawnGrace -= dt;
                    this.fallDistance = 0;
                }

                // Track fall distance for fall damage
                if (!this.flying && !this.onGround && this.velocity.y < 0) {
                    this.fallDistance += this.lastY - this.position.y;
                }
                this.lastY = this.position.y;

                if (this.flying) {
                    this.moveWithCollisionFlying(dt);
                } else {
                    this.moveWithCollision(dt);
                }

                // Apply fall damage
                if (this.onGround && this.fallDistance > CONFIG.FALL_DAMAGE_THRESHOLD && !this.creativeMode) {
                    const damage = Math.floor(this.fallDistance - CONFIG.FALL_DAMAGE_THRESHOLD);
                    if (damage > 0) this.takeDamage(damage);
                    this.fallDistance = 0;
                } else if (this.onGround) {
                    this.fallDistance = 0;
                }

                this.camera.position.set(this.position.x, this.position.y + CONFIG.PLAYER_EYE_HEIGHT, this.position.z);
                this.camera.rotation.order = 'YXZ';
                this.camera.rotation.y = this.yaw;
                this.camera.rotation.x = this.pitch;
            }

            moveWithCollisionFlying(dt) {
                const newX = this.position.x + this.velocity.x * dt;
                const newY = this.position.y + this.velocity.y * dt;
                const newZ = this.position.z + this.velocity.z * dt;

                if (!this.creativeMode || !this.checkCollisionAt(newX, this.position.y, this.position.z)) {
                    this.position.x = newX;
                }
                if (!this.creativeMode || !this.checkCollisionAt(this.position.x, newY, this.position.z)) {
                    this.position.y = newY;
                }
                if (!this.creativeMode || !this.checkCollisionAt(this.position.x, this.position.y, newZ)) {
                    this.position.z = newZ;
                }

                if (this.position.y < -10) { this.position.y = 60; this.velocity.y = 0; this.fallDistance = 0; this.lastY = 60; this.spawnGrace = 1.0; }
            }
            moveWithCollision(dt) {
                if (this.velocity.x !== 0) {
                    const newX = this.position.x + this.velocity.x * dt;
                    if (!this.checkCollisionAt(newX, this.position.y, this.position.z)) this.position.x = newX;
                    else if (this.onGround) {
                        for (let step = 0.1; step <= CONFIG.STEP_HEIGHT; step += 0.1) {
                            if (!this.checkCollisionAt(newX, this.position.y + step, this.position.z)) {
                                this.position.x = newX; this.position.y += step; break;
                            }
                        }
                        if (this.position.x !== newX) this.velocity.x = 0;
                    } else this.velocity.x = 0;
                }
                if (this.velocity.z !== 0) {
                    const newZ = this.position.z + this.velocity.z * dt;
                    if (!this.checkCollisionAt(this.position.x, this.position.y, newZ)) this.position.z = newZ;
                    else if (this.onGround) {
                        for (let step = 0.1; step <= CONFIG.STEP_HEIGHT; step += 0.1) {
                            if (!this.checkCollisionAt(this.position.x, this.position.y + step, newZ)) {
                                this.position.z = newZ; this.position.y += step; break;
                            }
                        }
                        if (this.position.z !== newZ) this.velocity.z = 0;
                    } else this.velocity.z = 0;
                }
                if (this.velocity.y !== 0) {
                    const newY = this.position.y + this.velocity.y * dt;
                    if (!this.checkCollisionAt(this.position.x, newY, this.position.z)) { this.position.y = newY; this.onGround = false; }
                    else {
                        if (this.velocity.y < 0) { this.onGround = true; for (let i = 0; i < 10; i++) { if (this.checkCollisionAt(this.position.x, this.position.y - 0.05, this.position.z)) break; this.position.y -= 0.05; } }
                        this.velocity.y = 0;
                    }
                }
                if (this.position.y < -10) { this.position.y = 60; this.velocity.y = 0; this.fallDistance = 0; this.lastY = 60; this.spawnGrace = 1.0; }
            }
            checkCollisionAt(x, y, z) {
                const hw = this.width / 2 - 0.01, h = this.height - 0.01;
                const points = [[x-hw,y,z-hw],[x+hw,y,z-hw],[x-hw,y,z+hw],[x+hw,y,z+hw],[x-hw,y+h*0.5,z-hw],[x+hw,y+h*0.5,z-hw],[x-hw,y+h*0.5,z+hw],[x+hw,y+h*0.5,z+hw],[x-hw,y+h,z-hw],[x+hw,y+h,z-hw],[x-hw,y+h,z+hw],[x+hw,y+h,z+hw]];
                for (const [px,py,pz] of points) { if (this.world.isSolid(px,py,pz)) return true; }
                return false;
            }
            getTargetBlock() {
                const rayDir = new THREE.Vector3(0, 0, -1).applyQuaternion(this.camera.quaternion).normalize();
                const rayOrigin = this.camera.position.clone();
                let prevX = Math.floor(rayOrigin.x), prevY = Math.floor(rayOrigin.y), prevZ = Math.floor(rayOrigin.z);
                for (let t = 0; t < CONFIG.REACH_DISTANCE; t += 0.05) {
                    const px = rayOrigin.x + rayDir.x * t, py = rayOrigin.y + rayDir.y * t, pz = rayOrigin.z + rayDir.z * t;
                    const bx = Math.floor(px), by = Math.floor(py), bz = Math.floor(pz);
                    const block = this.world.getBlock(bx, by, bz);
                    if (block !== BLOCKS.AIR && block !== BLOCKS.WATER) return { hit: { x: bx, y: by, z: bz, block }, place: { x: prevX, y: prevY, z: prevZ } };
                    if (bx !== prevX || by !== prevY || bz !== prevZ) { prevX = bx; prevY = by; prevZ = bz; }
                }
                return null;
            }
        }

        // ============================================
        // NAME GENERATOR
        // ============================================
        const PLAYER_ADJECTIVES = ['Cool','Swift','Bold','Lucky','Dark','Iron','Wild','Epic','Mega','Brave','Crazy','Daring','Fierce','Grand','Noble','Rapid','Sharp','Storm','Turbo','Void'];
        const PLAYER_NOUNS = ['Miner','Digger','Builder','Crafter','Steve','Alex','Pickaxe','Creeper','Dragon','Slime','Blaze','Knight','Ghost','Wolf','Hawk','Viper','Titan','Golem','Phoenix','Rex'];
        const SESSION_NAME = PLAYER_ADJECTIVES[Math.floor(Math.random()*PLAYER_ADJECTIVES.length)] + PLAYER_NOUNS[Math.floor(Math.random()*PLAYER_NOUNS.length)] + Math.floor(Math.random()*100);

        // ============================================
        // REMOTE PLAYER
        // ============================================
        class RemotePlayer {
            constructor(id, name, scene) {
                this.id = id;
                this.name = name;
                this.scene = scene;
                this.position = new THREE.Vector3(0, 60, 0);
                this.velocity = new THREE.Vector3();
                this.yaw = 0;
                this.pitch = 0;
                this.health = CONFIG.MAX_HEALTH;
                this.hotbarIndex = 0;
                this.sneaking = false;
                this.flying = false;
                this.joinOrder = 0;
                // Interpolation ring buffer
                this.stateBuffer = [];
                this.interpDelay = 0.1; // 100ms
                this.createMesh();
                this.createNametag();
            }

            createMesh() {
                this.mesh = new THREE.Group();
                const skinColor = 0xc8a882;
                // Deterministic shirt color from name/id so it matches across all clients
                const nameStr = this.name || this.id || '';
                let hash = 0;
                for (let i = 0; i < nameStr.length; i++) hash = ((hash << 5) - hash + nameStr.charCodeAt(i)) | 0;
                const shirtColors = [0x4488cc, 0xcc4444, 0x44cc44, 0xcccc44, 0xcc44cc, 0x44cccc];
                const shirtColor = shirtColors[((hash % shirtColors.length) + shirtColors.length) % shirtColors.length];
                const pantsColor = 0x3344aa;
                // Head
                const headGeo = new THREE.BoxGeometry(0.5, 0.5, 0.5);
                const headMat = new THREE.MeshLambertMaterial({ color: skinColor });
                this.head = new THREE.Mesh(headGeo, headMat);
                this.head.position.y = 1.65;
                this.mesh.add(this.head);
                // Body
                const bodyGeo = new THREE.BoxGeometry(0.5, 0.7, 0.3);
                const bodyMat = new THREE.MeshLambertMaterial({ color: shirtColor });
                this.body = new THREE.Mesh(bodyGeo, bodyMat);
                this.body.position.y = 1.15;
                this.mesh.add(this.body);
                // Left arm
                const armGeo = new THREE.BoxGeometry(0.25, 0.7, 0.25);
                const armMat = new THREE.MeshLambertMaterial({ color: shirtColor });
                this.leftArm = new THREE.Mesh(armGeo, armMat);
                this.leftArm.position.set(-0.375, 1.15, 0);
                this.mesh.add(this.leftArm);
                // Right arm
                this.rightArm = new THREE.Mesh(armGeo, armMat);
                this.rightArm.position.set(0.375, 1.15, 0);
                this.mesh.add(this.rightArm);
                // Left leg
                const legGeo = new THREE.BoxGeometry(0.25, 0.7, 0.25);
                const legMat = new THREE.MeshLambertMaterial({ color: pantsColor });
                this.leftLeg = new THREE.Mesh(legGeo, legMat);
                this.leftLeg.position.set(-0.125, 0.45, 0);
                this.mesh.add(this.leftLeg);
                // Right leg
                this.rightLeg = new THREE.Mesh(legGeo, legMat);
                this.rightLeg.position.set(0.125, 0.45, 0);
                this.mesh.add(this.rightLeg);

                this.scene.add(this.mesh);
            }

            createNametag() {
                const canvas = document.createElement('canvas');
                canvas.width = 256; canvas.height = 64;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = 'rgba(0,0,0,0.5)';
                ctx.fillRect(0, 0, 256, 64);
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 28px Consolas, monospace';
                ctx.textAlign = 'center';
                ctx.fillText(this.name, 128, 42);
                const tex = new THREE.CanvasTexture(canvas);
                const mat = new THREE.SpriteMaterial({ map: tex, transparent: true, depthTest: false });
                this.nametag = new THREE.Sprite(mat);
                this.nametag.scale.set(2, 0.5, 1);
                this.nametag.position.y = 2.1;
                this.mesh.add(this.nametag);
            }

            pushState(state) {
                this.stateBuffer.push({ time: performance.now() / 1000, ...state });
                if (this.stateBuffer.length > 20) this.stateBuffer.shift();
            }

            lerpAngle(a, b, t) {
                let diff = b - a;
                while (diff > Math.PI) diff -= Math.PI * 2;
                while (diff < -Math.PI) diff += Math.PI * 2;
                return a + diff * t;
            }

            interpolate() {
                if (this.stateBuffer.length < 2) {
                    if (this.stateBuffer.length === 1) {
                        const s = this.stateBuffer[0];
                        this.position.set(s.x, s.y, s.z);
                        this.yaw = s.yaw;
                        this.pitch = s.pitch;
                        this.health = s.health;
                        this.hotbarIndex = s.hotbarIndex;
                        this.sneaking = s.sneaking;
                        this.flying = s.flying;
                    }
                    this.updateMesh();
                    return;
                }
                const now = performance.now() / 1000 - this.interpDelay;
                // Find two states to interpolate between
                let i = 0;
                while (i < this.stateBuffer.length - 2 && this.stateBuffer[i + 1].time < now) i++;
                const a = this.stateBuffer[i], b = this.stateBuffer[i + 1];
                const range = b.time - a.time;
                const t = range > 0 ? Math.min(1, Math.max(0, (now - a.time) / range)) : 1;
                this.position.set(
                    a.x + (b.x - a.x) * t,
                    a.y + (b.y - a.y) * t,
                    a.z + (b.z - a.z) * t
                );
                this.yaw = this.lerpAngle(a.yaw, b.yaw, t);
                this.pitch = a.pitch + (b.pitch - a.pitch) * t;
                this.health = b.health;
                this.hotbarIndex = b.hotbarIndex;
                this.sneaking = b.sneaking;
                this.flying = b.flying;
                this.updateMesh();
            }

            updateMesh() {
                this.mesh.position.copy(this.position);
                this.mesh.rotation.y = this.yaw;
                this.head.rotation.x = this.pitch;
                // Walk animation
                const speed = this.velocity.length();
                const walkCycle = performance.now() / 200;
                if (speed > 0.5 || this.stateBuffer.length >= 2) {
                    const swing = Math.sin(walkCycle) * 0.6;
                    this.leftArm.rotation.x = swing;
                    this.rightArm.rotation.x = -swing;
                    this.leftLeg.rotation.x = -swing;
                    this.rightLeg.rotation.x = swing;
                } else {
                    this.leftArm.rotation.x = 0;
                    this.rightArm.rotation.x = 0;
                    this.leftLeg.rotation.x = 0;
                    this.rightLeg.rotation.x = 0;
                }
            }

            dispose() {
                this.scene.remove(this.mesh);
                this.mesh.traverse(child => {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) {
                        if (child.material.map) child.material.map.dispose();
                        child.material.dispose();
                    }
                });
            }
        }

        // ============================================
        // NETWORK MANAGER
        // ============================================
        class NetworkManager {
            constructor(game) {
                this.game = game;
                this.peer = null;
                this.connections = new Map(); // peerId -> DataConnection
                this.remotePlayers = new Map(); // peerId -> RemotePlayer
                this.isHost = false;
                this.hostId = null;
                this.myId = null;
                this.myName = SESSION_NAME;
                this.playerList = []; // ordered by join time: [{id, name, joinOrder}]
                this.nextEntityNetId = 1;
                this.lastPlayerBroadcast = 0;
                this.lastEntityBroadcast = 0;
                this.lastGameStateBroadcast = 0;
                this.lastHeartbeat = 0;
                this.lastHostHeartbeat = 0;
                this.hostHeartbeatTimeout = 3.0; // seconds before migration
                this.connected = false;
                this.entityStateCache = []; // cached for host migration
                this.chatCallback = null;
            }

            generateRoomCode() {
                const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
                let code = '';
                for (let i = 0; i < 6; i++) code += chars[Math.floor(Math.random() * chars.length)];
                return code;
            }

            initAsHost(callback) {
                const roomCode = this.generateRoomCode();
                this.peer = new Peer('craftmine-' + roomCode);
                this.isHost = true;
                this.peer.on('open', (id) => {
                    this.myId = id;
                    this.hostId = id;
                    this.playerList = [{ id: this.myId, name: this.myName, joinOrder: 0 }];
                    this.connected = true;
                    callback(roomCode);
                });
                this.peer.on('connection', (conn) => this.handleIncomingConnection(conn));
                this.peer.on('error', (err) => {
                    console.error('PeerJS host error:', err);
                    if (err.type === 'unavailable-id') {
                        // Room code collision, try again
                        this.peer.destroy();
                        this.initAsHost(callback);
                    }
                });
            }

            initAsClient(roomCode, callback, errorCallback) {
                this.peer = new Peer();
                this.isHost = false;
                this.peer.on('open', (id) => {
                    this.myId = id;
                    const hostPeerId = 'craftmine-' + roomCode.toUpperCase();
                    const conn = this.peer.connect(hostPeerId, { reliable: true });
                    conn.on('open', () => {
                        this.hostId = hostPeerId;
                        this.connections.set(hostPeerId, conn);
                        this.connected = true;
                        this.setupConnection(conn);
                        // Send join request
                        this.send(conn, { type: 'JOIN_REQUEST', name: this.myName });
                    });
                    conn.on('error', (err) => {
                        console.error('Connection error:', err);
                        errorCallback('Failed to connect to host');
                    });
                });
                this.peer.on('connection', (conn) => this.handleIncomingConnection(conn));
                this.peer.on('error', (err) => {
                    console.error('PeerJS client error:', err);
                    errorCallback('Connection failed: ' + err.type);
                });
                this.joinCallback = callback;
            }

            handleIncomingConnection(conn) {
                conn.on('open', () => {
                    this.connections.set(conn.peer, conn);
                    this.setupConnection(conn);
                });
            }

            setupConnection(conn) {
                conn.on('data', (data) => this.handleMessage(conn.peer, data));
                conn.on('close', () => this.handleDisconnect(conn.peer));
                conn.on('error', () => this.handleDisconnect(conn.peer));
            }

            send(conn, msg) {
                try { if (conn.open) conn.send(msg); }
                catch(e) { console.warn('Send failed:', e); }
            }

            broadcast(msg, excludeId) {
                for (const [peerId, conn] of this.connections) {
                    if (peerId !== excludeId) this.send(conn, msg);
                }
            }

            handleMessage(fromId, msg) {
                switch (msg.type) {
                    case 'JOIN_REQUEST':
                        if (this.isHost) this.handleJoinRequest(fromId, msg);
                        break;
                    case 'JOIN_ACCEPT':
                        this.handleJoinAccept(msg);
                        break;
                    case 'PLAYER_JOINED':
                        this.handlePlayerJoined(msg);
                        break;
                    case 'PLAYER_LEFT':
                        this.handlePlayerLeft(msg);
                        break;
                    case 'PLAYER_STATE':
                        this.handlePlayerState(fromId, msg);
                        break;
                    case 'BLOCK_CHANGE':
                        this.handleBlockChange(fromId, msg);
                        break;
                    case 'ENTITY_SPAWN':
                        this.handleEntitySpawn(msg);
                        break;
                    case 'ENTITY_DEATH':
                        this.handleEntityDeath(msg);
                        break;
                    case 'ENTITY_STATE_BATCH':
                        this.handleEntityStateBatch(msg);
                        break;
                    case 'EXPLOSION':
                        this.handleExplosion(msg);
                        break;
                    case 'WEAPON_FIRE':
                        this.handleWeaponFire(fromId, msg);
                        break;
                    case 'DAMAGE_ENTITY':
                        if (this.isHost) this.handleDamageEntity(msg);
                        break;
                    case 'PLAYER_DAMAGE':
                        this.handlePlayerDamage(msg);
                        break;
                    case 'HOST_HEARTBEAT':
                        this.lastHostHeartbeat = performance.now() / 1000;
                        break;
                    case 'HOST_MIGRATION':
                        this.handleHostMigration(msg);
                        break;
                    case 'GAME_STATE_SYNC':
                        this.handleGameStateSync(msg);
                        break;
                    case 'CHAT':
                        this.handleChat(msg);
                        break;
                    case 'NPC_SPAWN':
                        this.handleNPCSpawn(msg);
                        break;
                    case 'NPC_DESPAWN':
                        this.handleNPCDespawn(msg);
                        break;
                    case 'NPC_STATE_BATCH':
                        this.handleNPCStateBatch(msg);
                        break;
                    case 'DAMAGE_NPC':
                        this.handleNPCDamage(msg);
                        break;
                    case 'CONNECT_TO_PEER':
                        // Host told us to connect to a new peer
                        if (!this.connections.has(msg.peerId)) {
                            const conn = this.peer.connect(msg.peerId, { reliable: true });
                            conn.on('open', () => {
                                this.connections.set(msg.peerId, conn);
                                this.setupConnection(conn);
                            });
                        }
                        break;
                }
            }

            handleJoinRequest(fromId, msg) {
                const joinOrder = this.playerList.length;
                const newPlayer = { id: fromId, name: msg.name, joinOrder };
                this.playerList.push(newPlayer);

                // Build modified blocks as serializable data
                const modBlocks = [];
                for (const [key, val] of this.game.world.modifiedBlocks) {
                    modBlocks.push({ key, val });
                }

                // Ensure all entities have networkIds before sending
                for (const e of this.game.entityManager.entities) {
                    if (!e.networkId) e.networkId = this.getNextEntityNetId();
                }

                // Build entity data
                const entities = this.game.entityManager.entities.map(e => ({
                    networkId: e.networkId, type: e.type,
                    x: e.position.x, y: e.position.y, z: e.position.z,
                    health: e.health
                }));

                // Build NPC data
                const mgr = this.game.npcManager;
                const npcs = (mgr ? mgr.npcs : []).map(npc => ({
                    npcId: npc.remote.id, name: npc.remote.name,
                    x: npc.position.x, y: npc.position.y, z: npc.position.z,
                    yaw: npc.yaw
                }));

                // Send full state to new player
                const conn = this.connections.get(fromId);
                this.send(conn, {
                    type: 'JOIN_ACCEPT',
                    seed: this.game.world.seed,
                    modifiedBlocks: modBlocks,
                    playerList: this.playerList,
                    entities, npcs,
                    gameTime: this.game.gameTime,
                    dayCount: this.game.dayCount,
                    isRaining: this.game.isRaining
                });

                // Tell all existing peers about the new player
                this.broadcast({ type: 'PLAYER_JOINED', id: fromId, name: msg.name, joinOrder }, fromId);

                // Tell all existing peers to connect to the new peer (full mesh)
                for (const [peerId] of this.connections) {
                    if (peerId !== fromId) {
                        this.send(this.connections.get(peerId), { type: 'CONNECT_TO_PEER', peerId: fromId });
                        this.send(conn, { type: 'CONNECT_TO_PEER', peerId });
                    }
                }

                // Create remote player locally
                const rp = new RemotePlayer(fromId, msg.name, this.game.scene);
                rp.joinOrder = joinOrder;
                this.remotePlayers.set(fromId, rp);
                this.updatePlayerCountUI();
                this.game.addChatMessage(`${msg.name} joined the game`, '#55ff55');
            }

            handleJoinAccept(msg) {
                // Initialize world with host's seed
                this.game.initWorldFromNetwork(msg.seed, msg.modifiedBlocks);
                this.playerList = msg.playerList;
                this.hostId = this.playerList[0].id; // Host is always first

                // Create remote players for everyone already in game
                for (const p of msg.playerList) {
                    if (p.id !== this.myId) {
                        const rp = new RemotePlayer(p.id, p.name, this.game.scene);
                        rp.joinOrder = p.joinOrder;
                        this.remotePlayers.set(p.id, rp);
                    }
                }

                // Apply game state
                this.game.gameTime = msg.gameTime;
                this.game.dayCount = msg.dayCount;
                this.game.isRaining = msg.isRaining;
                if (msg.isRaining) document.querySelector('.rain').classList.add('active');

                // Spawn entities from host
                for (const e of msg.entities) {
                    this.spawnNetworkEntity(e);
                }

                // Spawn NPCs from host
                if (msg.npcs && this.game.npcManager) {
                    if (!this.game.npcManager.remoteNPCs) this.game.npcManager.remoteNPCs = new Map();
                    for (const n of msg.npcs) {
                        const rp = new RemotePlayer(n.npcId, n.name, this.game.scene);
                        rp.position.set(n.x, n.y, n.z);
                        rp.mesh.position.copy(rp.position);
                        rp.mesh.rotation.y = n.yaw || 0;
                        this.game.npcManager.remoteNPCs.set(n.npcId, rp);
                    }
                }

                this.lastHostHeartbeat = performance.now() / 1000;
                this.updatePlayerCountUI();
                if (this.joinCallback) this.joinCallback();
            }

            handlePlayerJoined(msg) {
                if (msg.id === this.myId) return;
                if (!this.remotePlayers.has(msg.id)) {
                    const rp = new RemotePlayer(msg.id, msg.name, this.game.scene);
                    rp.joinOrder = msg.joinOrder;
                    this.remotePlayers.set(msg.id, rp);
                    // Update player list
                    if (!this.playerList.find(p => p.id === msg.id)) {
                        this.playerList.push({ id: msg.id, name: msg.name, joinOrder: msg.joinOrder });
                    }
                    this.updatePlayerCountUI();
                    this.game.addChatMessage(`${msg.name} joined the game`, '#55ff55');
                }
            }

            handlePlayerLeft(msg) {
                this.removePlayer(msg.id);
            }

            handlePlayerState(fromId, msg) {
                const rp = this.remotePlayers.get(fromId);
                if (rp) rp.pushState(msg);
            }

            handleBlockChange(fromId, msg) {
                // Apply block change
                this.game.world.setBlock(msg.x, msg.y, msg.z, msg.blockType);
                this.game.meshBuilder.rebuildChunksNear(msg.x, msg.y, msg.z);
                if (msg.blockType === 0) this.game.audio.play('break');
                else this.game.audio.play('place');
                // If host, rebroadcast to others
                if (this.isHost) {
                    this.broadcast({ type: 'BLOCK_CHANGE', x: msg.x, y: msg.y, z: msg.z, blockType: msg.blockType }, fromId);
                }
            }

            handleEntitySpawn(msg) {
                if (this.isHost) return; // Host already has these
                this.spawnNetworkEntity(msg);
            }

            handleEntityDeath(msg) {
                if (this.isHost) return;
                const entity = this.game.entityManager.entities.find(e => e.networkId === msg.entityId);
                if (entity) {
                    entity.dead = true;
                    entity.deathTimer = 0.5;
                    if (entity.data.hostile) this.game.audio.play(entity.data.boss ? 'demon_death' : 'gore');
                }
            }

            handleEntityStateBatch(msg) {
                if (this.isHost) return;
                this.entityStateCache = msg.entities; // cache for migration
                const hostIds = new Set(msg.entities.map(es => es.id));
                for (const es of msg.entities) {
                    let entity = this.game.entityManager.entities.find(e => e.networkId === es.id);
                    // Auto-create missing entities from batch (handles missed spawns)
                    if (!entity && es.type && !es.dead && MOB_TYPES[es.type]) {
                        try {
                            const pos = new THREE.Vector3(es.x, es.y, es.z);
                            entity = new Entity(es.type, pos, this.game.scene, this.game.world);
                            entity.networkId = es.id;
                            entity.health = es.health;
                            this.game.entityManager.entities.push(entity);
                        } catch(err) { continue; }
                    }
                    if (entity) {
                        entity.networkTarget = new THREE.Vector3(es.x, es.y, es.z);
                        entity.networkYaw = es.yaw;
                        entity.health = es.health;
                        if (es.dead && !entity.dead) {
                            entity.dead = true;
                            entity.deathTimer = 0.5;
                        }
                    }
                }
                // Remove client entities the host no longer reports (despawned out of range)
                const ents = this.game.entityManager.entities;
                for (let i = ents.length - 1; i >= 0; i--) {
                    if (ents[i].networkId && !hostIds.has(ents[i].networkId)) {
                        ents[i].dispose();
                        ents.splice(i, 1);
                    }
                }
            }

            handleExplosion(msg) {
                if (this.isHost) return;
                this.game.projectileSystem.explode(msg.x, msg.y, msg.z, msg.radius);
            }

            handleWeaponFire(fromId, msg) {
                if (fromId === this.myId) return;
                // Render visual-only weapon effects
                const origin = new THREE.Vector3(msg.ox, msg.oy, msg.oz);
                const dir = new THREE.Vector3(msg.dx, msg.dy, msg.dz);
                this.game.projectileSystem.renderWeaponVisual(msg.weaponKey, origin, dir);
            }

            handleDamageEntity(msg) {
                // Host resolves damage
                const entity = this.game.entityManager.entities.find(e => e.networkId === msg.entityId);
                if (entity) {
                    const kb = msg.knockback ? new THREE.Vector3(msg.knockback.x, msg.knockback.y, msg.knockback.z) : null;
                    entity.takeDamage(msg.amount, kb);
                }
            }

            handlePlayerDamage(msg) {
                if (msg.targetPlayerId === this.myId) {
                    this.game.player.takeDamage(msg.amount);
                    this.game.audio.play('hurt');
                    document.getElementById('damage-overlay').classList.add('show');
                    setTimeout(() => document.getElementById('damage-overlay').classList.remove('show'), 200);
                    // Broadcast death message if killed
                    if (this.game.player.health <= 0) {
                        this.broadcast({ type: 'CHAT', from: 'Server', text: `${this.myName} was killed!` });
                    }
                }
            }

            handleHostMigration(msg) {
                this.hostId = msg.newHostId;
                this.playerList = msg.playerList;
                if (msg.newHostId === this.myId) {
                    this.isHost = true;
                    this.game.addChatMessage('You are now the host!', '#ffaa00');
                }
                // Hide migration overlay
                setTimeout(() => {
                    document.getElementById('migration-overlay').classList.remove('show');
                }, 1000);
                this.lastHostHeartbeat = performance.now() / 1000;
                this.updatePlayerCountUI();
            }

            handleGameStateSync(msg) {
                if (this.isHost) return;
                this.game.gameTime = msg.gameTime;
                this.game.dayCount = msg.dayCount;
                if (msg.isRaining !== this.game.isRaining) {
                    this.game.isRaining = msg.isRaining;
                    document.querySelector('.rain').classList.toggle('active', msg.isRaining);
                }
            }

            handleChat(msg) {
                this.game.addChatMessage(`<${msg.from}> ${msg.text}`, '#ffffff');
            }

            // --- NPC sync (host -> clients) ---

            handleNPCSpawn(msg) {
                if (this.isHost) return;
                const mgr = this.game.npcManager;
                if (!mgr) return;
                // Don't duplicate
                if (mgr.remoteNPCs && mgr.remoteNPCs.has(msg.npcId)) return;
                const rp = new RemotePlayer(msg.npcId, msg.name, this.game.scene);
                rp.position.set(msg.x, msg.y, msg.z);
                rp.mesh.position.copy(rp.position);
                if (!mgr.remoteNPCs) mgr.remoteNPCs = new Map();
                mgr.remoteNPCs.set(msg.npcId, rp);
            }

            handleNPCDespawn(msg) {
                if (this.isHost) return;
                const mgr = this.game.npcManager;
                if (!mgr || !mgr.remoteNPCs) return;
                const rp = mgr.remoteNPCs.get(msg.npcId);
                if (rp) { rp.dispose(); mgr.remoteNPCs.delete(msg.npcId); }
            }

            handleNPCStateBatch(msg) {
                if (this.isHost) return;
                const mgr = this.game.npcManager;
                if (!mgr) return;
                if (!mgr.remoteNPCs) mgr.remoteNPCs = new Map();
                for (const ns of msg.npcs) {
                    let rp = mgr.remoteNPCs.get(ns.id);
                    if (!rp) {
                        // Auto-create if we missed the spawn
                        rp = new RemotePlayer(ns.id, ns.name, this.game.scene);
                        mgr.remoteNPCs.set(ns.id, rp);
                    }
                    rp.pushState({
                        x: ns.x, y: ns.y, z: ns.z,
                        vx: 0, vy: 0, vz: 0,
                        yaw: ns.yaw, pitch: 0,
                        health: CONFIG.MAX_HEALTH, hotbarIndex: 0,
                        sneaking: false, flying: false
                    });
                }
            }

            broadcastNPCSpawn(npc) {
                if (!this.connected || !this.isHost) return;
                this.broadcast({
                    type: 'NPC_SPAWN', npcId: npc.remote.id, name: npc.remote.name,
                    x: npc.position.x, y: npc.position.y, z: npc.position.z
                });
            }

            broadcastNPCDespawn(npcId) {
                if (!this.connected || !this.isHost) return;
                this.broadcast({ type: 'NPC_DESPAWN', npcId });
            }

            // Client -> host: request NPC damage
            sendNPCDamage(npcId, amount) {
                if (!this.connected) return;
                if (this.isHost) {
                    this.handleNPCDamage({ npcId, amount });
                } else {
                    const hostConn = this.connections.get(this.hostId);
                    if (hostConn) this.send(hostConn, { type: 'DAMAGE_NPC', npcId, amount });
                }
            }

            // Host -> all: broadcast NPC damage visual (red flash on clients)
            broadcastNPCDamage(npcId, amount) {
                if (!this.connected || !this.isHost) return;
                this.broadcast({ type: 'DAMAGE_NPC', npcId, amount, fromHost: true });
            }

            handleNPCDamage(msg) {
                if (this.isHost) {
                    // Host resolves damage on local NPC
                    const mgr = this.game.npcManager;
                    if (!mgr) return;
                    const npc = mgr.npcs.find(n => n.remote.id === msg.npcId);
                    if (npc && !npc.dead) {
                        npc.takeDamage(msg.amount, null);
                        // Broadcast the damage to all clients for visual feedback
                        this.broadcast({ type: 'DAMAGE_NPC', npcId: msg.npcId, amount: msg.amount, fromHost: true });
                    }
                } else if (msg.fromHost) {
                    // Client: apply visual damage to remote NPC
                    const mgr = this.game.npcManager;
                    if (!mgr || !mgr.remoteNPCs) return;
                    const rp = mgr.remoteNPCs.get(msg.npcId);
                    if (rp) {
                        // Red flash
                        rp.mesh.traverse(c => {
                            if (c.material && !c.material._origColor) {
                                c.material._origColor = c.material.color.getHex();
                                c.material.color.setHex(0xff0000);
                            }
                        });
                        setTimeout(() => {
                            rp.mesh.traverse(c => {
                                if (c.material && c.material._origColor !== undefined) {
                                    c.material.color.setHex(c.material._origColor);
                                    delete c.material._origColor;
                                }
                            });
                        }, 300);
                    }
                }
            }

            sendChat(text) {
                const msg = { type: 'CHAT', from: this.myName, text };
                this.broadcast(msg);
                this.game.addChatMessage(`<${this.myName}> ${text}`, '#ffffff');
            }

            spawnNetworkEntity(e) {
                const pos = new THREE.Vector3(e.x, e.y, e.z);
                // entityType is used in ENTITY_SPAWN messages, type in JOIN_ACCEPT entity data
                const mobType = e.entityType || e.type;
                if (!mobType || !MOB_TYPES[mobType]) return;
                try {
                    const entity = new Entity(mobType, pos, this.game.scene, this.game.world);
                    entity.networkId = e.networkId || e.entityId;
                    entity.health = e.health || entity.maxHealth;
                    this.game.entityManager.entities.push(entity);
                } catch(err) {
                    console.warn('Failed to spawn network entity:', mobType, err);
                }
            }

            removePlayer(peerId) {
                const rp = this.remotePlayers.get(peerId);
                if (rp) {
                    const name = rp.name;
                    rp.dispose();
                    this.remotePlayers.delete(peerId);
                    this.game.addChatMessage(`${name} left the game`, '#ff5555');
                }
                this.connections.delete(peerId);
                this.playerList = this.playerList.filter(p => p.id !== peerId);
                this.updatePlayerCountUI();
                // Broadcast PLAYER_LEFT if host
                if (this.isHost) {
                    this.broadcast({ type: 'PLAYER_LEFT', id: peerId });
                }
            }

            handleDisconnect(peerId) {
                this.removePlayer(peerId);
                // Check if host disconnected
                if (peerId === this.hostId && !this.isHost) {
                    this.checkHostMigration();
                }
            }

            checkHostMigration() {
                // Filter out disconnected host
                this.playerList = this.playerList.filter(p => p.id !== this.hostId);
                if (this.playerList.length === 0) return;

                // Sort by joinOrder, first in line becomes host
                this.playerList.sort((a, b) => a.joinOrder - b.joinOrder);
                const newHostId = this.playerList[0].id;

                document.getElementById('migration-overlay').classList.add('show');

                if (newHostId === this.myId) {
                    // I'm the new host
                    this.isHost = true;
                    this.hostId = this.myId;
                    this.game.addChatMessage('You are now the host!', '#ffaa00');

                    // Restore entities from cache
                    if (this.entityStateCache.length > 0) {
                        for (const es of this.entityStateCache) {
                            const entity = this.game.entityManager.entities.find(e => e.networkId === es.id);
                            if (entity) {
                                entity.position.set(es.x, es.y, es.z);
                            }
                        }
                    }

                    // Broadcast migration to all
                    this.broadcast({
                        type: 'HOST_MIGRATION',
                        newHostId: this.myId,
                        playerList: this.playerList
                    });

                    setTimeout(() => {
                        document.getElementById('migration-overlay').classList.remove('show');
                    }, 1500);
                }
            }

            broadcastBlockChange(x, y, z, blockType) {
                if (!this.connected) return;
                const msg = { type: 'BLOCK_CHANGE', x, y, z, blockType };
                if (this.isHost) {
                    this.broadcast(msg);
                } else {
                    // Send to host, host rebroadcasts
                    const hostConn = this.connections.get(this.hostId);
                    if (hostConn) this.send(hostConn, msg);
                }
            }

            broadcastWeaponFire(weaponKey, origin, direction) {
                if (!this.connected) return;
                this.broadcast({
                    type: 'WEAPON_FIRE', weaponKey,
                    ox: origin.x, oy: origin.y, oz: origin.z,
                    dx: direction.x, dy: direction.y, dz: direction.z
                });
            }

            broadcastExplosion(x, y, z, radius) {
                if (!this.connected || !this.isHost) return;
                this.broadcast({ type: 'EXPLOSION', x, y, z, radius });
            }

            broadcastEntitySpawn(entity) {
                if (!this.connected || !this.isHost) return;
                this.broadcast({
                    type: 'ENTITY_SPAWN', entityId: entity.networkId, entityType: entity.type,
                    x: entity.position.x, y: entity.position.y, z: entity.position.z
                });
            }

            broadcastEntityDeath(entityId) {
                if (!this.connected || !this.isHost) return;
                this.broadcast({ type: 'ENTITY_DEATH', entityId });
            }

            sendDamageEntity(entityId, amount, knockback) {
                if (!this.connected) return;
                if (this.isHost) {
                    // Resolve locally
                    const entity = this.game.entityManager.entities.find(e => e.networkId === entityId);
                    if (entity) entity.takeDamage(amount, knockback);
                } else {
                    const hostConn = this.connections.get(this.hostId);
                    if (hostConn) {
                        this.send(hostConn, {
                            type: 'DAMAGE_ENTITY', entityId, amount,
                            knockback: knockback ? { x: knockback.x, y: knockback.y, z: knockback.z } : null
                        });
                    }
                }
            }

            broadcastPlayerDamage(targetPlayerId, amount) {
                if (!this.connected || !this.isHost) return;
                const conn = this.connections.get(targetPlayerId);
                if (conn) this.send(conn, { type: 'PLAYER_DAMAGE', targetPlayerId, amount });
            }

            update(dt) {
                if (!this.connected) return;
                const now = performance.now() / 1000;

                // Broadcast own player state at 20Hz
                if (now - this.lastPlayerBroadcast > 0.05) {
                    this.lastPlayerBroadcast = now;
                    const p = this.game.player;
                    this.broadcast({
                        type: 'PLAYER_STATE',
                        x: p.position.x, y: p.position.y, z: p.position.z,
                        vx: p.velocity.x, vy: p.velocity.y, vz: p.velocity.z,
                        yaw: p.yaw, pitch: p.pitch,
                        health: p.health, hotbarIndex: p.hotbarIndex,
                        sneaking: p.sneaking, flying: p.flying
                    });
                }

                // Host broadcasts entity states at 10Hz
                if (this.isHost && now - this.lastEntityBroadcast > 0.1) {
                    this.lastEntityBroadcast = now;
                    const entities = this.game.entityManager.entities
                        .filter(e => e.networkId)
                        .map(e => ({
                            id: e.networkId, type: e.type,
                            x: e.position.x, y: e.position.y, z: e.position.z,
                            vx: e.velocity.x, vy: e.velocity.y, vz: e.velocity.z,
                            health: e.health, yaw: e.mesh ? e.mesh.rotation.y : 0, dead: e.dead
                        }));
                    if (entities.length > 0) {
                        this.broadcast({ type: 'ENTITY_STATE_BATCH', entities });
                    }

                    // Also broadcast NPC states at 10Hz (skip dead NPCs)
                    const mgr = this.game.npcManager;
                    if (mgr && mgr.npcs.length > 0) {
                        const npcs = mgr.npcs.filter(n => !n.dead).map(npc => ({
                            id: npc.remote.id, name: npc.remote.name,
                            x: npc.position.x, y: npc.position.y, z: npc.position.z,
                            yaw: npc.yaw, health: npc.health
                        }));
                        this.broadcast({ type: 'NPC_STATE_BATCH', npcs });
                    }
                }

                // Host broadcasts game state at 2Hz
                if (this.isHost && now - this.lastGameStateBroadcast > 0.5) {
                    this.lastGameStateBroadcast = now;
                    this.broadcast({
                        type: 'GAME_STATE_SYNC',
                        gameTime: this.game.gameTime, dayCount: this.game.dayCount,
                        isRaining: this.game.isRaining
                    });
                }

                // Host heartbeat at 1Hz
                if (this.isHost && now - this.lastHeartbeat > 1.0) {
                    this.lastHeartbeat = now;
                    this.broadcast({ type: 'HOST_HEARTBEAT', timestamp: now });
                }

                // Client: check for host timeout
                if (!this.isHost && this.lastHostHeartbeat > 0) {
                    if (now - this.lastHostHeartbeat > this.hostHeartbeatTimeout) {
                        this.lastHostHeartbeat = now; // prevent repeated triggers
                        this.checkHostMigration();
                    }
                }

                // Interpolate remote players
                for (const [, rp] of this.remotePlayers) {
                    rp.interpolate();
                }
            }

            getNextEntityNetId() {
                return this.nextEntityNetId++;
            }

            updatePlayerCountUI() {
                const count = this.remotePlayers.size + 1;
                const el = document.getElementById('player-count');
                el.textContent = `Players: ${count}`;
                el.style.display = count > 1 ? 'block' : (this.connected ? 'block' : 'none');
                // Update lobby player count if visible
                const roomCount = document.getElementById('room-player-count');
                if (roomCount) roomCount.textContent = `${count} player${count > 1 ? 's' : ''}`;
            }

            disconnect() {
                this.broadcast({ type: 'PLAYER_LEFT', id: this.myId });
                for (const [, rp] of this.remotePlayers) rp.dispose();
                this.remotePlayers.clear();
                this.connections.clear();
                if (this.peer) this.peer.destroy();
                this.connected = false;
                document.getElementById('player-count').style.display = 'none';
            }
        }

        // ============================================
        // NPC MANAGER - Fake players that wander/follow
        // ============================================
        const NPC_NAMES = [
            'Alex', 'Steve', 'Notch', 'Jeb', 'Herobrine', 'Dinnerbone',
            'xXSlayerXx', 'ProMiner99', 'BlockKing', 'DiamondDave',
            'TNTSteve', 'CreeperHug', 'GhostFace', 'PixelNinja',
            'SkyWalker', 'IronGolem', 'RedstoneWiz', 'EndermanFan'
        ];

        class NPCPlayer {
            constructor(name, scene, world) {
                this.scene = scene;
                this.world = world;
                this.remote = new RemotePlayer('npc-' + Math.random().toString(36).slice(2), name, scene);
                this.position = this.remote.position;
                this.velocity = new THREE.Vector3();
                this.yaw = Math.random() * Math.PI * 2;
                this.onGround = false;
                this.wanderTimer = 0;
                this.wanderDir = new THREE.Vector3();
                this.followTarget = null;
                this.followDist = 0;
                this.state = 'wander'; // 'wander' | 'follow' | 'idle'
                this.idleTimer = 0;
                this.jumpCooldown = 0;
                this.stateTimer = 5 + Math.random() * 10;
                // Combat
                this.health = 20;
                this.maxHealth = 20;
                this.dead = false;
                this.deathTimer = 0;
                this.hurtTimer = 0;
                this.respawnTimer = 0;
            }

            takeDamage(amount, knockbackDir = null) {
                if (this.dead) return;
                this.health -= amount;
                this.hurtTimer = 0.3;
                // Red flash
                this.remote.mesh.traverse(c => {
                    if (c.material && !c.material._origColor) {
                        c.material._origColor = c.material.color.getHex();
                        c.material.color.setHex(0xff0000);
                    }
                });
                // Knockback
                if (knockbackDir) {
                    this.velocity.add(knockbackDir.clone().multiplyScalar(6));
                    this.velocity.y = 4;
                }
                if (this.health <= 0) this.die();
            }

            die() {
                this.dead = true;
                this.deathTimer = 1.5;
                this.velocity.set(0, 3, 0);
            }

            spawn(playerPos) {
                const angle = Math.random() * Math.PI * 2;
                const dist = 15 + Math.random() * 25;
                const sx = playerPos.x + Math.cos(angle) * dist;
                const sz = playerPos.z + Math.sin(angle) * dist;
                let sy = -1;
                for (let y = CONFIG.WORLD_HEIGHT - 1; y >= 0; y--) {
                    if (this.world.isSolid(sx, y, sz)) { sy = y + 1; break; }
                }
                if (sy < 0) sy = 60;
                this.position.set(sx, sy, sz);
            }

            update(dt, playerPos) {
                // Handle hurt flash recovery
                if (this.hurtTimer > 0) {
                    this.hurtTimer -= dt;
                    if (this.hurtTimer <= 0) {
                        this.remote.mesh.traverse(c => {
                            if (c.material && c.material._origColor !== undefined) {
                                c.material.color.setHex(c.material._origColor);
                                delete c.material._origColor;
                            }
                        });
                    }
                }

                // Handle death
                if (this.dead) {
                    this.deathTimer -= dt;
                    this.remote.mesh.rotation.z += dt * 3;
                    this.remote.mesh.position.y -= dt * 2;
                    if (this.deathTimer <= 0) {
                        // Respawn
                        this.dead = false;
                        this.health = this.maxHealth;
                        this.remote.mesh.rotation.z = 0;
                        this.remote.mesh.visible = true;
                        this.spawn(playerPos);
                        return 'respawned';
                    }
                    return null;
                }

                this.stateTimer -= dt;
                this.jumpCooldown -= dt;

                // Decide state
                const distToPlayer = this.position.distanceTo(playerPos);
                if (this.stateTimer <= 0) {
                    this.stateTimer = 4 + Math.random() * 8;
                    const roll = Math.random();
                    if (distToPlayer < 30 && roll < 0.4) {
                        this.state = 'follow';
                        this.followDist = 3 + Math.random() * 4;
                    } else if (roll < 0.7) {
                        this.state = 'wander';
                        const a = Math.random() * Math.PI * 2;
                        this.wanderDir.set(Math.cos(a), 0, Math.sin(a));
                    } else {
                        this.state = 'idle';
                        this.idleTimer = 2 + Math.random() * 3;
                    }
                }

                // Despawn if too far
                if (distToPlayer > 80) return 'despawn';

                const moveSpeed = 4.5;
                let moveX = 0, moveZ = 0;

                if (this.state === 'follow') {
                    const dx = playerPos.x - this.position.x;
                    const dz = playerPos.z - this.position.z;
                    const dist = Math.sqrt(dx * dx + dz * dz);
                    if (dist > this.followDist) {
                        moveX = (dx / dist) * moveSpeed;
                        moveZ = (dz / dist) * moveSpeed;
                        this.yaw = Math.atan2(-dx, -dz);
                    }
                } else if (this.state === 'wander') {
                    moveX = this.wanderDir.x * moveSpeed * 0.5;
                    moveZ = this.wanderDir.z * moveSpeed * 0.5;
                    this.yaw = Math.atan2(-this.wanderDir.x, -this.wanderDir.z);
                }
                // idle: no movement

                // Gravity
                this.velocity.x = moveX;
                this.velocity.z = moveZ;
                this.velocity.y -= CONFIG.GRAVITY * dt;
                this.velocity.y = Math.max(this.velocity.y, -30);

                // Move with simple collision
                const nx = this.position.x + this.velocity.x * dt;
                const nz = this.position.z + this.velocity.z * dt;
                const ny = this.position.y + this.velocity.y * dt;

                // X
                if (!this.isSolidAt(nx, this.position.y, this.position.z)) {
                    this.position.x = nx;
                } else {
                    // Try step up
                    if (this.onGround && !this.isSolidAt(nx, this.position.y + 1, this.position.z)) {
                        this.position.x = nx;
                        this.position.y += 1;
                    } else {
                        this.velocity.x = 0;
                        // Change direction on wall hit
                        if (this.state === 'wander') {
                            const a = Math.random() * Math.PI * 2;
                            this.wanderDir.set(Math.cos(a), 0, Math.sin(a));
                        }
                    }
                }
                // Z
                if (!this.isSolidAt(this.position.x, this.position.y, nz)) {
                    this.position.z = nz;
                } else {
                    if (this.onGround && !this.isSolidAt(this.position.x, this.position.y + 1, nz)) {
                        this.position.z = nz;
                        this.position.y += 1;
                    } else {
                        this.velocity.z = 0;
                        if (this.state === 'wander') {
                            const a = Math.random() * Math.PI * 2;
                            this.wanderDir.set(Math.cos(a), 0, Math.sin(a));
                        }
                    }
                }
                // Y
                if (!this.isSolidAt(this.position.x, ny, this.position.z)) {
                    this.position.y = ny;
                    this.onGround = false;
                } else {
                    if (this.velocity.y < 0) this.onGround = true;
                    this.velocity.y = 0;
                }

                // Jump over obstacles / randomly
                if (this.onGround && this.jumpCooldown <= 0) {
                    const ahead = new THREE.Vector3(this.position.x + Math.sin(this.yaw) * 0.8, this.position.y, this.position.z + Math.cos(this.yaw) * 0.8);
                    if (this.world.isSolid(ahead.x, ahead.y + 0.5, ahead.z) || Math.random() < 0.005) {
                        this.velocity.y = CONFIG.JUMP_FORCE;
                        this.onGround = false;
                        this.jumpCooldown = 0.5;
                    }
                }

                // Fall respawn
                if (this.position.y < -10) return 'despawn';

                // Update visual
                this.remote.mesh.position.copy(this.position);
                this.remote.mesh.rotation.y = this.yaw;
                // Walk animation
                const isMoving = Math.abs(moveX) > 0.1 || Math.abs(moveZ) > 0.1;
                const walkCycle = performance.now() / 200;
                const swing = isMoving ? Math.sin(walkCycle) * 0.6 : 0;
                this.remote.leftArm.rotation.x = swing;
                this.remote.rightArm.rotation.x = -swing;
                this.remote.leftLeg.rotation.x = -swing;
                this.remote.rightLeg.rotation.x = swing;

                return null;
            }

            isSolidAt(x, y, z) {
                const hw = 0.3;
                const points = [
                    [x - hw, y, z - hw], [x + hw, y, z - hw],
                    [x - hw, y, z + hw], [x + hw, y, z + hw],
                    [x - hw, y + 1.6, z - hw], [x + hw, y + 1.6, z - hw],
                    [x - hw, y + 1.6, z + hw], [x + hw, y + 1.6, z + hw],
                ];
                for (const [px, py, pz] of points) {
                    if (this.world.isSolid(px, py, pz)) return true;
                }
                return false;
            }

            dispose() {
                this.remote.dispose();
            }
        }

        class NPCManager {
            constructor(scene, world) {
                this.scene = scene;
                this.world = world;
                this.game = null;
                this.npcs = []; // Host-side: actual NPCPlayer instances with AI
                this.remoteNPCs = new Map(); // Client-side: RemotePlayer meshes from network
                this.spawnTimer = 3;
                this.maxNPCs = 4;
                this.usedNames = new Set();
            }

            get isNetClient() {
                return this.game && this.game.networkManager && !this.game.networkManager.isHost && this.game.isMultiplayer;
            }

            pickName() {
                const available = NPC_NAMES.filter(n => !this.usedNames.has(n));
                if (available.length === 0) return 'Player' + Math.floor(Math.random() * 999);
                const name = available[Math.floor(Math.random() * available.length)];
                this.usedNames.add(name);
                return name;
            }

            update(dt, playerPos) {
                // Client: only interpolate remote NPCs from network data
                if (this.isNetClient) {
                    for (const [, rp] of this.remoteNPCs) {
                        rp.interpolate();
                    }
                    return;
                }

                // Host / singleplayer: run AI
                this.spawnTimer -= dt;
                if (this.spawnTimer <= 0 && this.npcs.length < this.maxNPCs) {
                    this.spawnTimer = 8 + Math.random() * 15;
                    const npc = new NPCPlayer(this.pickName(), this.scene, this.world);
                    npc.spawn(playerPos);
                    this.npcs.push(npc);
                    // Broadcast spawn
                    if (this.game && this.game.networkManager) {
                        this.game.networkManager.broadcastNPCSpawn(npc);
                    }
                }

                for (let i = this.npcs.length - 1; i >= 0; i--) {
                    const result = this.npcs[i].update(dt, playerPos);
                    if (result === 'despawn') {
                        const npcId = this.npcs[i].remote.id;
                        this.usedNames.delete(this.npcs[i].remote.name);
                        this.npcs[i].dispose();
                        this.npcs.splice(i, 1);
                        // Broadcast despawn
                        if (this.game && this.game.networkManager) {
                            this.game.networkManager.broadcastNPCDespawn(npcId);
                        }
                    }
                }
            }

            dispose() {
                for (const npc of this.npcs) npc.dispose();
                this.npcs = [];
                for (const [, rp] of this.remoteNPCs) rp.dispose();
                this.remoteNPCs.clear();
                this.usedNames.clear();
            }
        }

        // ============================================
        // GAME
        // ============================================
        class Game {
            constructor() {
                this.container = document.getElementById('game-container');
                this.debug = document.getElementById('debug');
                this.audio = new AudioSystem();
                this.networkManager = null;
                this.isMultiplayer = false;
                this.gameStarted = false;

                this.initRenderer();
                this.initScene();
                this.initLighting();
                this.initLobby();
            }

            initGame(seed) {
                this.world = new World(seed);
                this.world.seed = seed;
                this.meshBuilder = new MeshBuilder(this.scene, this.world);
                this.player = new Player(this.camera, this.world);
                this.projectileSystem = new ProjectileSystem(this.scene, this.world, this.meshBuilder, this.audio);
                this.projectileSystem.game = this;
                this.entityManager = new EntityManager(this.scene, this.world, this.audio);
                this.entityManager.game = this;
                this.projectileSystem.setEntityManager(this.entityManager);
                this.npcManager = new NPCManager(this.scene, this.world);
                this.npcManager.game = this;

                this.initHotbar();
                this.initControls();
                this.initHealthBar();
                this.initPauseMenu();

                this.highlightMesh = this.createHighlightMesh();
                this.scene.add(this.highlightMesh);

                this.isLocked = false;
                this.isPaused = false;
                this.clock = new THREE.Clock();
                this.lastChunkUpdate = 0;
                this.frameCount = 0; this.fps = 0; this.lastFpsTime = performance.now();
                this.isShooting = false; this.lastShotTime = 0;
                this.screenShake = 0; this.cameraOffset = new THREE.Vector3();
                this.weaponInfoTimeout = null;

                // Day/night cycle
                this.gameTime = 0.25;
                this.dayCount = 1;
                this.timeCycleEnabled = true;
                this.weatherEnabled = false;
                this.isRaining = false;

                // UI visibility
                this.showDebug = true;
                this.showUI = true;

                // Chat
                this.chatMessages = [];
                this.chatOpen = false;

                this.findSpawnPoint();
                this.camera.position.set(this.player.position.x, this.player.position.y + CONFIG.PLAYER_EYE_HEIGHT, this.player.position.z);
                this.camera.rotation.order = 'YXZ';
                this.camera.rotation.y = this.player.yaw;
                this.camera.rotation.x = this.player.pitch;
                this.updateChunks();

                // Hide lobby, show game
                document.getElementById('lobby').classList.add('hidden');
                document.getElementById('click-to-start').style.display = 'block';
                document.getElementById('crosshair').style.display = 'block';
                document.getElementById('hotbar').style.display = 'flex';
                document.getElementById('debug').style.display = 'block';
                document.getElementById('game-mode').style.display = 'block';
                document.getElementById('time-display').style.display = 'block';
                document.getElementById('health-bar').style.display = 'flex';

                document.getElementById('click-to-start').addEventListener('click', () => this.startGame());
                document.addEventListener('click', (e) => {
                    if (!this.isLocked && !this.isPaused && this.gameStarted && !this.chatOpen && e.target.tagName !== 'INPUT' && e.target.tagName !== 'BUTTON') this.startGame();
                });

                this.gameStarted = true;
                this.animate();
            }

            initLobby() {
                const lobbyStatus = document.getElementById('lobby-status');
                const joinInput = document.getElementById('join-input');

                document.getElementById('btn-singleplayer').addEventListener('click', () => {
                    this.startSingleplayer();
                });

                document.getElementById('btn-host').addEventListener('click', () => {
                    lobbyStatus.textContent = 'Creating room...';
                    document.getElementById('btn-host').disabled = true;
                    this.startAsHost();
                });

                document.getElementById('btn-join').addEventListener('click', () => {
                    const code = joinInput.value.trim();
                    if (!code) { lobbyStatus.textContent = 'Enter a room code!'; return; }
                    lobbyStatus.textContent = 'Connecting...';
                    document.getElementById('btn-join').disabled = true;
                    this.startAsClient(code);
                });

                // Auto-uppercase and allow Enter key to join
                joinInput.addEventListener('input', () => {
                    joinInput.value = joinInput.value.toUpperCase();
                });
                joinInput.addEventListener('keydown', (e) => {
                    if (e.code === 'Enter') document.getElementById('btn-join').click();
                });
            }

            startSingleplayer() {
                this.isMultiplayer = false;
                this.initGame(Date.now());
            }

            startAsHost() {
                this.isMultiplayer = true;
                const seed = Date.now();
                this.networkManager = new NetworkManager(this);
                this.networkManager.initAsHost((roomCode) => {
                    this._hostSeed = seed;
                    this._hostRoomCode = roomCode;

                    // Hide main buttons, show room info
                    document.getElementById('lobby-btns').classList.add('hidden');
                    document.getElementById('lobby-status').textContent = '';
                    document.getElementById('room-info').style.display = 'block';
                    document.getElementById('room-code-display').textContent = roomCode;

                    // Click code to copy
                    const codeEl = document.getElementById('room-code-display');
                    codeEl.addEventListener('click', () => this.copyRoomCode(roomCode));

                    // Start Game button
                    document.getElementById('btn-start-host').addEventListener('click', () => {
                        this.initGame(seed);
                        // Show persistent room code badge in-game
                        const badge = document.getElementById('room-badge');
                        badge.textContent = `Room: ${roomCode}`;
                        badge.style.display = 'block';
                        badge.addEventListener('click', () => this.copyRoomCode(roomCode));
                        document.getElementById('disconnect-btn').style.display = 'block';
                        document.getElementById('player-count').style.display = 'block';
                        document.getElementById('player-count').textContent = 'Players: 1';
                        this.networkManager.updatePlayerCountUI();
                    });

                    // Cancel button
                    document.getElementById('btn-cancel-host').addEventListener('click', () => {
                        this.networkManager.disconnect();
                        this.networkManager = null;
                        this.isMultiplayer = false;
                        document.getElementById('room-info').style.display = 'none';
                        document.getElementById('lobby-btns').classList.remove('hidden');
                    });
                });
            }

            copyRoomCode(code) {
                navigator.clipboard.writeText(code).then(() => {
                    const msg = document.getElementById('copied-msg');
                    if (msg) { msg.classList.add('show'); setTimeout(() => msg.classList.remove('show'), 1500); }
                    // Also flash the badge if in-game
                    const badge = document.getElementById('room-badge');
                    if (badge && badge.style.display !== 'none') {
                        badge.textContent = 'Copied!';
                        setTimeout(() => { badge.textContent = `Room: ${this._hostRoomCode}`; }, 1200);
                    }
                }).catch(() => {
                    // Fallback - select the text
                    const range = document.createRange();
                    range.selectNode(document.getElementById('room-code-display'));
                    window.getSelection().removeAllRanges();
                    window.getSelection().addRange(range);
                });
            }

            startAsClient(roomCode) {
                this.isMultiplayer = true;
                this._hostRoomCode = roomCode.toUpperCase();
                this.networkManager = new NetworkManager(this);
                this.networkManager.initAsClient(roomCode,
                    () => {
                        // Success - world already initialized in handleJoinAccept -> initWorldFromNetwork
                        document.getElementById('lobby-status').textContent = '';
                        document.getElementById('disconnect-btn').style.display = 'block';
                        document.getElementById('player-count').style.display = 'block';
                        // Show room badge
                        const badge = document.getElementById('room-badge');
                        badge.textContent = `Room: ${this._hostRoomCode}`;
                        badge.style.display = 'block';
                        badge.addEventListener('click', () => this.copyRoomCode(this._hostRoomCode));
                    },
                    (err) => {
                        document.getElementById('lobby-status').textContent = err;
                        this.networkManager = null;
                        this.isMultiplayer = false;
                    }
                );
            }

            initWorldFromNetwork(seed, modifiedBlocks) {
                this.initGame(seed);
                // Apply modified blocks from host
                for (const { key, val } of modifiedBlocks) {
                    this.world.modifiedBlocks.set(key, val);
                    const [x, y, z] = key.split(',').map(Number);
                    const cx = Math.floor(x / CONFIG.CHUNK_SIZE);
                    const cz = Math.floor(z / CONFIG.CHUNK_SIZE);
                    const chunkKey = this.world.getChunkKey(cx, cz);
                    const chunk = this.world.chunks.get(chunkKey);
                    if (chunk) {
                        const lx = ((x % CONFIG.CHUNK_SIZE) + CONFIG.CHUNK_SIZE) % CONFIG.CHUNK_SIZE;
                        const lz = ((z % CONFIG.CHUNK_SIZE) + CONFIG.CHUNK_SIZE) % CONFIG.CHUNK_SIZE;
                        chunk[this.world.getLocalIndex(lx, y, lz)] = val;
                    }
                }
                this.updateChunks();
            }

            addChatMessage(text, color = '#ffffff') {
                const messagesEl = document.getElementById('chat-messages');
                const msgEl = document.createElement('div');
                msgEl.className = 'chat-msg';
                msgEl.style.color = color;
                msgEl.textContent = text;
                messagesEl.appendChild(msgEl);
                messagesEl.scrollTop = messagesEl.scrollHeight;
                // Fade out after 8 seconds
                setTimeout(() => msgEl.classList.add('faded'), 8000);
                setTimeout(() => { if (msgEl.parentNode) msgEl.remove(); }, 9000);
            }

            openChat() {
                this.chatOpen = true;
                document.exitPointerLock();
                const wrap = document.getElementById('chat-input-wrap');
                wrap.classList.add('show');
                const input = document.getElementById('chat-input');
                input.value = '';
                input.focus();
                const handler = (e) => {
                    if (e.code === 'Enter') {
                        const text = input.value.trim();
                        if (text && this.networkManager) {
                            this.networkManager.sendChat(text);
                        }
                        this.closeChat();
                        input.removeEventListener('keydown', handler);
                    } else if (e.code === 'Escape') {
                        this.closeChat();
                        input.removeEventListener('keydown', handler);
                    }
                };
                input.addEventListener('keydown', handler);
            }

            closeChat() {
                this.chatOpen = false;
                document.getElementById('chat-input-wrap').classList.remove('show');
                this.container.requestPointerLock();
            }

            initHealthBar() {
                const healthBar = document.getElementById('health-bar');
                healthBar.innerHTML = '';
                for (let i = 0; i < CONFIG.MAX_HEALTH; i++) {
                    const heart = document.createElement('div');
                    heart.className = 'heart';
                    healthBar.appendChild(heart);
                }
            }

            updateHealthBar() {
                const hearts = document.querySelectorAll('.heart');
                hearts.forEach((heart, i) => {
                    if (i < Math.floor(this.player.health)) {
                        heart.className = 'heart';
                    } else if (i < this.player.health) {
                        heart.className = 'heart half';
                    } else {
                        heart.className = 'heart empty';
                    }
                });
            }

            initPauseMenu() {
                document.getElementById('resume-btn').addEventListener('click', () => this.togglePause());
                document.getElementById('creative-btn').addEventListener('click', () => {
                    this.player.toggleCreativeMode();
                    this.updateGameModeDisplay();
                });
                document.getElementById('weather-btn').addEventListener('click', () => {
                    this.weatherEnabled = !this.weatherEnabled;
                    if (!this.weatherEnabled) {
                        this.isRaining = false;
                        document.querySelector('.rain').classList.remove('active');
                    }
                });
                document.getElementById('time-btn').addEventListener('click', () => {
                    this.timeCycleEnabled = !this.timeCycleEnabled;
                });
                document.getElementById('disconnect-btn').addEventListener('click', () => {
                    if (this.networkManager) {
                        this.networkManager.disconnect();
                        this.networkManager = null;
                        this.isMultiplayer = false;
                    }
                    this.togglePause();
                    this.addChatMessage('Disconnected from game', '#ff5555');
                    document.getElementById('disconnect-btn').style.display = 'none';
                });
            }

            togglePause() {
                this.isPaused = !this.isPaused;
                document.getElementById('pause-menu').classList.toggle('show', this.isPaused);
                if (this.isPaused) {
                    document.exitPointerLock();
                } else {
                    this.container.requestPointerLock();
                }
            }

            updateGameModeDisplay() {
                const modeEl = document.getElementById('game-mode');
                modeEl.textContent = this.player.creativeMode ? 'Creative' : 'Survival';
                modeEl.style.color = this.player.creativeMode ? '#55ff55' : '#ffffff';
            }

            updateDayNightCycle(dt) {
                if (!this.timeCycleEnabled) return;

                this.gameTime += dt / CONFIG.DAY_LENGTH;
                if (this.gameTime >= 1) {
                    this.gameTime -= 1;
                    this.dayCount++;
                }

                // Update sky color based on time
                const dayProgress = this.gameTime;
                let skyColor, fogColor, ambientIntensity, sunIntensity;

                if (dayProgress < 0.25) {
                    // Night to sunrise
                    const t = dayProgress / 0.25;
                    skyColor = new THREE.Color().lerpColors(new THREE.Color(0x0a0a20), new THREE.Color(0xff7733), t);
                    fogColor = skyColor;
                    ambientIntensity = 0.2 + t * 0.3;
                    sunIntensity = t * 0.5;
                } else if (dayProgress < 0.3) {
                    // Sunrise to day
                    const t = (dayProgress - 0.25) / 0.05;
                    skyColor = new THREE.Color().lerpColors(new THREE.Color(0xff7733), new THREE.Color(0x87ceeb), t);
                    fogColor = skyColor;
                    ambientIntensity = 0.5 + t * 0.1;
                    sunIntensity = 0.5 + t * 0.5;
                } else if (dayProgress < 0.7) {
                    // Day
                    skyColor = new THREE.Color(0x87ceeb);
                    fogColor = skyColor;
                    ambientIntensity = 0.6;
                    sunIntensity = 1.0;
                } else if (dayProgress < 0.75) {
                    // Day to sunset
                    const t = (dayProgress - 0.7) / 0.05;
                    skyColor = new THREE.Color().lerpColors(new THREE.Color(0x87ceeb), new THREE.Color(0xff5500), t);
                    fogColor = skyColor;
                    ambientIntensity = 0.6 - t * 0.2;
                    sunIntensity = 1.0 - t * 0.5;
                } else {
                    // Sunset to night
                    const t = (dayProgress - 0.75) / 0.25;
                    skyColor = new THREE.Color().lerpColors(new THREE.Color(0xff5500), new THREE.Color(0x0a0a20), t);
                    fogColor = skyColor;
                    ambientIntensity = 0.4 - t * 0.2;
                    sunIntensity = 0.5 - t * 0.5;
                }

                this.renderer.setClearColor(skyColor);
                this.scene.fog.color = fogColor;
                this.ambientLight.intensity = ambientIntensity;
                this.sunLight.intensity = Math.max(0, sunIntensity);

                // Update sun position
                const sunAngle = dayProgress * Math.PI * 2 - Math.PI / 2;
                this.sunLight.position.set(Math.cos(sunAngle) * 100, Math.sin(sunAngle) * 200, 50);

                // Update time display
                const hours = Math.floor(dayProgress * 24);
                const minutes = Math.floor((dayProgress * 24 - hours) * 60);
                const timeStr = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
                const period = dayProgress < 0.25 || dayProgress > 0.75 ? 'Night' : (dayProgress < 0.5 ? 'Morning' : 'Afternoon');
                document.getElementById('time-display').textContent = `Day ${this.dayCount} - ${timeStr} (${period})`;
            }

            updateWeather(dt) {
                if (!this.weatherEnabled) return;

                // Random weather changes
                if (Math.random() < 0.0005) {
                    this.isRaining = !this.isRaining;
                    document.querySelector('.rain').classList.toggle('active', this.isRaining);
                }
            }

            startGame() {
                this.audio.init();
                this.container.requestPointerLock();
                document.getElementById('click-to-start').style.display = 'none';
            }

            initRenderer() {
                this.renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: 'high-performance' });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                this.renderer.setClearColor(0x87ceeb);
                this.renderer.shadowMap.enabled = false;
                this.container.appendChild(this.renderer.domElement);
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });
            }

            initScene() {
                this.scene = new THREE.Scene();
                this.scene.fog = new THREE.FogExp2(0x87ceeb, 0.008);
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 500);
            }

            initLighting() {
                this.ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                this.scene.add(this.ambientLight);
                this.sunLight = new THREE.DirectionalLight(0xffffee, 1.0);
                this.sunLight.position.set(100, 200, 50);
                this.scene.add(this.sunLight);
                const fill = new THREE.DirectionalLight(0x8888ff, 0.3);
                fill.position.set(-50, 50, -50);
                this.scene.add(fill);
                // Hemisphere light for sky color
                const hemi = new THREE.HemisphereLight(0x87ceeb, 0x5a3a1a, 0.4);
                this.scene.add(hemi);
            }

            createHighlightMesh() {
                const geo = new THREE.BoxGeometry(1.01, 1.01, 1.01);
                const edges = new THREE.EdgesGeometry(geo);
                const mat = new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 2 });
                const mesh = new THREE.LineSegments(edges, mat);
                mesh.visible = false;
                return mesh;
            }

            initHotbar() {
                const hotbar = document.getElementById('hotbar');
                hotbar.innerHTML = '';
                // Create texture generator for hotbar icons
                if (!this.hotbarTextureGen) {
                    this.hotbarTextureGen = new TextureGenerator(32);
                }
                for (let i = 0; i < this.player.hotbar.length; i++) {
                    const slot = document.createElement('div');
                    slot.className = 'hotbar-slot' + (i === this.player.hotbarIndex ? ' selected' : '');
                    const item = this.player.hotbar[i];
                    const preview = document.createElement('div');
                    preview.className = 'block-preview';
                    if (typeof item === 'string' && WEAPONS[item]) {
                        // Use weapon texture
                        const weaponCanvas = this.hotbarTextureGen.generateWeaponTexture(item);
                        weaponCanvas.style.width = '100%';
                        weaponCanvas.style.height = '100%';
                        weaponCanvas.style.imageRendering = 'pixelated';
                        preview.appendChild(weaponCanvas);
                    } else {
                        // Use block texture
                        const blockCanvas = this.hotbarTextureGen.getTexture(item, 'top');
                        if (blockCanvas) {
                            const img = document.createElement('canvas');
                            img.width = 32;
                            img.height = 32;
                            const ctx = img.getContext('2d');
                            ctx.drawImage(blockCanvas, 0, 0, 32, 32);
                            img.style.width = '100%';
                            img.style.height = '100%';
                            img.style.imageRendering = 'pixelated';
                            preview.appendChild(img);
                        } else {
                            const data = BLOCK_DATA[item];
                            preview.style.background = `#${data.colors.top.toString(16).padStart(6, '0')}`;
                        }
                    }
                    const num = document.createElement('span');
                    num.textContent = i < 9 ? (i + 1).toString() : (i === 9 ? '0' : '');
                    slot.appendChild(preview);
                    slot.appendChild(num);
                    hotbar.appendChild(slot);
                }
            }

            updateHotbarSelection() {
                const slots = document.querySelectorAll('.hotbar-slot');
                slots.forEach((slot, i) => slot.classList.toggle('selected', i === this.player.hotbarIndex));
                const selected = this.player.hotbar[this.player.hotbarIndex];
                this.player.selectedBlock = (typeof selected === 'string') ? null : selected;
                this.updateCrosshair();
                this.showWeaponInfo();
            }

            updateCrosshair() {
                const crosshair = document.getElementById('crosshair');
                const selected = this.player.hotbar[this.player.hotbarIndex];
                crosshair.className = '';
                if (typeof selected === 'string' && WEAPONS[selected]) {
                    crosshair.classList.add(WEAPONS[selected].crosshair);
                } else {
                    crosshair.classList.add('default');
                }
            }

            showWeaponInfo() {
                const info = document.getElementById('weapon-info');
                const selected = this.player.hotbar[this.player.hotbarIndex];
                if (typeof selected === 'string' && WEAPONS[selected]) {
                    info.textContent = WEAPONS[selected].name;
                    info.style.color = WEAPONS[selected].color;
                } else if (BLOCK_DATA[selected]) {
                    info.textContent = BLOCK_DATA[selected].name;
                    info.style.color = '#fff';
                }
                info.classList.add('show');
                clearTimeout(this.weaponInfoTimeout);
                this.weaponInfoTimeout = setTimeout(() => info.classList.remove('show'), 1500);
            }

            initControls() {
                document.addEventListener('pointerlockchange', () => {
                    this.isLocked = document.pointerLockElement === this.container;
                    if (!this.isLocked && !this.isPaused) {
                        // In multiplayer, don't show the blocking overlay - just a small hint
                        if (this.isMultiplayer) {
                            document.getElementById('click-to-start').style.display = 'none';
                        } else {
                            document.getElementById('click-to-start').style.display = 'block';
                        }
                    }
                    // In multiplayer, clear movement keys on unlock to prevent stuck movement
                    if (!this.isLocked && this.player) {
                        this.player.keys.forward = false;
                        this.player.keys.backward = false;
                        this.player.keys.left = false;
                        this.player.keys.right = false;
                        this.player.keys.jump = false;
                        this.player.keys.sneak = false;
                        this.isShooting = false;
                    }
                });

                document.addEventListener('mousemove', (e) => {
                    if (!this.isLocked || this.isPaused) return;
                    this.player.yaw -= e.movementX * CONFIG.MOUSE_SENSITIVITY;
                    this.player.pitch -= e.movementY * CONFIG.MOUSE_SENSITIVITY;
                    this.player.pitch = Math.max(-Math.PI/2 + 0.01, Math.min(Math.PI/2 - 0.01, this.player.pitch));
                });

                document.addEventListener('keydown', (e) => {
                    // Handle escape for pause menu
                    if (e.code === 'Escape') {
                        if (this.isLocked || this.isPaused) {
                            e.preventDefault();
                            this.togglePause();
                        }
                        return;
                    }

                    // Global keybinds (work even when paused)
                    switch(e.code) {
                        case 'F1':
                            e.preventDefault();
                            this.showUI = !this.showUI;
                            document.getElementById('hotbar').style.display = this.showUI ? 'flex' : 'none';
                            document.getElementById('health-bar').style.display = this.showUI ? 'flex' : 'none';
                            document.getElementById('game-mode').style.display = this.showUI ? 'block' : 'none';
                            document.getElementById('crosshair').style.display = this.showUI ? 'block' : 'none';
                            document.getElementById('weapon-info').style.display = this.showUI ? 'block' : 'none';
                            return;
                        case 'F3':
                            e.preventDefault();
                            this.showDebug = !this.showDebug;
                            document.getElementById('debug').style.display = this.showDebug ? 'block' : 'none';
                            document.getElementById('time-display').style.display = this.showDebug ? 'block' : 'none';
                            return;
                    }

                    // Chat toggle
                    if (e.code === 'KeyT' && this.isLocked && !this.isPaused && this.isMultiplayer && !this.chatOpen) {
                        e.preventDefault();
                        this.openChat();
                        return;
                    }

                    if (!this.isLocked || this.isPaused) return;

                    switch(e.code) {
                        case 'KeyW': this.player.keys.forward = true; break;
                        case 'KeyS': this.player.keys.backward = true; break;
                        case 'KeyA': this.player.keys.left = true; break;
                        case 'KeyD': this.player.keys.right = true; break;
                        case 'Space':
                            this.player.keys.jump = true;
                            e.preventDefault();
                            // Double-tap to toggle flying
                            const now = performance.now();
                            if (now - (this.lastSpacePress || 0) < 300) {
                                this.player.flying = !this.player.flying;
                                if (!this.player.creativeMode && this.player.flying) {
                                    this.player.creativeMode = true;
                                    this.updateGameModeDisplay();
                                }
                            }
                            this.lastSpacePress = now;
                            break;
                        case 'ShiftLeft': case 'ShiftRight': this.player.keys.sneak = true; break;
                        case 'KeyF':
                            if (this.player.creativeMode) {
                                this.player.flying = !this.player.flying;
                            }
                            break;
                        case 'KeyC':
                            this.player.toggleCreativeMode();
                            this.updateGameModeDisplay();
                            break;
                        case 'Digit1': case 'Digit2': case 'Digit3': case 'Digit4': case 'Digit5':
                        case 'Digit6': case 'Digit7': case 'Digit8': case 'Digit9':
                            this.player.hotbarIndex = Math.min(parseInt(e.code.slice(-1)) - 1, this.player.hotbar.length - 1);
                            this.updateHotbarSelection(); break;
                        case 'Digit0':
                            this.player.hotbarIndex = Math.min(9, this.player.hotbar.length - 1);
                            this.updateHotbarSelection(); break;
                    }
                });

                document.addEventListener('keyup', (e) => {
                    switch(e.code) {
                        case 'KeyW': this.player.keys.forward = false; break;
                        case 'KeyS': this.player.keys.backward = false; break;
                        case 'KeyA': this.player.keys.left = false; break;
                        case 'KeyD': this.player.keys.right = false; break;
                        case 'Space': this.player.keys.jump = false; break;
                        case 'ShiftLeft': case 'ShiftRight': this.player.keys.sneak = false; break;
                    }
                });

                document.addEventListener('mousedown', (e) => {
                    if (!this.isLocked) return;
                    if (e.button === 0) { this.isShooting = true; this.handleLeftClick(); }
                    else if (e.button === 2) this.handleRightClick();
                });

                document.addEventListener('mouseup', (e) => { if (e.button === 0) this.isShooting = false; });

                document.addEventListener('wheel', (e) => {
                    if (!this.isLocked) return;
                    this.player.hotbarIndex = (this.player.hotbarIndex + (e.deltaY > 0 ? 1 : -1) + this.player.hotbar.length) % this.player.hotbar.length;
                    this.updateHotbarSelection();
                });

                document.addEventListener('contextmenu', (e) => e.preventDefault());
            }

            handleLeftClick() {
                const selected = this.player.hotbar[this.player.hotbarIndex];
                if (typeof selected === 'string' && WEAPONS[selected]) {
                    this.shootWeapon(selected);
                } else {
                    const target = this.player.getTargetBlock();
                    if (target && target.hit.block !== BLOCKS.BEDROCK) {
                        this.world.setBlock(target.hit.x, target.hit.y, target.hit.z, BLOCKS.AIR);
                        this.meshBuilder.rebuildChunksNear(target.hit.x, target.hit.y, target.hit.z);
                        this.audio.play('break');
                        if (this.networkManager) {
                            this.networkManager.broadcastBlockChange(target.hit.x, target.hit.y, target.hit.z, BLOCKS.AIR);
                        }
                    }
                }
            }

            handleRightClick() {
                const selected = this.player.hotbar[this.player.hotbarIndex];
                if (typeof selected === 'string') return;
                const target = this.player.getTargetBlock();
                if (!target) return;
                const { x, y, z } = target.place;
                const p = this.player.position, hw = this.player.width/2, h = this.player.height;
                if (p.x+hw > x && p.x-hw < x+1 && p.y+h > y && p.y < y+1 && p.z+hw > z && p.z-hw < z+1) return;
                this.world.setBlock(x, y, z, selected);
                this.meshBuilder.rebuildChunksNear(x, y, z);
                this.audio.play('place');
                if (this.networkManager) {
                    this.networkManager.broadcastBlockChange(x, y, z, selected);
                }
            }

            shootWeapon(weaponKey) {
                const weapon = WEAPONS[weaponKey];
                const now = performance.now() / 1000;
                if (now - this.lastShotTime < weapon.fireRate) return;
                this.lastShotTime = now;

                const dir = new THREE.Vector3(0, 0, -1).applyQuaternion(this.camera.quaternion);
                const origin = this.camera.position.clone().add(dir.clone().multiplyScalar(0.5));

                // Broadcast weapon fire to network
                if (this.networkManager) {
                    this.networkManager.broadcastWeaponFire(weaponKey, origin, dir);
                }

                switch(weaponKey) {
                    case 'TNT_GUN': this.projectileSystem.shootTNT(origin, dir, weapon.projectileSpeed); break;
                    case 'LASER_GUN':
                        this.projectileSystem.shootLaser(origin, dir, weapon.range);
                        this.entityManager.damageEntityAtRay(origin, dir, weapon.range, weapon.damage);
                        this.damagePlayersAtRay(origin, dir, weapon.range, weapon.damage);
                        break;
                    case 'RAILGUN':
                        this.projectileSystem.shootRailgun(origin, dir);
                        this.entityManager.damageEntityAtRay(origin, dir, 150, 50);
                        this.damagePlayersAtRay(origin, dir, 150, 50);
                        break;
                    case 'MINIGUN':
                        this.projectileSystem.shootMinigun(origin, dir, weapon.spread);
                        this.entityManager.damageEntityAtRay(origin, dir, 80, weapon.damage);
                        this.damagePlayersAtRay(origin, dir, 80, weapon.damage);
                        break;
                    case 'FREEZE_RAY': this.projectileSystem.shootFreezeRay(origin, dir); break;
                    case 'SWORD':
                        this.projectileSystem.shootSword(origin, dir);
                        this.entityManager.damageEntityAtRay(origin, dir, 4, 7);
                        this.damagePlayersAtRay(origin, dir, 4, 7);
                        break;
                    case 'CHAINSAW':
                        this.projectileSystem.shootChainsaw(origin, dir);
                        this.entityManager.damageEntityAtRay(origin, dir, 3, 5);
                        this.damagePlayersAtRay(origin, dir, 3, 5);
                        break;
                    case 'BOW': this.projectileSystem.shootBow(origin, dir, weapon.projectileSpeed); break;
                    case 'GRENADE': this.projectileSystem.shootGrenade(origin, dir, weapon.projectileSpeed); break;
                    case 'ROCKET_LAUNCHER': this.projectileSystem.shootRocket(origin, dir, weapon.projectileSpeed); break;
                    case 'SHOTGUN':
                        for (let i = 0; i < weapon.pellets; i++) {
                            const spread = new THREE.Vector3(
                                dir.x + (Math.random() - 0.5) * weapon.spread,
                                dir.y + (Math.random() - 0.5) * weapon.spread,
                                dir.z + (Math.random() - 0.5) * weapon.spread
                            ).normalize();
                            this.projectileSystem.shootMinigun(origin.clone(), spread, 0);
                            this.entityManager.damageEntityAtRay(origin, spread, 40, weapon.damage);
                            this.damagePlayersAtRay(origin, spread, 40, weapon.damage);
                        }
                        break;
                    case 'PLASMA_CANNON': this.projectileSystem.shootPlasma(origin, dir, weapon.projectileSpeed); break;
                    case 'FLAMETHROWER':
                        this.projectileSystem.shootFlame(origin, dir);
                        this.entityManager.damageEntitiesInRadius(origin.clone().add(dir.clone().multiplyScalar(5)), 3, weapon.damage);
                        this.damagePlayersInRadius(origin.clone().add(dir.clone().multiplyScalar(5)), 3, weapon.damage);
                        break;
                    case 'LIGHTNING_STAFF':
                        this.projectileSystem.shootLightning(origin, dir, weapon.range);
                        this.entityManager.damageEntityAtRay(origin, dir, weapon.range, weapon.damage);
                        this.damagePlayersAtRay(origin, dir, weapon.range, weapon.damage);
                        // Chain to nearby enemies and players
                        const hitPos = origin.clone().add(dir.clone().multiplyScalar(weapon.range / 2));
                        this.entityManager.damageEntitiesInRadius(hitPos, 8, weapon.damage / 2);
                        this.damagePlayersInRadius(hitPos, 8, weapon.damage / 2);
                        break;
                    case 'CLUSTER_BOMB': this.projectileSystem.shootCluster(origin, dir, weapon.projectileSpeed, weapon.cluster); break;
                    case 'BFG': this.projectileSystem.shootBFG(origin, dir, weapon.projectileSpeed); break;
                    case 'NUKE_LAUNCHER': this.projectileSystem.shootNuke(origin, dir, weapon.projectileSpeed); break;
                    case 'GRAVITY_GUN':
                        this.projectileSystem.shootGravityWave(origin, dir);
                        // Push all entities and players away
                        for (const entity of this.entityManager.entities) {
                            const toEntity = entity.position.clone().sub(origin);
                            if (toEntity.length() < 20 && toEntity.dot(dir) > 0) {
                                entity.velocity.add(dir.clone().multiplyScalar(15));
                                entity.velocity.y += 5;
                            }
                        }
                        this.damagePlayersAtRay(origin, dir, 20, 3);
                        break;
                    case 'BLACK_HOLE': this.projectileSystem.shootBlackHole(origin, dir, weapon.projectileSpeed); break;
                }

                const shakeAmount = {
                    'RAILGUN': 0.3, 'MINIGUN': 0.02, 'SWORD': 0.05, 'BOW': 0.03, 'GRENADE': 0.04,
                    'ROCKET_LAUNCHER': 0.25, 'SHOTGUN': 0.2, 'PLASMA_CANNON': 0.15, 'FLAMETHROWER': 0.01,
                    'LIGHTNING_STAFF': 0.1, 'CLUSTER_BOMB': 0.15, 'BFG': 0.5, 'NUKE_LAUNCHER': 0.4,
                    'GRAVITY_GUN': 0.05, 'BLACK_HOLE': 0.3
                };
                this.screenShake = Math.max(this.screenShake, shakeAmount[weaponKey] || 0.08);

                // Only show muzzle flash for guns
                if (!['SWORD', 'BOW', 'GRENADE'].includes(weaponKey)) {
                    const flash = document.getElementById('muzzle-flash');
                    flash.classList.add('flash');
                    setTimeout(() => flash.classList.remove('flash'), 30);
                }
            }

            // PvP: ray test against players and NPCs (0.4x damage - players are tougher)
            damagePlayersAtRay(origin, direction, range, damage) {
                const pvpDamage = damage * 0.4;
                let closestHit = null;
                let closestDist = range;

                const testHit = (center, hitRadius) => {
                    const toTarget = center.clone().sub(origin);
                    const proj = toTarget.dot(direction);
                    if (proj < 0 || proj > range) return null;
                    const closest = origin.clone().add(direction.clone().multiplyScalar(proj));
                    return center.distanceTo(closest) < hitRadius && proj < closestDist ? proj : null;
                };

                // Check remote players
                if (this.networkManager) {
                    for (const [peerId, rp] of this.networkManager.remotePlayers) {
                        const center = rp.position.clone(); center.y += 0.9;
                        const d = testHit(center, 0.8);
                        if (d !== null) { closestDist = d; closestHit = { type: 'player', id: peerId }; }
                    }
                }

                // Check NPCs (host: local npcs, client: remoteNPCs)
                if (this.npcManager) {
                    if (this.npcManager.npcs) {
                        for (const npc of this.npcManager.npcs) {
                            if (npc.dead) continue;
                            const center = npc.position.clone(); center.y += 0.9;
                            const d = testHit(center, 0.8);
                            if (d !== null) { closestDist = d; closestHit = { type: 'npc', npc }; }
                        }
                    }
                    if (this.npcManager.remoteNPCs) {
                        for (const [npcId, rp] of this.npcManager.remoteNPCs) {
                            const center = rp.position.clone(); center.y += 0.9;
                            const d = testHit(center, 0.8);
                            if (d !== null) { closestDist = d; closestHit = { type: 'remoteNpc', npcId }; }
                        }
                    }
                }

                if (closestHit) {
                    const kb = direction.clone();
                    if (closestHit.type === 'player') {
                        this.sendPvPDamage(closestHit.id, pvpDamage);
                    } else if (closestHit.type === 'npc') {
                        closestHit.npc.takeDamage(pvpDamage, kb);
                        if (this.networkManager) this.networkManager.broadcastNPCDamage(closestHit.npc.remote.id, pvpDamage);
                    } else if (closestHit.type === 'remoteNpc') {
                        if (this.networkManager) this.networkManager.sendNPCDamage(closestHit.npcId, pvpDamage);
                    }
                    this.audio.play('hit');
                    return true;
                }
                return false;
            }

            // PvP: radius damage against players and NPCs (explosions)
            damagePlayersInRadius(position, radius, damage) {
                const pvpDamage = damage * 0.4;
                if (this.networkManager) {
                    for (const [peerId, rp] of this.networkManager.remotePlayers) {
                        const dist = rp.position.distanceTo(position);
                        if (dist < radius) this.sendPvPDamage(peerId, pvpDamage * (1 - dist / radius));
                    }
                }
                if (this.npcManager) {
                    if (this.npcManager.npcs) {
                        for (const npc of this.npcManager.npcs) {
                            if (npc.dead) continue;
                            const dist = npc.position.distanceTo(position);
                            if (dist < radius) {
                                const dmg = pvpDamage * (1 - dist / radius);
                                const kb = npc.position.clone().sub(position).normalize();
                                npc.takeDamage(dmg, kb);
                                if (this.networkManager) this.networkManager.broadcastNPCDamage(npc.remote.id, dmg);
                            }
                        }
                    }
                    if (this.npcManager.remoteNPCs) {
                        for (const [npcId, rp] of this.npcManager.remoteNPCs) {
                            const dist = rp.position.distanceTo(position);
                            if (dist < radius) {
                                if (this.networkManager) this.networkManager.sendNPCDamage(npcId, pvpDamage * (1 - dist / radius));
                            }
                        }
                    }
                }
            }

            sendPvPDamage(targetPeerId, amount) {
                if (!this.networkManager || !this.networkManager.connected) return;
                const conn = this.networkManager.connections.get(targetPeerId);
                if (conn) this.networkManager.send(conn, { type: 'PLAYER_DAMAGE', targetPlayerId: targetPeerId, amount });
            }

            findSpawnPoint() {
                for (let cx = -1; cx <= 1; cx++) for (let cz = -1; cz <= 1; cz++) this.world.generateChunk(cx, cz);
                for (let y = CONFIG.WORLD_HEIGHT - 1; y >= 0; y--) {
                    if (this.world.isSolid(8, y, 8)) {
                        this.player.position.set(8.5, y + 1.5, 8.5);
                        this.player.lastY = y + 1.5;
                        this.player.fallDistance = 0;
                        this.player.spawnGrace = 1.0;
                        break;
                    }
                }
            }

            updateChunks() {
                const pcx = Math.floor(this.player.position.x / CONFIG.CHUNK_SIZE);
                const pcz = Math.floor(this.player.position.z / CONFIG.CHUNK_SIZE);
                const chunksToLoad = [];
                for (let dx = -CONFIG.RENDER_DISTANCE; dx <= CONFIG.RENDER_DISTANCE; dx++) {
                    for (let dz = -CONFIG.RENDER_DISTANCE; dz <= CONFIG.RENDER_DISTANCE; dz++) {
                        if (dx*dx + dz*dz > CONFIG.RENDER_DISTANCE * CONFIG.RENDER_DISTANCE) continue;
                        const key = `${pcx+dx},${pcz+dz}`;
                        if (!this.meshBuilder.chunkMeshes.has(key) && !this.meshBuilder.pendingChunks.has(key)) {
                            chunksToLoad.push({ cx: pcx+dx, cz: pcz+dz, dist: dx*dx + dz*dz });
                        }
                    }
                }
                chunksToLoad.sort((a, b) => a.dist - b.dist);
                for (const { cx, cz } of chunksToLoad) this.meshBuilder.buildChunkMeshAsync(cx, cz);

                const removeDistance = CONFIG.RENDER_DISTANCE + 2;
                for (const [key] of this.meshBuilder.chunkMeshes) {
                    const [cx, cz] = key.split(',').map(Number);
                    if ((cx-pcx)*(cx-pcx) + (cz-pcz)*(cz-pcz) > removeDistance * removeDistance) {
                        this.meshBuilder.removeChunk(cx, cz);
                    }
                }
            }

            updateFrustumCulling() {
                // Create frustum from camera
                this.frustum = this.frustum || new THREE.Frustum();
                this.projScreenMatrix = this.projScreenMatrix || new THREE.Matrix4();
                this.projScreenMatrix.multiplyMatrices(this.camera.projectionMatrix, this.camera.matrixWorldInverse);
                this.frustum.setFromProjectionMatrix(this.projScreenMatrix);

                // Cull chunks based on frustum
                const chunkHalfSize = CONFIG.CHUNK_SIZE / 2;
                const chunkHeight = CONFIG.WORLD_HEIGHT / 2;

                for (const [key, group] of this.meshBuilder.chunkMeshes) {
                    const [cx, cz] = key.split(',').map(Number);
                    const centerX = cx * CONFIG.CHUNK_SIZE + chunkHalfSize;
                    const centerZ = cz * CONFIG.CHUNK_SIZE + chunkHalfSize;

                    // Create bounding sphere for chunk
                    const sphere = new THREE.Sphere(
                        new THREE.Vector3(centerX, chunkHeight, centerZ),
                        Math.sqrt(chunkHalfSize * chunkHalfSize * 2 + chunkHeight * chunkHeight)
                    );

                    group.visible = this.frustum.intersectsSphere(sphere);
                }
            }

            animate() {
                requestAnimationFrame(() => this.animate());
                const rawDt = this.clock.getDelta();
                const dt = Math.min(rawDt, 0.1); // Clamp to 100ms max - prevents tab-switch burst

                this.frameCount++;
                const now = performance.now();
                if (now - this.lastFpsTime >= 1000) { this.fps = this.frameCount; this.frameCount = 0; this.lastFpsTime = now; }

                // Update network
                if (this.networkManager) this.networkManager.update(dt);

                // Update day/night and weather regardless of pause
                this.updateDayNightCycle(dt);
                this.updateWeather(dt);
                this.meshBuilder.updateWater(dt);

                // In multiplayer: always run simulation. In singleplayer: only when locked & unpaused.
                const canInput = this.isLocked && !this.isPaused;
                const simActive = canInput || this.isMultiplayer;

                if (simActive) {
                    // Player physics always update in multiplayer (gravity etc.), input only when locked
                    if (canInput) {
                        this.player.update(dt);
                    } else if (this.isMultiplayer) {
                        // Still apply gravity/physics but no input
                        const savedKeys = { ...this.player.keys };
                        this.player.keys = { forward: false, backward: false, left: false, right: false, jump: false, sneak: false };
                        this.player.update(dt);
                        this.player.keys = savedKeys;
                    }
                    this.updateHealthBar();

                    // Check for damage from being in lava or drowning in water
                    const playerBlock = this.world.getBlock(
                        Math.floor(this.player.position.x),
                        Math.floor(this.player.position.y),
                        Math.floor(this.player.position.z)
                    );
                    const headBlock = this.world.getBlock(
                        Math.floor(this.player.position.x),
                        Math.floor(this.player.position.y + CONFIG.PLAYER_EYE_HEIGHT),
                        Math.floor(this.player.position.z)
                    );
                    if (playerBlock === BLOCKS.LAVA && !this.player.creativeMode) {
                        this.player.takeDamage(dt * 4); // Lava damage over time
                        document.getElementById('damage-overlay').classList.add('show');
                        setTimeout(() => document.getElementById('damage-overlay').classList.remove('show'), 200);
                    }
                    // Drowning in water
                    const waterOverlay = document.getElementById('water-overlay');
                    const airMeterEl = document.getElementById('air-meter');
                    const wasInWater = this.player.inWater || false;
                    if (headBlock === BLOCKS.WATER) {
                        if (!wasInWater) {
                            this.audio.play('splash');
                            this.player.inWater = true;
                        }
                        waterOverlay.classList.add('show');
                        if (!this.player.creativeMode) {
                            if (this.player.airMeter === undefined) this.player.airMeter = 10;
                            this.player.airMeter -= dt;
                            airMeterEl.classList.add('show');
                            const bubbleCount = Math.ceil(Math.max(0, this.player.airMeter));
                            airMeterEl.innerHTML = '';
                            for (let i = 0; i < 10; i++) {
                                const bubble = document.createElement('div');
                                bubble.className = 'air-bubble' + (i >= bubbleCount ? ' empty' : '');
                                airMeterEl.appendChild(bubble);
                            }
                            if (this.player.airMeter <= 0) {
                                this.player.takeDamage(dt * 2);
                                document.getElementById('damage-overlay').classList.add('show');
                                setTimeout(() => document.getElementById('damage-overlay').classList.remove('show'), 200);
                            }
                        }
                        if (Math.random() < dt * 5) {
                            this.projectileSystem.spawnParticle(
                                this.player.position.x + (Math.random() - 0.5) * 0.5,
                                this.player.position.y + CONFIG.PLAYER_EYE_HEIGHT,
                                this.player.position.z + (Math.random() - 0.5) * 0.5,
                                0xaaddff
                            );
                        }
                        if (Math.random() < dt * 0.5) {
                            this.audio.play('underwater');
                        }
                    } else {
                        if (wasInWater) {
                            this.audio.play('splash');
                            this.player.inWater = false;
                        }
                        waterOverlay.classList.remove('show');
                        airMeterEl.classList.remove('show');
                        this.player.airMeter = 10;
                    }

                    const selected = this.player.hotbar[this.player.hotbarIndex];
                    if (canInput && this.isShooting && typeof selected === 'string' && WEAPONS[selected]) {
                        this.shootWeapon(selected);
                    }

                    const projectileResult = this.projectileSystem.update(dt, this.player.position);

                    // Handle projectile hits on player (fireballs)
                    if (projectileResult && projectileResult.damage && !this.player.creativeMode) {
                        this.player.takeDamage(projectileResult.damage);
                        this.audio.play('hurt');
                        document.getElementById('damage-overlay').classList.add('show');
                        setTimeout(() => document.getElementById('damage-overlay').classList.remove('show'), 200);
                    }

                    // Update NPCs
                    if (this.npcManager) this.npcManager.update(dt, this.player.position);

                    // Update entities
                    const isNight = this.gameTime < 0.25 || this.gameTime > 0.75;
                    const entityResult = this.entityManager.update(dt, this.player.position, isNight, this.projectileSystem);
                    if (entityResult && entityResult.damage && !this.player.creativeMode) {
                        this.player.takeDamage(entityResult.damage);
                        this.audio.play('hurt');
                        document.getElementById('damage-overlay').classList.add('show');
                        setTimeout(() => document.getElementById('damage-overlay').classList.remove('show'), 200);
                    }

                    // Screen shake from explosions
                    if (this.projectileSystem.lastExplosion) {
                        const timeSince = (performance.now() - this.projectileSystem.lastExplosion.time) / 1000;
                        if (timeSince < 0.4) {
                            const exp = this.projectileSystem.lastExplosion;
                            const dist = this.player.position.distanceTo(new THREE.Vector3(exp.x, exp.y, exp.z));
                            const intensity = Math.max(0, 1 - dist / 40) * (1 - timeSince / 0.4);
                            this.screenShake = Math.max(this.screenShake, intensity * 0.4);

                            if (!this.player.creativeMode && dist < 8 && timeSince < 0.05) {
                                const damage = Math.floor((1 - dist / 8) * 5);
                                this.player.takeDamage(damage);
                                document.getElementById('damage-overlay').classList.add('show');
                                setTimeout(() => document.getElementById('damage-overlay').classList.remove('show'), 200);
                            }
                        }
                    }

                    if (this.screenShake > 0.001) {
                        this.cameraOffset.set((Math.random()-0.5)*this.screenShake, (Math.random()-0.5)*this.screenShake, (Math.random()-0.5)*this.screenShake);
                        this.camera.position.add(this.cameraOffset);
                        this.screenShake *= 0.85;
                    }

                    this.lastChunkUpdate += dt;
                    if (this.lastChunkUpdate > 0.2) { this.updateChunks(); this.lastChunkUpdate = 0; }

                    if (canInput) {
                        const target = this.player.getTargetBlock();
                        if (typeof selected !== 'string' && target) {
                            this.highlightMesh.visible = true;
                            this.highlightMesh.position.set(target.hit.x + 0.5, target.hit.y + 0.5, target.hit.z + 0.5);
                        } else {
                            this.highlightMesh.visible = false;
                        }
                    }

                    const biome = this.world.getBiome(Math.floor(this.player.position.x), Math.floor(this.player.position.z));
                    const biomeNames = ['Plains', 'Desert', 'Snow', 'Forest', 'Ocean'];
                    const itemName = typeof selected === 'string' ? WEAPONS[selected]?.name : BLOCK_DATA[selected]?.name;
                    const flyingStr = this.player.flying ? ' [Flying]' : '';
                    const netInfo = this.networkManager && this.networkManager.connected ? `<br>Net: ${this.networkManager.isHost ? 'HOST' : 'CLIENT'} | Players: ${this.networkManager.remotePlayers.size + 1}` : '';
                    this.debug.innerHTML = `FPS: ${this.fps}<br>XYZ: ${this.player.position.x.toFixed(1)} / ${this.player.position.y.toFixed(1)} / ${this.player.position.z.toFixed(1)}<br>Biome: ${biomeNames[biome]}<br>Item: ${itemName || 'Unknown'}${flyingStr}<br>Chunks: ${this.meshBuilder.chunkMeshes.size}<br>Entities: ${this.entityManager.getEntityCount()}<br>Particles: ${this.projectileSystem.particles.length}${netInfo}`;
                }

                // Frustum culling for performance
                this.updateFrustumCulling();
                this.renderer.render(this.scene, this.camera);
            }
        }

        // Start
        window.addEventListener('DOMContentLoaded', () => new Game());
    </script>
</body>
</html>
